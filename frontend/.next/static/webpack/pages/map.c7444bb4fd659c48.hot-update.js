"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/map",{

/***/ "./pages/map.js":
/*!**********************!*\
  !*** ./pages/map.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _src_components_Layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/components/Layout */ \"./src/components/Layout.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/supabase */ \"./lib/supabase.js\");\n/* harmony import */ var _lib_geocoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/geocoding */ \"./lib/geocoding.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Import the map component dynamically to avoid SSR issues with Leaflet\nconst MapComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"src_components_MapComponent_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../src/components/MapComponent */ \"./src/components/MapComponent.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"map.js -> \" + \"../src/components/MapComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = MapComponent;\nfunction MapPage() {\n    _s();\n    const [properties, setProperties] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedProperty, setSelectedProperty] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [geocoding, setGeocoding] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [geocodingLogs, setGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showGeocodingLogs, setShowGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cleaning, setCleaning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cleaningLogs, setCleaningLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showCleaningLogs, setShowCleaningLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [enriching, setEnriching] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [enrichingLogs, setEnrichingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showEnrichingLogs, setShowEnrichingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [mapBounds, setMapBounds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [totalFetched, setTotalFetched] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [sidebarState, setSidebarState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"open\"); // 'open', 'collapsed', or 'fullscreen'\n    const [dataStats, setDataStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalProperties: 0,\n        invalidCoordinates: 0,\n        missingCoordinates: 0,\n        zeroCoordinates: 0,\n        invalidRange: 0,\n        duplicatedLocations: 0\n    });\n    const [lastBounds, setLastBounds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Initial property load on page load\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        loadProperties();\n    }, []);\n    // Reload properties when map bounds change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (mapBounds) {\n            console.log(\"Map bounds changed, loading properties in the visible area\");\n            loadProperties(mapBounds);\n        }\n    }, [\n        mapBounds\n    ]);\n    // Handle map bounds changes\n    const handleBoundsChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((bounds)=>{\n        setMapBounds(bounds);\n    }, []);\n    // Calculate statistics about the property data\n    const calculateStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((propData)=>{\n        if (!propData || !Array.isArray(propData)) return;\n        const missingCoords = propData.filter((p)=>!p.latitude || !p.longitude).length;\n        const zeroCoords = propData.filter((p)=>p.latitude === 0 && p.longitude === 0).length;\n        const invalidRange = propData.filter((p)=>{\n            if (!p.latitude || !p.longitude) return false;\n            const lat = typeof p.latitude === \"number\" ? p.latitude : parseFloat(String(p.latitude));\n            const lng = typeof p.longitude === \"number\" ? p.longitude : parseFloat(String(p.longitude));\n            return isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180;\n        }).length;\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        propData.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        setDataStats({\n            totalProperties: propData.length,\n            invalidCoordinates: missingCoords + zeroCoords + invalidRange,\n            missingCoordinates: missingCoords,\n            zeroCoordinates: zeroCoords,\n            invalidRange: invalidRange,\n            duplicatedLocations: duplicatedCoords,\n            uniqueLocations: coordMap.size\n        });\n    }, []);\n    // Function to load properties with optional bounds filter\n    async function loadProperties() {\n        let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        try {\n            setLoading(true);\n            const options = {\n                sortBy: \"created_at\",\n                sortAsc: false,\n                page: 1,\n                pageSize: 100,\n                filters: {},\n                includeIncomplete: true,\n                includeResearch: true,\n                noLimit: false // Enable pagination\n            };\n            // Apply bounds filter if provided\n            if (bounds) {\n                options.bounds = bounds;\n                // Only load more properties if the bounds have changed significantly\n                const boundsChanged = hasSignificantBoundsChange(bounds, lastBounds);\n                if (!boundsChanged) {\n                    setLoading(false);\n                    return;\n                }\n                setLastBounds(bounds);\n            }\n            const data = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_4__.fetchProperties)(options);\n            // Calculate statistics\n            calculateStats(data);\n            // Enhanced logging for debugging\n            console.log(\"Loaded \".concat(data.length, \" properties for map\"));\n            // Filter out properties with invalid coordinates\n            const validProperties = data.filter((p)=>p.latitude && p.longitude && typeof p.latitude === \"number\" && typeof p.longitude === \"number\" && !(p.latitude === 0 && p.longitude === 0) && p.latitude >= 29.5 && p.latitude <= 31.0 && p.longitude >= -98.0 && p.longitude <= -97.0);\n            setProperties(validProperties);\n            setTotalFetched(validProperties.length);\n        } catch (error) {\n            console.error(\"Error fetching properties:\", error);\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Helper function to check if map bounds have changed significantly\n    function hasSignificantBoundsChange(newBounds, oldBounds) {\n        if (!oldBounds) return true;\n        const oldArea = (oldBounds.north - oldBounds.south) * (oldBounds.east - oldBounds.west);\n        const newArea = (newBounds.north - newBounds.south) * (newBounds.east - newBounds.west);\n        const oldCenterLat = (oldBounds.north + oldBounds.south) / 2;\n        const oldCenterLng = (oldBounds.east + oldBounds.west) / 2;\n        const newCenterLat = (newBounds.north + newBounds.south) / 2;\n        const newCenterLng = (newBounds.east + newBounds.west) / 2;\n        const centerShift = Math.sqrt(Math.pow(newCenterLat - oldCenterLat, 2) + Math.pow(newCenterLng - oldCenterLng, 2));\n        const areaRatio = Math.max(newArea / oldArea, oldArea / newArea);\n        return areaRatio > 1.5 || centerShift > 0.1;\n    }\n    // Function to handle sidebar state change\n    const handleSidebarStateChange = (state)=>{\n        setSidebarState(state);\n    };\n    // Function to batch geocode properties with missing coordinates\n    async function batchGeocodeProperties() {\n        try {\n            setGeocoding(true);\n            clearGeocodingLogs();\n            setShowGeocodingLogs(true);\n            // Filter properties that need geocoding\n            const propsToGeocode = properties.filter((p)=>!p.latitude || !p.longitude || p.latitude === 0 || p.longitude === 0 || p._coordinates_missing || p._needs_geocoding || p._is_grid_pattern);\n            if (propsToGeocode.length === 0) {\n                addGeocodingLog(\"No properties need geocoding\", \"info\");\n                alert(\"No properties need geocoding\");\n                setGeocoding(false);\n                return;\n            }\n            // Confirm with user\n            addGeocodingLog(\"Found \".concat(propsToGeocode.length, \" properties that need geocoding\"), \"info\");\n            if (!confirm(\"This will attempt to geocode \".concat(propsToGeocode.length, \" properties with missing or invalid coordinates. Continue?\"))) {\n                addGeocodingLog(\"Geocoding cancelled by user\", \"warning\");\n                setGeocoding(false);\n                return;\n            }\n            addGeocodingLog(\"Starting batch geocoding of \".concat(propsToGeocode.length, \" properties\"), \"info\");\n            // Process in batches of 25 to avoid rate limits\n            const batchSize = 25;\n            const batches = Math.ceil(propsToGeocode.length / batchSize);\n            let successCount = 0;\n            let failCount = 0;\n            for(let i = 0; i < batches; i++){\n                const start = i * batchSize;\n                const end = Math.min(start + batchSize, propsToGeocode.length);\n                const batch = propsToGeocode.slice(start, end);\n                addGeocodingLog(\"Processing batch \".concat(i + 1, \"/\").concat(batches, \" (\").concat(batch.length, \" properties)\"), \"info\");\n                console.log(\"Processing batch \".concat(i + 1, \"/\").concat(batches, \" (\").concat(batch.length, \" properties)\"));\n                try {\n                    // For each property in the batch, log the property being processed\n                    batch.forEach((property, idx)=>{\n                        const propertyName = property.name || \"Property #\".concat(property.id);\n                        addGeocodingLog(\"[\".concat(i + 1, \".\").concat(idx + 1, \"] Queuing \").concat(propertyName), \"detail\");\n                    });\n                    const geocodedBatch = await (0,_lib_geocoding__WEBPACK_IMPORTED_MODULE_5__.enhancedGeocodeProperties)(batch, (property, status, details)=>{\n                        // This is a callback that will be called for each property as it's processed\n                        const propertyName = property.name || \"Property #\".concat(property.id);\n                        if (status === \"success\") {\n                            addGeocodingLog(\"Geocoded: \".concat(propertyName, \" (\").concat(details, \")\"), \"success\");\n                        } else if (status === \"error\") {\n                            addGeocodingLog(\"Failed: \".concat(propertyName, \" (\").concat(details, \")\"), \"error\");\n                        } else {\n                            addGeocodingLog(\"\".concat(status, \": \").concat(propertyName, \" \").concat(details ? \"(\".concat(details, \")\") : \"\"), \"info\");\n                        }\n                    });\n                    // Count successes and failures\n                    const batchSuccess = geocodedBatch.filter((p)=>p._geocoded).length;\n                    const batchFail = geocodedBatch.filter((p)=>p._geocoding_failed).length;\n                    successCount += batchSuccess;\n                    failCount += batchFail;\n                    addGeocodingLog(\"Batch \".concat(i + 1, \" complete: \").concat(batchSuccess, \" successes, \").concat(batchFail, \" failures\"), batchSuccess > batchFail ? \"success\" : \"warning\");\n                    // Merge geocoded properties back into the main array\n                    const updatedProperties = [\n                        ...properties\n                    ];\n                    geocodedBatch.forEach((geocodedProp)=>{\n                        const index = updatedProperties.findIndex((p)=>p.id === geocodedProp.id);\n                        if (index !== -1) {\n                            updatedProperties[index] = geocodedProp;\n                        }\n                    });\n                    // Update the properties state\n                    setProperties(updatedProperties);\n                    calculateStats(updatedProperties);\n                    // Wait a bit between batches to avoid rate limits\n                    if (i < batches - 1) {\n                        addGeocodingLog(\"Waiting 2 seconds before next batch to avoid rate limits\", \"info\");\n                        await new Promise((resolve)=>setTimeout(resolve, 2000));\n                    }\n                } catch (error) {\n                    console.error(\"Error geocoding batch \".concat(i + 1, \":\"), error);\n                    addGeocodingLog(\"Error with batch \".concat(i + 1, \": \").concat(error.message), \"error\");\n                    failCount += batch.length;\n                }\n            }\n            addGeocodingLog(\"Geocoding complete: \".concat(successCount, \" successes, \").concat(failCount, \" failures\"), successCount > failCount ? \"success\" : \"error\");\n            alert(\"Geocoding complete:\\n\\n\".concat(successCount, \" properties successfully geocoded\\n\").concat(failCount, \" properties failed to geocode\"));\n        } catch (error) {\n            console.error(\"Error in batch geocoding:\", error);\n            addGeocodingLog(\"Geocoding error: \".concat(error.message), \"error\");\n            alert(\"Error geocoding properties: \".concat(error.message));\n        } finally{\n            setGeocoding(false);\n        }\n    }\n    function runPropertyAnalysis() {\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        properties.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        // Find coordinates with multiple properties\n        const multiplePropsLocations = Array.from(coordMap.entries()).filter((param)=>{\n            let [_, count] = param;\n            return count > 1;\n        }).sort((a, b)=>b[1] - a[1]); // Sort by count descending\n        const multiplePropsCount = multiplePropsLocations.reduce((sum, param)=>{\n            let [_, count] = param;\n            return sum + count;\n        }, 0);\n        const uniqueLocations = coordMap.size;\n        // Count by geocoding source if available\n        const bySource = {\n            existing: properties.filter((p)=>p._geocoding_source === \"existing\").length,\n            verified_address: properties.filter((p)=>p._geocoding_source === \"verified_address\").length,\n            full_address: properties.filter((p)=>p._geocoding_source === \"full_address\").length,\n            property_name: properties.filter((p)=>p._geocoding_source === \"property_name\").length,\n            unknown: properties.filter((p)=>p.latitude && p.longitude && !p._geocoding_source).length\n        };\n        alert(\"Map Properties Analysis:\\n\\n\" + \"- Total properties: \".concat(properties.length, \"\\n\") + \"- Properties with invalid coordinates: \".concat(dataStats.invalidCoordinates, \"\\n\") + \"   • Missing coordinates: \".concat(dataStats.missingCoordinates, \"\\n\") + \"   • Zero coordinates: \".concat(dataStats.zeroCoordinates, \"\\n\") + \"   • Invalid coordinate range: \".concat(dataStats.invalidRange, \"\\n\\n\") + \"- Unique locations on map: \".concat(uniqueLocations, \"\\n\") + \"- Properties sharing exact coordinates: \".concat(duplicatedCoords, \"\\n\") + \"- Number of shared locations: \".concat(multiplePropsLocations.length, \"\\n\\n\") + (multiplePropsLocations.length > 0 ? \"Top shared locations:\\n\" + multiplePropsLocations.slice(0, 5).map((param)=>{\n            let [coords, count] = param;\n            return \"   • \".concat(count, \" properties at \").concat(coords);\n        }).join(\"\\n\") : \"\") + \"\\n\\n\" + \"Geocoding sources:\\n\" + \"   • Existing valid: \".concat(bySource.existing, \"\\n\") + \"   • Verified address: \".concat(bySource.verified_address, \"\\n\") + \"   • Full address: \".concat(bySource.full_address, \"\\n\") + \"   • Property name: \".concat(bySource.property_name, \"\\n\") + \"   • Unknown source: \".concat(bySource.unknown, \"\\n\\n\") + \"Note: Properties at identical coordinates will appear as a single marker until clicked.\");\n    }\n    // Function to clean property data\n    async function cleanPropertyData() {\n        try {\n            // Start the cleaning process\n            setLoading(true);\n            setCleaning(true);\n            clearCleaningLogs();\n            setShowCleaningLogs(true);\n            addCleaningLog(\"Starting data cleaning process...\", \"info\");\n            // First, analyze the data to identify issues\n            addCleaningLog(\"Analyzing properties for data quality issues...\", \"info\");\n            const dataIssues = {\n                missingNames: properties.filter((p)=>!p.name || p.name.trim() === \"\").length,\n                incompleteAddresses: properties.filter((p)=>p.address && (!p.city || !p.state)).length,\n                suspiciousZeros: properties.filter((p)=>p.units === 0 || p.num_units === 0).length,\n                suspiciousCoordinates: properties.filter((p)=>{\n                    // Check for suspicious patterns in coordinates\n                    if (!p.latitude || !p.longitude) return false;\n                    const latStr = String(p.latitude);\n                    const lngStr = String(p.longitude);\n                    // Check for very low precision or suspicious patterns\n                    return latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2 || latStr === lngStr || // Same lat/lng is suspicious\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                }).length,\n                duplicateNames: findDuplicates(properties, \"name\"),\n                duplicateAddresses: findDuplicates(properties, \"address\"),\n                testProperties: properties.filter((p)=>p.name && p.name.toLowerCase().includes(\"test\") || p.name && p.name.toLowerCase().includes(\"example\") || p.address && p.address.toLowerCase().includes(\"test\") || p._is_test_property).length\n            };\n            const totalIssues = dataIssues.missingNames + dataIssues.incompleteAddresses + dataIssues.suspiciousZeros + dataIssues.suspiciousCoordinates + dataIssues.duplicateNames.length + dataIssues.duplicateAddresses.length + dataIssues.testProperties;\n            // Log analysis results\n            addCleaningLog(\"Analysis found \".concat(totalIssues, \" data quality issues:\"), \"info\");\n            addCleaningLog(\"- \".concat(dataIssues.missingNames, \" properties missing names\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.incompleteAddresses, \" properties with incomplete addresses\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.suspiciousZeros, \" properties with suspicious zero values\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.suspiciousCoordinates, \" properties with suspicious coordinates\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.duplicateNames.length, \" duplicate property names\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.duplicateAddresses.length, \" duplicate addresses\"), \"detail\");\n            addCleaningLog(\"- \".concat(dataIssues.testProperties, \" potential test/example properties\"), \"detail\");\n            // No issues found\n            if (totalIssues === 0) {\n                addCleaningLog(\"No data issues found that need cleaning\", \"success\");\n                alert(\"No data issues found that need cleaning\");\n                setLoading(false);\n                setCleaning(false);\n                return;\n            }\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(totalIssues, \" data quality issues:\\n\\n\") + \"- \".concat(dataIssues.missingNames, \" properties missing names\\n\") + \"- \".concat(dataIssues.incompleteAddresses, \" properties with incomplete addresses\\n\") + \"- \".concat(dataIssues.suspiciousZeros, \" properties with suspicious zero values\\n\") + \"- \".concat(dataIssues.suspiciousCoordinates, \" properties with suspicious coordinates\\n\") + \"- \".concat(dataIssues.duplicateNames.length, \" duplicate property names\\n\") + \"- \".concat(dataIssues.duplicateAddresses.length, \" duplicate addresses\\n\") + \"- \".concat(dataIssues.testProperties, \" potential test/example properties\\n\\n\") + \"Would you like to clean these issues?\");\n            if (!confirmation) {\n                addCleaningLog(\"Cleaning cancelled by user\", \"warning\");\n                setLoading(false);\n                setCleaning(false);\n                return;\n            }\n            // Optional: offer advanced options\n            const advancedOptions = confirm(\"Would you like to use advanced cleaning options?\\n\\n\" + \"- Fix missing names and extract city/state from addresses\\n\" + \"- Flag suspicious coordinates for geocoding\\n\" + \"- Identify and flag duplicate properties\\n\" + \"- Flag test properties for filtering\\n\\n\" + \"Select 'Cancel' for basic cleaning only.\");\n            addCleaningLog(\"Starting \".concat(advancedOptions ? \"advanced\" : \"basic\", \" cleaning process...\"), \"info\");\n            // Apply fixes to a copy of the properties\n            const cleanedProperties = [\n                ...properties\n            ];\n            // Clean property names\n            let issuesCleaned = 0;\n            addCleaningLog(\"Processing \".concat(properties.length, \" properties...\"), \"info\");\n            properties.forEach((property, index)=>{\n                let propertyCleaned = false;\n                let cleaningNotes = [];\n                // Fix missing names using address\n                if (!property.name || property.name.trim() === \"\") {\n                    if (property.address) {\n                        cleanedProperties[index].name = \"Property at \".concat(property.address.split(\",\")[0]);\n                        addCleaningLog(\"Generated name for property #\".concat(property.id, ': \"').concat(cleanedProperties[index].name, '\"'), \"success\");\n                    } else {\n                        cleanedProperties[index].name = \"Unnamed Property \".concat(property.id.toString().substring(0, 8));\n                        addCleaningLog(\"Generated fallback name for property #\".concat(property.id, ': \"').concat(cleanedProperties[index].name, '\"'), \"success\");\n                    }\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Missing name fixed\");\n                }\n                // Fix missing city/state if address exists\n                if (property.address && (!property.city || !property.state)) {\n                    // Try to extract city and state from address\n                    const addressParts = property.address.split(\",\").map((p)=>p.trim());\n                    if (addressParts.length >= 2 && !property.city) {\n                        cleanedProperties[index].city = addressParts[addressParts.length - 2];\n                        addCleaningLog('Extracted city \"'.concat(cleanedProperties[index].city, '\" for property #').concat(property.id), \"success\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"City extracted from address\");\n                    }\n                    if (addressParts.length >= 1 && !property.state) {\n                        // Try to extract state from the last part of the address\n                        const statePart = addressParts[addressParts.length - 1];\n                        const stateMatch = statePart.match(/[A-Z]{2}/);\n                        if (stateMatch) {\n                            cleanedProperties[index].state = stateMatch[0];\n                            addCleaningLog('Extracted state \"'.concat(cleanedProperties[index].state, '\" for property #').concat(property.id), \"success\");\n                            propertyCleaned = true;\n                            cleaningNotes.push(\"State extracted from address\");\n                        }\n                    }\n                }\n                // Flag suspicious coordinates for advanced cleaning\n                if (advancedOptions) {\n                    const latStr = String(property.latitude || \"\");\n                    const lngStr = String(property.longitude || \"\");\n                    // Check for suspicious patterns in coordinates\n                    const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2;\n                    const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                    if (hasLowPrecision || hasSuspiciousPattern) {\n                        cleanedProperties[index]._is_grid_pattern = true;\n                        cleanedProperties[index]._needs_geocoding = true;\n                        addCleaningLog(\"Flagged suspicious coordinates (\".concat(latStr, \", \").concat(lngStr, \") for property #\").concat(property.id), \"warning\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged suspicious coordinates for geocoding\");\n                    }\n                }\n                // Flag test properties\n                if (property.name && property.name.toLowerCase().includes(\"test\") || property.name && property.name.toLowerCase().includes(\"example\") || property.address && property.address.toLowerCase().includes(\"test\")) {\n                    cleanedProperties[index]._is_test_property = true;\n                    addCleaningLog(\"Flagged test property #\".concat(property.id, ': \"').concat(property.name, '\"'), \"warning\");\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Flagged as test property\");\n                }\n                // Flag suspicious zeros for advanced cleaning\n                if (advancedOptions && (property.units === 0 || property.num_units === 0)) {\n                    // We'll just flag these for now, manual review is needed\n                    if (!cleanedProperties[index]._data_quality_issues) {\n                        cleanedProperties[index]._data_quality_issues = [];\n                    }\n                    cleanedProperties[index]._data_quality_issues.push(\"zero_units\");\n                    addCleaningLog(\"Flagged zero units for property #\".concat(property.id), \"warning\");\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Flagged zero units\");\n                }\n                // Update property with cleaning information\n                if (propertyCleaned) {\n                    cleanedProperties[index]._data_cleaned = true;\n                    cleanedProperties[index]._cleaning_notes = cleaningNotes.join(\", \");\n                    issuesCleaned++;\n                }\n            });\n            addCleaningLog(\"Finished processing. Cleaned \".concat(issuesCleaned, \" properties.\"), \"success\");\n            // Update state with cleaned properties\n            addCleaningLog(\"Updating property data with cleaned values...\", \"info\");\n            setProperties(cleanedProperties);\n            calculateStats(cleanedProperties);\n            // Alert user of results\n            addCleaningLog(\"Data cleaning complete!\", \"success\");\n            alert(\"Data cleaning complete!\\n\\n\" + \"- \".concat(issuesCleaned, \" properties were cleaned\\n\") + \"- Added names to \".concat(dataIssues.missingNames, \" properties\\n\") + \"- Extracted city/state for \".concat(dataIssues.incompleteAddresses, \" properties\\n\") + \"- Flagged \".concat(dataIssues.suspiciousCoordinates, \" suspicious coordinates for geocoding\\n\") + \"- Identified \".concat(dataIssues.duplicateNames.length, \" duplicate names\\n\") + \"- Flagged \".concat(dataIssues.testProperties, \" test properties\\n\\n\") + \"Next steps:\\n\" + '1. Use \"Batch Geocode\" to fix flagged coordinates\\n' + '2. Use \"Properties Analysis\" to review data quality\\n' + \"3. Some properties still require manual review\");\n        } catch (error) {\n            console.error(\"Error cleaning property data:\", error);\n            addCleaningLog(\"Error: \".concat(error.message), \"error\");\n            alert(\"Error cleaning data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n            setCleaning(false);\n        }\n    }\n    // Helper function to find duplicates in properties by field\n    function findDuplicates(array, key) {\n        const counts = {};\n        const duplicates = [];\n        // Skip entries with empty values\n        array.forEach((item)=>{\n            if (item[key] && item[key].trim() !== \"\") {\n                const value = item[key].toLowerCase().trim();\n                counts[value] = (counts[value] || 0) + 1;\n            }\n        });\n        // Find values that appear more than once\n        Object.keys(counts).forEach((value)=>{\n            if (counts[value] > 1) {\n                duplicates.push({\n                    value,\n                    count: counts[value]\n                });\n            }\n        });\n        return duplicates;\n    }\n    // Function to enrich property data with zero values\n    async function enrichPropertyData() {\n        try {\n            setLoading(true);\n            setEnriching(true);\n            clearEnrichingLogs();\n            setShowEnrichingLogs(true);\n            addEnrichingLog(\"Starting data enrichment process...\", \"info\");\n            // Identify properties with suspicious zero values\n            addEnrichingLog(\"Analyzing properties for suspicious zero values...\", \"info\");\n            const suspiciousProperties = properties.filter((p)=>p.units === 0 || p.num_units === 0);\n            if (suspiciousProperties.length === 0) {\n                addEnrichingLog(\"No properties with suspicious zero values found\", \"success\");\n                alert(\"No properties with suspicious zero values found\");\n                setLoading(false);\n                setEnriching(false);\n                return;\n            }\n            addEnrichingLog(\"Found \".concat(suspiciousProperties.length, \" properties with suspicious zero values:\"), \"info\");\n            addEnrichingLog(\"- \".concat(suspiciousProperties.filter((p)=>p.units === 0).length, \" properties with zero units\"), \"detail\");\n            addEnrichingLog(\"- \".concat(suspiciousProperties.filter((p)=>p.num_units === 0).length, \" properties with zero units\"), \"detail\");\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(suspiciousProperties.length, \" properties with suspicious zero values:\\n\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0).length, \" properties with zero units\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.num_units === 0).length, \" properties with zero units\\n\\n\") + \"Would you like to attempt to enrich these properties?\");\n            if (!confirmation) {\n                addEnrichingLog(\"Enrichment cancelled by user\", \"warning\");\n                setLoading(false);\n                setEnriching(false);\n                return;\n            }\n            // Make a copy of the properties for enrichment\n            const enrichedProperties = [\n                ...properties\n            ];\n            let enrichedCount = 0;\n            // Analyze collections of similar properties to derive estimates\n            addEnrichingLog(\"Analyzing property data for statistical enrichment...\", \"info\");\n            // Group properties by city/state for better comparison\n            const cityStateGroups = {};\n            properties.forEach((p)=>{\n                if (p.city && p.state && p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)) {\n                    const key = \"\".concat(p.city.toLowerCase(), \",\").concat(p.state.toLowerCase());\n                    if (!cityStateGroups[key]) {\n                        cityStateGroups[key] = [];\n                    }\n                    cityStateGroups[key].push(p);\n                }\n            });\n            // Calculate median values per city/state\n            const medianValues = {};\n            Object.keys(cityStateGroups).forEach((key)=>{\n                const group = cityStateGroups[key];\n                if (group.length >= 3) {\n                    // Calculate median price per unit\n                    const pricesPerUnit = group.map((p)=>{\n                        const units = p.units || p.num_units || 0;\n                        return units > 0 ? p.price / units : 0;\n                    }).filter((v)=>v > 0).sort((a, b)=>a - b);\n                    const medianPricePerUnit = pricesPerUnit[Math.floor(pricesPerUnit.length / 2)];\n                    // Calculate median year built\n                    const yearBuilt = group.map((p)=>p.year_built).filter((y)=>y && y > 1900).sort((a, b)=>a - b);\n                    const medianYearBuilt = yearBuilt.length > 0 ? yearBuilt[Math.floor(yearBuilt.length / 2)] : null;\n                    medianValues[key] = {\n                        medianPricePerUnit,\n                        medianYearBuilt,\n                        sampleSize: group.length\n                    };\n                    addEnrichingLog(\"Group \".concat(key, \": \").concat(group.length, \" properties, $\").concat(Math.round(medianPricePerUnit).toLocaleString(), \"/unit\"), \"detail\");\n                }\n            });\n            addEnrichingLog(\"Created \".concat(Object.keys(medianValues).length, \" statistical groups for comparison\"), \"info\");\n            addEnrichingLog(\"Starting to process \".concat(suspiciousProperties.length, \" properties with zero values...\"), \"info\");\n            // Enrich properties with suspicious zero values\n            suspiciousProperties.forEach((property)=>{\n                const index = enrichedProperties.findIndex((p)=>p.id === property.id);\n                if (index === -1) return;\n                let isEnriched = false;\n                let enrichmentNotes = [];\n                // Find the best reference group for this property\n                let referenceGroup = null;\n                let referenceKey = null;\n                if (property.city && property.state) {\n                    const key = \"\".concat(property.city.toLowerCase(), \",\").concat(property.state.toLowerCase());\n                    if (medianValues[key]) {\n                        referenceGroup = medianValues[key];\n                        referenceKey = key;\n                        addEnrichingLog(\"Property #\".concat(property.id, \": Found exact city/state match (\").concat(key, \")\"), \"detail\");\n                    }\n                }\n                // If no direct city/state match, use the closest geographically or a general average\n                if (!referenceGroup) {\n                    // Fall back to state-level data or general average\n                    if (property.state) {\n                        const stateGroups = Object.keys(medianValues).filter((key)=>key.endsWith(\",\".concat(property.state.toLowerCase())));\n                        if (stateGroups.length > 0) {\n                            // Use the largest sample from the state\n                            referenceKey = stateGroups.sort((a, b)=>medianValues[b].sampleSize - medianValues[a].sampleSize)[0];\n                            referenceGroup = medianValues[referenceKey];\n                            addEnrichingLog(\"Property #\".concat(property.id, \": Found state-level match (\").concat(referenceKey, \")\"), \"detail\");\n                        }\n                    }\n                    // If still no match, use the overall average\n                    if (!referenceGroup) {\n                        const allPricesPerUnit = properties.filter((p)=>p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)).map((p)=>p.price / (p.units || p.num_units)).sort((a, b)=>a - b);\n                        if (allPricesPerUnit.length > 0) {\n                            referenceGroup = {\n                                medianPricePerUnit: allPricesPerUnit[Math.floor(allPricesPerUnit.length / 2)],\n                                medianYearBuilt: null,\n                                sampleSize: allPricesPerUnit.length\n                            };\n                            referenceKey = \"all_properties\";\n                            addEnrichingLog(\"Property #\".concat(property.id, \": Using global average (\").concat(allPricesPerUnit.length, \" properties)\"), \"detail\");\n                        }\n                    }\n                }\n                // Calculate missing values\n                if (referenceGroup) {\n                    // Fix zero units if price is available\n                    if ((property.units === 0 || !property.units) && (property.num_units === 0 || !property.num_units) && property.price > 0 && referenceGroup.medianPricePerUnit > 0) {\n                        const estimatedUnits = Math.round(property.price / referenceGroup.medianPricePerUnit);\n                        enrichedProperties[index].units = estimatedUnits;\n                        enrichedProperties[index].num_units = estimatedUnits;\n                        addEnrichingLog(\"Property #\".concat(property.id, \": Estimated \").concat(estimatedUnits, \" units based on $\").concat(property.price.toLocaleString(), \" price\"), \"success\");\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated \".concat(estimatedUnits, \" units based on price and \").concat(referenceKey, \" median\"));\n                    }\n                    // Add missing year built if we have a reference\n                    if ((!property.year_built || property.year_built < 1900) && referenceGroup.medianYearBuilt) {\n                        enrichedProperties[index].year_built = referenceGroup.medianYearBuilt;\n                        addEnrichingLog(\"Property #\".concat(property.id, \": Estimated year built as \").concat(referenceGroup.medianYearBuilt), \"success\");\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated year built as \".concat(referenceGroup.medianYearBuilt, \" based on \").concat(referenceKey, \" median\"));\n                    }\n                }\n                // Flag property as needing human review if we couldn't enrich it\n                if (!isEnriched) {\n                    // Mark as needing manual review\n                    if (!enrichedProperties[index]._data_quality_issues) {\n                        enrichedProperties[index]._data_quality_issues = [];\n                    }\n                    enrichedProperties[index]._data_quality_issues.push(\"needs_manual_review\");\n                    addEnrichingLog(\"Property #\".concat(property.id, \": Insufficient data for enrichment, marked for manual review\"), \"warning\");\n                    isEnriched = true;\n                    enrichmentNotes.push(\"Marked for manual review - insufficient data to make estimates\");\n                }\n                // Update property with enrichment information\n                if (isEnriched) {\n                    enrichedProperties[index]._data_enriched = true;\n                    enrichedProperties[index]._enrichment_notes = enrichmentNotes.join(\", \");\n                    enrichedCount++;\n                }\n            });\n            addEnrichingLog(\"Enrichment processing complete. Enriched \".concat(enrichedCount, \" properties.\"), \"success\");\n            // Update state with enriched properties\n            addEnrichingLog(\"Updating property data with enriched values...\", \"info\");\n            setProperties(enrichedProperties);\n            calculateStats(enrichedProperties);\n            // Alert user of results\n            addEnrichingLog(\"Data enrichment complete!\", \"success\");\n            alert(\"Data enrichment complete!\\n\\n\" + \"- \".concat(enrichedCount, \" properties were enriched or marked for review\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0).length, \" properties with zero units processed\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.num_units === 0).length, \" properties with zero units processed\\n\\n\") + \"Next steps:\\n\" + \"1. Review the enriched data for accuracy\\n\" + \"2. Properties marked for manual review need human attention\\n\" + '3. Use \"Properties Analysis\" to verify data quality');\n        } catch (error) {\n            console.error(\"Error enriching property data:\", error);\n            addEnrichingLog(\"Error: \".concat(error.message), \"error\");\n            alert(\"Error enriching data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n            setEnriching(false);\n        }\n    }\n    // Function to add a log entry with timestamp\n    const addGeocodingLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"info\";\n        const timestamp = new Date().toLocaleTimeString();\n        setGeocodingLogs((prevLogs)=>[\n                {\n                    message,\n                    timestamp,\n                    type\n                },\n                ...prevLogs.slice(0, 99) // Keep only the last 100 logs\n            ]);\n    }, []);\n    // Clear logs when starting new geocoding process\n    const clearGeocodingLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setGeocodingLogs([]);\n    }, []);\n    // Function to add a cleaning log entry with timestamp\n    const addCleaningLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"info\";\n        const timestamp = new Date().toLocaleTimeString();\n        setCleaningLogs((prevLogs)=>[\n                {\n                    message,\n                    timestamp,\n                    type\n                },\n                ...prevLogs.slice(0, 99) // Keep only the last 100 logs\n            ]);\n    }, []);\n    // Clear logs when starting new cleaning process\n    const clearCleaningLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setCleaningLogs([]);\n    }, []);\n    // Function to add an enrichment log entry with timestamp\n    const addEnrichingLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"info\";\n        const timestamp = new Date().toLocaleTimeString();\n        setEnrichingLogs((prevLogs)=>[\n                {\n                    message,\n                    timestamp,\n                    type\n                },\n                ...prevLogs.slice(0, 99) // Keep only the last 100 logs\n            ]);\n    }, []);\n    // Clear logs when starting new enrichment process\n    const clearEnrichingLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setEnrichingLogs([]);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_components_Layout__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        title: \"Property Map | Acquire Apartments\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative bg-white min-h-screen\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col h-[calc(100vh-4rem)] overflow-hidden\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"container mx-auto px-4 py-4 flex-shrink-0\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-2xl font-bold text-gray-800\",\n                                children: \"Map View\"\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 900,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-600\",\n                                children: \"Browse properties on the map or use filters to refine your search\"\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 901,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                        lineNumber: 899,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-grow flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex-shrink-0 transition-all duration-300 \".concat(sidebarState === \"collapsed\" ? \"w-12\" : sidebarState === \"fullscreen\" ? \"w-full\" : \"w-full md:w-1/3 lg:w-1/4\"),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"p-4\",\n                                    children: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"src_components_PropertySidebar_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../src/components/PropertySidebar */ \"./src/components/PropertySidebar.tsx\")), {\n                                        loadableGenerated: {\n                                            modules: [\n                                                \"map.js -> \" + \"../src/components/PropertySidebar\"\n                                            ]\n                                        }\n                                    }), {\n                                        properties,\n                                        selectedProperty,\n                                        setSelectedProperty,\n                                        loading,\n                                        sidebarState,\n                                        onSidebarStateChange: handleSidebarStateChange\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                    lineNumber: 911,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 906,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex-grow transition-all duration-300 \".concat(sidebarState === \"fullscreen\" ? \"hidden\" : \"block\"),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"h-full rounded-lg shadow overflow-hidden\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MapComponent, {\n                                        properties: properties,\n                                        selectedProperty: selectedProperty,\n                                        setSelectedProperty: setSelectedProperty,\n                                        onBoundsChange: handleBoundsChange\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 928,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                    lineNumber: 927,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 924,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                        lineNumber: 904,\n                        columnNumber: 11\n                    }, this),\n                    showGeocodingLogs && geocodingLogs.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute bottom-4 right-4 w-96 max-h-64 bg-white rounded-lg shadow-lg overflow-auto p-4 z-50\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between items-center mb-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"font-semibold\",\n                                        children: \"Geocoding Logs\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 942,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>setShowGeocodingLogs(false),\n                                        className: \"text-gray-500 hover:text-gray-700\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                            className: \"w-5 h-5\",\n                                            fill: \"none\",\n                                            stroke: \"currentColor\",\n                                            viewBox: \"0 0 24 24\",\n                                            xmlns: \"http://www.w3.org/2000/svg\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                strokeLinecap: \"round\",\n                                                strokeLinejoin: \"round\",\n                                                strokeWidth: 2,\n                                                d: \"M6 18L18 6M6 6l12 12\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                                lineNumber: 945,\n                                                columnNumber: 21\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                            lineNumber: 944,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 943,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 941,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-1\",\n                                children: geocodingLogs.map((log, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-sm p-1 \".concat(log.type === \"error\" ? \"text-red-600\" : log.type === \"warning\" ? \"text-amber-600\" : log.type === \"success\" ? \"text-green-600\" : \"text-gray-600\"),\n                                        children: log.message\n                                    }, index, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 951,\n                                        columnNumber: 19\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 949,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                        lineNumber: 940,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                lineNumber: 898,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n            lineNumber: 897,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n        lineNumber: 896,\n        columnNumber: 5\n    }, this);\n}\n_s(MapPage, \"JHEppcrWSvVkqojYnAug6H6cVNo=\");\n_c1 = MapPage;\nvar _c, _c1;\n$RefreshReg$(_c, \"MapComponent\");\n$RefreshReg$(_c1, \"MapPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJOE0sSUFBSSxLQUFLLFlBQVksbUJBQ3pCOU0sSUFBSThNLElBQUksS0FBSyxZQUFZLG1CQUN6QjtrREFFQzlNLElBQUlzRyxPQUFPO3VDQU5KTDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQjVCO0dBNTdCd0I1STtNQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9tYXAuanM/ZDI0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9zcmMvY29tcG9uZW50cy9MYXlvdXQnO1xuaW1wb3J0IHsgZmV0Y2hQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IGVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMgfSBmcm9tICcuLi9saWIvZ2VvY29kaW5nJztcblxuLy8gSW1wb3J0IHRoZSBtYXAgY29tcG9uZW50IGR5bmFtaWNhbGx5IHRvIGF2b2lkIFNTUiBpc3N1ZXMgd2l0aCBMZWFmbGV0XG5jb25zdCBNYXBDb21wb25lbnQgPSBkeW5hbWljKFxuICAoKSA9PiBpbXBvcnQoJy4uL3NyYy9jb21wb25lbnRzL01hcENvbXBvbmVudCcpLFxuICB7IHNzcjogZmFsc2UgfVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwUGFnZSgpIHtcbiAgY29uc3QgW3Byb3BlcnRpZXMsIHNldFByb3BlcnRpZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRQcm9wZXJ0eSwgc2V0U2VsZWN0ZWRQcm9wZXJ0eV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtnZW9jb2RpbmcsIHNldEdlb2NvZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtnZW9jb2RpbmdMb2dzLCBzZXRHZW9jb2RpbmdMb2dzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3Nob3dHZW9jb2RpbmdMb2dzLCBzZXRTaG93R2VvY29kaW5nTG9nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjbGVhbmluZywgc2V0Q2xlYW5pbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2xlYW5pbmdMb2dzLCBzZXRDbGVhbmluZ0xvZ3NdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2hvd0NsZWFuaW5nTG9ncywgc2V0U2hvd0NsZWFuaW5nTG9nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlbnJpY2hpbmcsIHNldEVucmljaGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlbnJpY2hpbmdMb2dzLCBzZXRFbnJpY2hpbmdMb2dzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3Nob3dFbnJpY2hpbmdMb2dzLCBzZXRTaG93RW5yaWNoaW5nTG9nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFttYXBCb3VuZHMsIHNldE1hcEJvdW5kc10gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3RvdGFsRmV0Y2hlZCwgc2V0VG90YWxGZXRjaGVkXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2lkZWJhclN0YXRlLCBzZXRTaWRlYmFyU3RhdGVdID0gdXNlU3RhdGUoJ29wZW4nKTsgLy8gJ29wZW4nLCAnY29sbGFwc2VkJywgb3IgJ2Z1bGxzY3JlZW4nXG4gIGNvbnN0IFtkYXRhU3RhdHMsIHNldERhdGFTdGF0c10gPSB1c2VTdGF0ZSh7XG4gICAgdG90YWxQcm9wZXJ0aWVzOiAwLFxuICAgIGludmFsaWRDb29yZGluYXRlczogMCxcbiAgICBtaXNzaW5nQ29vcmRpbmF0ZXM6IDAsXG4gICAgemVyb0Nvb3JkaW5hdGVzOiAwLFxuICAgIGludmFsaWRSYW5nZTogMCxcbiAgICBkdXBsaWNhdGVkTG9jYXRpb25zOiAwXG4gIH0pO1xuICBjb25zdCBbbGFzdEJvdW5kcywgc2V0TGFzdEJvdW5kc10gPSB1c2VTdGF0ZShudWxsKTtcblxuICAvLyBJbml0aWFsIHByb3BlcnR5IGxvYWQgb24gcGFnZSBsb2FkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZFByb3BlcnRpZXMoKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJlbG9hZCBwcm9wZXJ0aWVzIHdoZW4gbWFwIGJvdW5kcyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwQm91bmRzKSB7XG4gICAgICBjb25zb2xlLmxvZygnTWFwIGJvdW5kcyBjaGFuZ2VkLCBsb2FkaW5nIHByb3BlcnRpZXMgaW4gdGhlIHZpc2libGUgYXJlYScpO1xuICAgICAgbG9hZFByb3BlcnRpZXMobWFwQm91bmRzKTtcbiAgICB9XG4gIH0sIFttYXBCb3VuZHNdKTtcblxuICAvLyBIYW5kbGUgbWFwIGJvdW5kcyBjaGFuZ2VzXG4gIGNvbnN0IGhhbmRsZUJvdW5kc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChib3VuZHMpID0+IHtcbiAgICBzZXRNYXBCb3VuZHMoYm91bmRzKTtcbiAgfSwgW10pO1xuXG4gIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzIGFib3V0IHRoZSBwcm9wZXJ0eSBkYXRhXG4gIGNvbnN0IGNhbGN1bGF0ZVN0YXRzID0gdXNlQ2FsbGJhY2soKHByb3BEYXRhKSA9PiB7XG4gICAgaWYgKCFwcm9wRGF0YSB8fCAhQXJyYXkuaXNBcnJheShwcm9wRGF0YSkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBtaXNzaW5nQ29vcmRzID0gcHJvcERhdGEuZmlsdGVyKHAgPT4gIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlKS5sZW5ndGg7XG4gICAgY29uc3QgemVyb0Nvb3JkcyA9IHByb3BEYXRhLmZpbHRlcihwID0+IHAubGF0aXR1ZGUgPT09IDAgJiYgcC5sb25naXR1ZGUgPT09IDApLmxlbmd0aDtcbiAgICBjb25zdCBpbnZhbGlkUmFuZ2UgPSBwcm9wRGF0YS5maWx0ZXIocCA9PiB7XG4gICAgICBpZiAoIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBsYXQgPSB0eXBlb2YgcC5sYXRpdHVkZSA9PT0gJ251bWJlcicgPyBwLmxhdGl0dWRlIDogcGFyc2VGbG9hdChTdHJpbmcocC5sYXRpdHVkZSkpO1xuICAgICAgY29uc3QgbG5nID0gdHlwZW9mIHAubG9uZ2l0dWRlID09PSAnbnVtYmVyJyA/IHAubG9uZ2l0dWRlIDogcGFyc2VGbG9hdChTdHJpbmcocC5sb25naXR1ZGUpKTtcbiAgICAgIHJldHVybiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpIHx8IGxhdCA8IC05MCB8fCBsYXQgPiA5MCB8fCBsbmcgPCAtMTgwIHx8IGxuZyA+IDE4MCk7XG4gICAgfSkubGVuZ3RoO1xuICAgIFxuICAgIC8vIENvdW50IHByb3BlcnRpZXMgYXQgaWRlbnRpY2FsIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgY29vcmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGR1cGxpY2F0ZWRDb29yZHMgPSAwO1xuICAgIFxuICAgIHByb3BEYXRhLmZvckVhY2gocCA9PiB7XG4gICAgICBpZiAocC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSkge1xuICAgICAgICBjb25zdCBjb29yZEtleSA9IGAke3AubGF0aXR1ZGV9LCR7cC5sb25naXR1ZGV9YDtcbiAgICAgICAgaWYgKGNvb3JkTWFwLmhhcyhjb29yZEtleSkpIHtcbiAgICAgICAgICBjb29yZE1hcC5zZXQoY29vcmRLZXksIGNvb3JkTWFwLmdldChjb29yZEtleSkgKyAxKTtcbiAgICAgICAgICBkdXBsaWNhdGVkQ29vcmRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRNYXAuc2V0KGNvb3JkS2V5LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNldERhdGFTdGF0cyh7XG4gICAgICB0b3RhbFByb3BlcnRpZXM6IHByb3BEYXRhLmxlbmd0aCxcbiAgICAgIGludmFsaWRDb29yZGluYXRlczogbWlzc2luZ0Nvb3JkcyArIHplcm9Db29yZHMgKyBpbnZhbGlkUmFuZ2UsXG4gICAgICBtaXNzaW5nQ29vcmRpbmF0ZXM6IG1pc3NpbmdDb29yZHMsXG4gICAgICB6ZXJvQ29vcmRpbmF0ZXM6IHplcm9Db29yZHMsXG4gICAgICBpbnZhbGlkUmFuZ2U6IGludmFsaWRSYW5nZSxcbiAgICAgIGR1cGxpY2F0ZWRMb2NhdGlvbnM6IGR1cGxpY2F0ZWRDb29yZHMsXG4gICAgICB1bmlxdWVMb2NhdGlvbnM6IGNvb3JkTWFwLnNpemVcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGxvYWQgcHJvcGVydGllcyB3aXRoIG9wdGlvbmFsIGJvdW5kcyBmaWx0ZXJcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFByb3BlcnRpZXMoYm91bmRzID0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgXG4gICAgICAgIHNvcnRCeTogJ2NyZWF0ZWRfYXQnLCBcbiAgICAgICAgc29ydEFzYzogZmFsc2UsXG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIHBhZ2VTaXplOiAxMDAsIC8vIFJlZHVjZWQgaW5pdGlhbCBsb2FkIHNpemVcbiAgICAgICAgZmlsdGVyczoge30sXG4gICAgICAgIGluY2x1ZGVJbmNvbXBsZXRlOiB0cnVlLFxuICAgICAgICBpbmNsdWRlUmVzZWFyY2g6IHRydWUsXG4gICAgICAgIG5vTGltaXQ6IGZhbHNlIC8vIEVuYWJsZSBwYWdpbmF0aW9uXG4gICAgICB9O1xuXG4gICAgICAvLyBBcHBseSBib3VuZHMgZmlsdGVyIGlmIHByb3ZpZGVkXG4gICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgIG9wdGlvbnMuYm91bmRzID0gYm91bmRzO1xuICAgICAgICAvLyBPbmx5IGxvYWQgbW9yZSBwcm9wZXJ0aWVzIGlmIHRoZSBib3VuZHMgaGF2ZSBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgY29uc3QgYm91bmRzQ2hhbmdlZCA9IGhhc1NpZ25pZmljYW50Qm91bmRzQ2hhbmdlKGJvdW5kcywgbGFzdEJvdW5kcyk7XG4gICAgICAgIGlmICghYm91bmRzQ2hhbmdlZCkge1xuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0Qm91bmRzKGJvdW5kcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaFByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgICBjYWxjdWxhdGVTdGF0cyhkYXRhKTtcbiAgICAgIFxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7ZGF0YS5sZW5ndGh9IHByb3BlcnRpZXMgZm9yIG1hcGApO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgb3V0IHByb3BlcnRpZXMgd2l0aCBpbnZhbGlkIGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCB2YWxpZFByb3BlcnRpZXMgPSBkYXRhLmZpbHRlcihwID0+IFxuICAgICAgICBwLmxhdGl0dWRlICYmIFxuICAgICAgICBwLmxvbmdpdHVkZSAmJiBcbiAgICAgICAgdHlwZW9mIHAubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIFxuICAgICAgICB0eXBlb2YgcC5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICEocC5sYXRpdHVkZSA9PT0gMCAmJiBwLmxvbmdpdHVkZSA9PT0gMCkgJiZcbiAgICAgICAgcC5sYXRpdHVkZSA+PSAyOS41ICYmIHAubGF0aXR1ZGUgPD0gMzEuMCAmJiBcbiAgICAgICAgcC5sb25naXR1ZGUgPj0gLTk4LjAgJiYgcC5sb25naXR1ZGUgPD0gLTk3LjBcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHNldFByb3BlcnRpZXModmFsaWRQcm9wZXJ0aWVzKTtcbiAgICAgIHNldFRvdGFsRmV0Y2hlZCh2YWxpZFByb3BlcnRpZXMubGVuZ3RoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvcGVydGllczonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBtYXAgYm91bmRzIGhhdmUgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gIGZ1bmN0aW9uIGhhc1NpZ25pZmljYW50Qm91bmRzQ2hhbmdlKG5ld0JvdW5kcywgb2xkQm91bmRzKSB7XG4gICAgaWYgKCFvbGRCb3VuZHMpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIGNvbnN0IG9sZEFyZWEgPSAob2xkQm91bmRzLm5vcnRoIC0gb2xkQm91bmRzLnNvdXRoKSAqIChvbGRCb3VuZHMuZWFzdCAtIG9sZEJvdW5kcy53ZXN0KTtcbiAgICBjb25zdCBuZXdBcmVhID0gKG5ld0JvdW5kcy5ub3J0aCAtIG5ld0JvdW5kcy5zb3V0aCkgKiAobmV3Qm91bmRzLmVhc3QgLSBuZXdCb3VuZHMud2VzdCk7XG4gICAgXG4gICAgY29uc3Qgb2xkQ2VudGVyTGF0ID0gKG9sZEJvdW5kcy5ub3J0aCArIG9sZEJvdW5kcy5zb3V0aCkgLyAyO1xuICAgIGNvbnN0IG9sZENlbnRlckxuZyA9IChvbGRCb3VuZHMuZWFzdCArIG9sZEJvdW5kcy53ZXN0KSAvIDI7XG4gICAgY29uc3QgbmV3Q2VudGVyTGF0ID0gKG5ld0JvdW5kcy5ub3J0aCArIG5ld0JvdW5kcy5zb3V0aCkgLyAyO1xuICAgIGNvbnN0IG5ld0NlbnRlckxuZyA9IChuZXdCb3VuZHMuZWFzdCArIG5ld0JvdW5kcy53ZXN0KSAvIDI7XG4gICAgXG4gICAgY29uc3QgY2VudGVyU2hpZnQgPSBNYXRoLnNxcnQoXG4gICAgICBNYXRoLnBvdyhuZXdDZW50ZXJMYXQgLSBvbGRDZW50ZXJMYXQsIDIpICsgXG4gICAgICBNYXRoLnBvdyhuZXdDZW50ZXJMbmcgLSBvbGRDZW50ZXJMbmcsIDIpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBhcmVhUmF0aW8gPSBNYXRoLm1heChuZXdBcmVhIC8gb2xkQXJlYSwgb2xkQXJlYSAvIG5ld0FyZWEpO1xuICAgIHJldHVybiBhcmVhUmF0aW8gPiAxLjUgfHwgY2VudGVyU2hpZnQgPiAwLjE7XG4gIH1cblxuICAvLyBGdW5jdGlvbiB0byBoYW5kbGUgc2lkZWJhciBzdGF0ZSBjaGFuZ2VcbiAgY29uc3QgaGFuZGxlU2lkZWJhclN0YXRlQ2hhbmdlID0gKHN0YXRlKSA9PiB7XG4gICAgc2V0U2lkZWJhclN0YXRlKHN0YXRlKTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byBiYXRjaCBnZW9jb2RlIHByb3BlcnRpZXMgd2l0aCBtaXNzaW5nIGNvb3JkaW5hdGVzXG4gIGFzeW5jIGZ1bmN0aW9uIGJhdGNoR2VvY29kZVByb3BlcnRpZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNldEdlb2NvZGluZyh0cnVlKTtcbiAgICAgIGNsZWFyR2VvY29kaW5nTG9ncygpO1xuICAgICAgc2V0U2hvd0dlb2NvZGluZ0xvZ3ModHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBwcm9wZXJ0aWVzIHRoYXQgbmVlZCBnZW9jb2RpbmdcbiAgICAgIGNvbnN0IHByb3BzVG9HZW9jb2RlID0gcHJvcGVydGllcy5maWx0ZXIocCA9PiBcbiAgICAgICAgIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlIHx8IFxuICAgICAgICBwLmxhdGl0dWRlID09PSAwIHx8IHAubG9uZ2l0dWRlID09PSAwIHx8XG4gICAgICAgIHAuX2Nvb3JkaW5hdGVzX21pc3NpbmcgfHwgcC5fbmVlZHNfZ2VvY29kaW5nIHx8XG4gICAgICAgIHAuX2lzX2dyaWRfcGF0dGVyblxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKHByb3BzVG9HZW9jb2RlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhZGRHZW9jb2RpbmdMb2coJ05vIHByb3BlcnRpZXMgbmVlZCBnZW9jb2RpbmcnLCAnaW5mbycpO1xuICAgICAgICBhbGVydCgnTm8gcHJvcGVydGllcyBuZWVkIGdlb2NvZGluZycpO1xuICAgICAgICBzZXRHZW9jb2RpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbmZpcm0gd2l0aCB1c2VyXG4gICAgICBhZGRHZW9jb2RpbmdMb2coYEZvdW5kICR7cHJvcHNUb0dlb2NvZGUubGVuZ3RofSBwcm9wZXJ0aWVzIHRoYXQgbmVlZCBnZW9jb2RpbmdgLCAnaW5mbycpO1xuICAgICAgaWYgKCFjb25maXJtKGBUaGlzIHdpbGwgYXR0ZW1wdCB0byBnZW9jb2RlICR7cHJvcHNUb0dlb2NvZGUubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggbWlzc2luZyBvciBpbnZhbGlkIGNvb3JkaW5hdGVzLiBDb250aW51ZT9gKSkge1xuICAgICAgICBhZGRHZW9jb2RpbmdMb2coJ0dlb2NvZGluZyBjYW5jZWxsZWQgYnkgdXNlcicsICd3YXJuaW5nJyk7XG4gICAgICAgIHNldEdlb2NvZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYWRkR2VvY29kaW5nTG9nKGBTdGFydGluZyBiYXRjaCBnZW9jb2Rpbmcgb2YgJHtwcm9wc1RvR2VvY29kZS5sZW5ndGh9IHByb3BlcnRpZXNgLCAnaW5mbycpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGluIGJhdGNoZXMgb2YgMjUgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDI1O1xuICAgICAgY29uc3QgYmF0Y2hlcyA9IE1hdGguY2VpbChwcm9wc1RvR2VvY29kZS5sZW5ndGggLyBiYXRjaFNpemUpO1xuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBsZXQgZmFpbENvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpICogYmF0Y2hTaXplO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGJhdGNoU2l6ZSwgcHJvcHNUb0dlb2NvZGUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBwcm9wc1RvR2VvY29kZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgXG4gICAgICAgIGFkZEdlb2NvZGluZ0xvZyhgUHJvY2Vzc2luZyBiYXRjaCAke2krMX0vJHtiYXRjaGVzfSAoJHtiYXRjaC5sZW5ndGh9IHByb3BlcnRpZXMpYCwgJ2luZm8nKTtcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgYmF0Y2ggJHtpKzF9LyR7YmF0Y2hlc30gKCR7YmF0Y2gubGVuZ3RofSBwcm9wZXJ0aWVzKWApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCBwcm9wZXJ0eSBpbiB0aGUgYmF0Y2gsIGxvZyB0aGUgcHJvcGVydHkgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICAgICAgYmF0Y2guZm9yRWFjaCgocHJvcGVydHksIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZSB8fCBgUHJvcGVydHkgIyR7cHJvcGVydHkuaWR9YDtcbiAgICAgICAgICAgIGFkZEdlb2NvZGluZ0xvZyhgWyR7aSsxfS4ke2lkeCsxfV0gUXVldWluZyAke3Byb3BlcnR5TmFtZX1gLCAnZGV0YWlsJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZ2VvY29kZWRCYXRjaCA9IGF3YWl0IGVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMoYmF0Y2gsIChwcm9wZXJ0eSwgc3RhdHVzLCBkZXRhaWxzKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBwcm9wZXJ0eSBhcyBpdCdzIHByb2Nlc3NlZFxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZSB8fCBgUHJvcGVydHkgIyR7cHJvcGVydHkuaWR9YDtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYEdlb2NvZGVkOiAke3Byb3BlcnR5TmFtZX0gKCR7ZGV0YWlsc30pYCwgJ3N1Y2Nlc3MnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgIGFkZEdlb2NvZGluZ0xvZyhgRmFpbGVkOiAke3Byb3BlcnR5TmFtZX0gKCR7ZGV0YWlsc30pYCwgJ2Vycm9yJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYCR7c3RhdHVzfTogJHtwcm9wZXJ0eU5hbWV9ICR7ZGV0YWlscyA/IGAoJHtkZXRhaWxzfSlgIDogJyd9YCwgJ2luZm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb3VudCBzdWNjZXNzZXMgYW5kIGZhaWx1cmVzXG4gICAgICAgICAgY29uc3QgYmF0Y2hTdWNjZXNzID0gZ2VvY29kZWRCYXRjaC5maWx0ZXIocCA9PiBwLl9nZW9jb2RlZCkubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGJhdGNoRmFpbCA9IGdlb2NvZGVkQmF0Y2guZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX2ZhaWxlZCkubGVuZ3RoO1xuICAgICAgICAgIFxuICAgICAgICAgIHN1Y2Nlc3NDb3VudCArPSBiYXRjaFN1Y2Nlc3M7XG4gICAgICAgICAgZmFpbENvdW50ICs9IGJhdGNoRmFpbDtcbiAgICAgICAgICBcbiAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYEJhdGNoICR7aSsxfSBjb21wbGV0ZTogJHtiYXRjaFN1Y2Nlc3N9IHN1Y2Nlc3NlcywgJHtiYXRjaEZhaWx9IGZhaWx1cmVzYCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU3VjY2VzcyA+IGJhdGNoRmFpbCA/ICdzdWNjZXNzJyA6ICd3YXJuaW5nJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWVyZ2UgZ2VvY29kZWQgcHJvcGVydGllcyBiYWNrIGludG8gdGhlIG1haW4gYXJyYXlcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvcGVydGllcyA9IFsuLi5wcm9wZXJ0aWVzXTtcbiAgICAgICAgICBnZW9jb2RlZEJhdGNoLmZvckVhY2goZ2VvY29kZWRQcm9wID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdXBkYXRlZFByb3BlcnRpZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gZ2VvY29kZWRQcm9wLmlkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdXBkYXRlZFByb3BlcnRpZXNbaW5kZXhdID0gZ2VvY29kZWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcGVydGllcyBzdGF0ZVxuICAgICAgICAgIHNldFByb3BlcnRpZXModXBkYXRlZFByb3BlcnRpZXMpO1xuICAgICAgICAgIGNhbGN1bGF0ZVN0YXRzKHVwZGF0ZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGEgYml0IGJldHdlZW4gYmF0Y2hlcyB0byBhdm9pZCByYXRlIGxpbWl0c1xuICAgICAgICAgIGlmIChpIDwgYmF0Y2hlcyAtIDEpIHtcbiAgICAgICAgICAgIGFkZEdlb2NvZGluZ0xvZyhgV2FpdGluZyAyIHNlY29uZHMgYmVmb3JlIG5leHQgYmF0Y2ggdG8gYXZvaWQgcmF0ZSBsaW1pdHNgLCAnaW5mbycpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2VvY29kaW5nIGJhdGNoICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgYWRkR2VvY29kaW5nTG9nKGBFcnJvciB3aXRoIGJhdGNoICR7aSsxfTogJHtlcnJvci5tZXNzYWdlfWAsICdlcnJvcicpO1xuICAgICAgICAgIGZhaWxDb3VudCArPSBiYXRjaC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgYWRkR2VvY29kaW5nTG9nKGBHZW9jb2RpbmcgY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fSBzdWNjZXNzZXMsICR7ZmFpbENvdW50fSBmYWlsdXJlc2AsIFxuICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCA+IGZhaWxDb3VudCA/ICdzdWNjZXNzJyA6ICdlcnJvcicpO1xuICAgICAgXG4gICAgICBhbGVydChgR2VvY29kaW5nIGNvbXBsZXRlOlxcblxcbiR7c3VjY2Vzc0NvdW50fSBwcm9wZXJ0aWVzIHN1Y2Nlc3NmdWxseSBnZW9jb2RlZFxcbiR7ZmFpbENvdW50fSBwcm9wZXJ0aWVzIGZhaWxlZCB0byBnZW9jb2RlYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYmF0Y2ggZ2VvY29kaW5nOicsIGVycm9yKTtcbiAgICAgIGFkZEdlb2NvZGluZ0xvZyhgR2VvY29kaW5nIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgJ2Vycm9yJyk7XG4gICAgICBhbGVydChgRXJyb3IgZ2VvY29kaW5nIHByb3BlcnRpZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0R2VvY29kaW5nKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5Qcm9wZXJ0eUFuYWx5c2lzKCkge1xuICAgIC8vIENvdW50IHByb3BlcnRpZXMgYXQgaWRlbnRpY2FsIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgY29vcmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGR1cGxpY2F0ZWRDb29yZHMgPSAwO1xuICAgIFxuICAgIHByb3BlcnRpZXMuZm9yRWFjaChwID0+IHtcbiAgICAgIGlmIChwLmxhdGl0dWRlICYmIHAubG9uZ2l0dWRlKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkS2V5ID0gYCR7cC5sYXRpdHVkZX0sJHtwLmxvbmdpdHVkZX1gO1xuICAgICAgICBpZiAoY29vcmRNYXAuaGFzKGNvb3JkS2V5KSkge1xuICAgICAgICAgIGNvb3JkTWFwLnNldChjb29yZEtleSwgY29vcmRNYXAuZ2V0KGNvb3JkS2V5KSArIDEpO1xuICAgICAgICAgIGR1cGxpY2F0ZWRDb29yZHMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29yZE1hcC5zZXQoY29vcmRLZXksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRmluZCBjb29yZGluYXRlcyB3aXRoIG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICBjb25zdCBtdWx0aXBsZVByb3BzTG9jYXRpb25zID0gQXJyYXkuZnJvbShjb29yZE1hcC5lbnRyaWVzKCkpXG4gICAgICAuZmlsdGVyKChbXywgY291bnRdKSA9PiBjb3VudCA+IDEpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pOyAvLyBTb3J0IGJ5IGNvdW50IGRlc2NlbmRpbmdcbiAgICBcbiAgICBjb25zdCBtdWx0aXBsZVByb3BzQ291bnQgPSBtdWx0aXBsZVByb3BzTG9jYXRpb25zLnJlZHVjZSgoc3VtLCBbXywgY291bnRdKSA9PiBzdW0gKyBjb3VudCwgMCk7XG4gICAgY29uc3QgdW5pcXVlTG9jYXRpb25zID0gY29vcmRNYXAuc2l6ZTtcbiAgICBcbiAgICAvLyBDb3VudCBieSBnZW9jb2Rpbmcgc291cmNlIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IGJ5U291cmNlID0ge1xuICAgICAgZXhpc3Rpbmc6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ2V4aXN0aW5nJykubGVuZ3RoLFxuICAgICAgdmVyaWZpZWRfYWRkcmVzczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLl9nZW9jb2Rpbmdfc291cmNlID09PSAndmVyaWZpZWRfYWRkcmVzcycpLmxlbmd0aCxcbiAgICAgIGZ1bGxfYWRkcmVzczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLl9nZW9jb2Rpbmdfc291cmNlID09PSAnZnVsbF9hZGRyZXNzJykubGVuZ3RoLFxuICAgICAgcHJvcGVydHlfbmFtZTogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLl9nZW9jb2Rpbmdfc291cmNlID09PSAncHJvcGVydHlfbmFtZScpLmxlbmd0aCxcbiAgICAgIHVua25vd246IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSAmJiAhcC5fZ2VvY29kaW5nX3NvdXJjZSkubGVuZ3RoXG4gICAgfTtcbiAgICBcbiAgICBhbGVydChcbiAgICAgIGBNYXAgUHJvcGVydGllcyBBbmFseXNpczpcXG5cXG5gICtcbiAgICAgIGAtIFRvdGFsIHByb3BlcnRpZXM6ICR7cHJvcGVydGllcy5sZW5ndGh9XFxuYCArXG4gICAgICBgLSBQcm9wZXJ0aWVzIHdpdGggaW52YWxpZCBjb29yZGluYXRlczogJHtkYXRhU3RhdHMuaW52YWxpZENvb3JkaW5hdGVzfVxcbmAgK1xuICAgICAgYCAgIOKAoiBNaXNzaW5nIGNvb3JkaW5hdGVzOiAke2RhdGFTdGF0cy5taXNzaW5nQ29vcmRpbmF0ZXN9XFxuYCArXG4gICAgICBgICAg4oCiIFplcm8gY29vcmRpbmF0ZXM6ICR7ZGF0YVN0YXRzLnplcm9Db29yZGluYXRlc31cXG5gICtcbiAgICAgIGAgICDigKIgSW52YWxpZCBjb29yZGluYXRlIHJhbmdlOiAke2RhdGFTdGF0cy5pbnZhbGlkUmFuZ2V9XFxuXFxuYCArXG4gICAgICBgLSBVbmlxdWUgbG9jYXRpb25zIG9uIG1hcDogJHt1bmlxdWVMb2NhdGlvbnN9XFxuYCArXG4gICAgICBgLSBQcm9wZXJ0aWVzIHNoYXJpbmcgZXhhY3QgY29vcmRpbmF0ZXM6ICR7ZHVwbGljYXRlZENvb3Jkc31cXG5gICtcbiAgICAgIGAtIE51bWJlciBvZiBzaGFyZWQgbG9jYXRpb25zOiAke211bHRpcGxlUHJvcHNMb2NhdGlvbnMubGVuZ3RofVxcblxcbmAgK1xuICAgICAgKG11bHRpcGxlUHJvcHNMb2NhdGlvbnMubGVuZ3RoID4gMCA/IFxuICAgICAgICBgVG9wIHNoYXJlZCBsb2NhdGlvbnM6XFxuYCArXG4gICAgICAgIG11bHRpcGxlUHJvcHNMb2NhdGlvbnMuc2xpY2UoMCwgNSkubWFwKChbY29vcmRzLCBjb3VudF0pID0+IFxuICAgICAgICAgIGAgICDigKIgJHtjb3VudH0gcHJvcGVydGllcyBhdCAke2Nvb3Jkc31gXG4gICAgICAgICkuam9pbignXFxuJykgOiAnJykgK1xuICAgICAgYFxcblxcbmAgK1xuICAgICAgYEdlb2NvZGluZyBzb3VyY2VzOlxcbmAgK1xuICAgICAgYCAgIOKAoiBFeGlzdGluZyB2YWxpZDogJHtieVNvdXJjZS5leGlzdGluZ31cXG5gICtcbiAgICAgIGAgICDigKIgVmVyaWZpZWQgYWRkcmVzczogJHtieVNvdXJjZS52ZXJpZmllZF9hZGRyZXNzfVxcbmAgK1xuICAgICAgYCAgIOKAoiBGdWxsIGFkZHJlc3M6ICR7YnlTb3VyY2UuZnVsbF9hZGRyZXNzfVxcbmAgK1xuICAgICAgYCAgIOKAoiBQcm9wZXJ0eSBuYW1lOiAke2J5U291cmNlLnByb3BlcnR5X25hbWV9XFxuYCArXG4gICAgICBgICAg4oCiIFVua25vd24gc291cmNlOiAke2J5U291cmNlLnVua25vd259XFxuXFxuYCArXG4gICAgICBgTm90ZTogUHJvcGVydGllcyBhdCBpZGVudGljYWwgY29vcmRpbmF0ZXMgd2lsbCBhcHBlYXIgYXMgYSBzaW5nbGUgbWFya2VyIHVudGlsIGNsaWNrZWQuYFxuICAgICk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiB0byBjbGVhbiBwcm9wZXJ0eSBkYXRhXG4gIGFzeW5jIGZ1bmN0aW9uIGNsZWFuUHJvcGVydHlEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGFydCB0aGUgY2xlYW5pbmcgcHJvY2Vzc1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldENsZWFuaW5nKHRydWUpO1xuICAgICAgY2xlYXJDbGVhbmluZ0xvZ3MoKTtcbiAgICAgIHNldFNob3dDbGVhbmluZ0xvZ3ModHJ1ZSk7XG4gICAgICBcbiAgICAgIGFkZENsZWFuaW5nTG9nKFwiU3RhcnRpbmcgZGF0YSBjbGVhbmluZyBwcm9jZXNzLi4uXCIsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgLy8gRmlyc3QsIGFuYWx5emUgdGhlIGRhdGEgdG8gaWRlbnRpZnkgaXNzdWVzXG4gICAgICBhZGRDbGVhbmluZ0xvZyhcIkFuYWx5emluZyBwcm9wZXJ0aWVzIGZvciBkYXRhIHF1YWxpdHkgaXNzdWVzLi4uXCIsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgY29uc3QgZGF0YUlzc3VlcyA9IHtcbiAgICAgICAgbWlzc2luZ05hbWVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+ICFwLm5hbWUgfHwgcC5uYW1lLnRyaW0oKSA9PT0gJycpLmxlbmd0aCxcbiAgICAgICAgaW5jb21wbGV0ZUFkZHJlc3NlczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLmFkZHJlc3MgJiYgKCFwLmNpdHkgfHwgIXAuc3RhdGUpKS5sZW5ndGgsXG4gICAgICAgIHN1c3BpY2lvdXNaZXJvczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBcbiAgICAgICAgICAocC51bml0cyA9PT0gMCB8fCBwLm51bV91bml0cyA9PT0gMClcbiAgICAgICAgKS5sZW5ndGgsXG4gICAgICAgIHN1c3BpY2lvdXNDb29yZGluYXRlczogcHJvcGVydGllcy5maWx0ZXIocCA9PiB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnMgaW4gY29vcmRpbmF0ZXNcbiAgICAgICAgICBpZiAoIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbGF0U3RyID0gU3RyaW5nKHAubGF0aXR1ZGUpO1xuICAgICAgICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwLmxvbmdpdHVkZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHZlcnkgbG93IHByZWNpc2lvbiBvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChsYXRTdHIuaW5jbHVkZXMoJy4nKSAmJiBsYXRTdHIuc3BsaXQoJy4nKVsxXS5sZW5ndGggPD0gMikgfHxcbiAgICAgICAgICAgIChsbmdTdHIuaW5jbHVkZXMoJy4nKSAmJiBsbmdTdHIuc3BsaXQoJy4nKVsxXS5sZW5ndGggPD0gMikgfHxcbiAgICAgICAgICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IC8vIFNhbWUgbGF0L2xuZyBpcyBzdXNwaWNpb3VzXG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjAnKSB8fFxuICAgICAgICAgICAgbG5nU3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJy41JykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy41JylcbiAgICAgICAgICApO1xuICAgICAgICB9KS5sZW5ndGgsXG4gICAgICAgIGR1cGxpY2F0ZU5hbWVzOiBmaW5kRHVwbGljYXRlcyhwcm9wZXJ0aWVzLCAnbmFtZScpLFxuICAgICAgICBkdXBsaWNhdGVBZGRyZXNzZXM6IGZpbmREdXBsaWNhdGVzKHByb3BlcnRpZXMsICdhZGRyZXNzJyksXG4gICAgICAgIHRlc3RQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgICAgICAgIChwLm5hbWUgJiYgcC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3Rlc3QnKSkgfHwgXG4gICAgICAgICAgKHAubmFtZSAmJiBwLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZXhhbXBsZScpKSB8fFxuICAgICAgICAgIChwLmFkZHJlc3MgJiYgcC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3Rlc3QnKSkgfHwgXG4gICAgICAgICAgcC5faXNfdGVzdF9wcm9wZXJ0eVxuICAgICAgICApLmxlbmd0aFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxJc3N1ZXMgPSBkYXRhSXNzdWVzLm1pc3NpbmdOYW1lcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLmluY29tcGxldGVBZGRyZXNzZXMgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy5zdXNwaWNpb3VzWmVyb3MgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXMgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGggKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy5kdXBsaWNhdGVBZGRyZXNzZXMubGVuZ3RoICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJc3N1ZXMudGVzdFByb3BlcnRpZXM7XG4gICAgICBcbiAgICAgIC8vIExvZyBhbmFseXNpcyByZXN1bHRzXG4gICAgICBhZGRDbGVhbmluZ0xvZyhgQW5hbHlzaXMgZm91bmQgJHt0b3RhbElzc3Vlc30gZGF0YSBxdWFsaXR5IGlzc3VlczpgLCBcImluZm9cIik7XG4gICAgICBhZGRDbGVhbmluZ0xvZyhgLSAke2RhdGFJc3N1ZXMubWlzc2luZ05hbWVzfSBwcm9wZXJ0aWVzIG1pc3NpbmcgbmFtZXNgLCBcImRldGFpbFwiKTtcbiAgICAgIGFkZENsZWFuaW5nTG9nKGAtICR7ZGF0YUlzc3Vlcy5pbmNvbXBsZXRlQWRkcmVzc2VzfSBwcm9wZXJ0aWVzIHdpdGggaW5jb21wbGV0ZSBhZGRyZXNzZXNgLCBcImRldGFpbFwiKTtcbiAgICAgIGFkZENsZWFuaW5nTG9nKGAtICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzWmVyb3N9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzYCwgXCJkZXRhaWxcIik7XG4gICAgICBhZGRDbGVhbmluZ0xvZyhgLSAke2RhdGFJc3N1ZXMuc3VzcGljaW91c0Nvb3JkaW5hdGVzfSBwcm9wZXJ0aWVzIHdpdGggc3VzcGljaW91cyBjb29yZGluYXRlc2AsIFwiZGV0YWlsXCIpO1xuICAgICAgYWRkQ2xlYW5pbmdMb2coYC0gJHtkYXRhSXNzdWVzLmR1cGxpY2F0ZU5hbWVzLmxlbmd0aH0gZHVwbGljYXRlIHByb3BlcnR5IG5hbWVzYCwgXCJkZXRhaWxcIik7XG4gICAgICBhZGRDbGVhbmluZ0xvZyhgLSAke2RhdGFJc3N1ZXMuZHVwbGljYXRlQWRkcmVzc2VzLmxlbmd0aH0gZHVwbGljYXRlIGFkZHJlc3Nlc2AsIFwiZGV0YWlsXCIpO1xuICAgICAgYWRkQ2xlYW5pbmdMb2coYC0gJHtkYXRhSXNzdWVzLnRlc3RQcm9wZXJ0aWVzfSBwb3RlbnRpYWwgdGVzdC9leGFtcGxlIHByb3BlcnRpZXNgLCBcImRldGFpbFwiKTtcbiAgICAgIFxuICAgICAgLy8gTm8gaXNzdWVzIGZvdW5kXG4gICAgICBpZiAodG90YWxJc3N1ZXMgPT09IDApIHtcbiAgICAgICAgYWRkQ2xlYW5pbmdMb2coJ05vIGRhdGEgaXNzdWVzIGZvdW5kIHRoYXQgbmVlZCBjbGVhbmluZycsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgYWxlcnQoJ05vIGRhdGEgaXNzdWVzIGZvdW5kIHRoYXQgbmVlZCBjbGVhbmluZycpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgc2V0Q2xlYW5pbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbmZpcm0gd2l0aCB1c2VyXG4gICAgICBjb25zdCBjb25maXJtYXRpb24gPSBjb25maXJtKFxuICAgICAgICBgRm91bmQgJHt0b3RhbElzc3Vlc30gZGF0YSBxdWFsaXR5IGlzc3VlczpcXG5cXG5gICtcbiAgICAgICAgYC0gJHtkYXRhSXNzdWVzLm1pc3NpbmdOYW1lc30gcHJvcGVydGllcyBtaXNzaW5nIG5hbWVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5pbmNvbXBsZXRlQWRkcmVzc2VzfSBwcm9wZXJ0aWVzIHdpdGggaW5jb21wbGV0ZSBhZGRyZXNzZXNcXG5gICtcbiAgICAgICAgYC0gJHtkYXRhSXNzdWVzLnN1c3BpY2lvdXNaZXJvc30gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXNcXG5gICtcbiAgICAgICAgYC0gJHtkYXRhSXNzdWVzLnN1c3BpY2lvdXNDb29yZGluYXRlc30gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXNcXG5gICtcbiAgICAgICAgYC0gJHtkYXRhSXNzdWVzLmR1cGxpY2F0ZU5hbWVzLmxlbmd0aH0gZHVwbGljYXRlIHByb3BlcnR5IG5hbWVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVBZGRyZXNzZXMubGVuZ3RofSBkdXBsaWNhdGUgYWRkcmVzc2VzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllc30gcG90ZW50aWFsIHRlc3QvZXhhbXBsZSBwcm9wZXJ0aWVzXFxuXFxuYCArXG4gICAgICAgIGBXb3VsZCB5b3UgbGlrZSB0byBjbGVhbiB0aGVzZSBpc3N1ZXM/YFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKCFjb25maXJtYXRpb24pIHtcbiAgICAgICAgYWRkQ2xlYW5pbmdMb2coJ0NsZWFuaW5nIGNhbmNlbGxlZCBieSB1c2VyJywgXCJ3YXJuaW5nXCIpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgc2V0Q2xlYW5pbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9wdGlvbmFsOiBvZmZlciBhZHZhbmNlZCBvcHRpb25zXG4gICAgICBjb25zdCBhZHZhbmNlZE9wdGlvbnMgPSBjb25maXJtKFxuICAgICAgICBcIldvdWxkIHlvdSBsaWtlIHRvIHVzZSBhZHZhbmNlZCBjbGVhbmluZyBvcHRpb25zP1xcblxcblwiICtcbiAgICAgICAgXCItIEZpeCBtaXNzaW5nIG5hbWVzIGFuZCBleHRyYWN0IGNpdHkvc3RhdGUgZnJvbSBhZGRyZXNzZXNcXG5cIiArXG4gICAgICAgIFwiLSBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcblwiICtcbiAgICAgICAgXCItIElkZW50aWZ5IGFuZCBmbGFnIGR1cGxpY2F0ZSBwcm9wZXJ0aWVzXFxuXCIgK1xuICAgICAgICBcIi0gRmxhZyB0ZXN0IHByb3BlcnRpZXMgZm9yIGZpbHRlcmluZ1xcblxcblwiICtcbiAgICAgICAgXCJTZWxlY3QgJ0NhbmNlbCcgZm9yIGJhc2ljIGNsZWFuaW5nIG9ubHkuXCJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGFkZENsZWFuaW5nTG9nKGBTdGFydGluZyAke2FkdmFuY2VkT3B0aW9ucyA/ICdhZHZhbmNlZCcgOiAnYmFzaWMnfSBjbGVhbmluZyBwcm9jZXNzLi4uYCwgXCJpbmZvXCIpO1xuICAgICAgXG4gICAgICAvLyBBcHBseSBmaXhlcyB0byBhIGNvcHkgb2YgdGhlIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IGNsZWFuZWRQcm9wZXJ0aWVzID0gWy4uLnByb3BlcnRpZXNdO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgbGV0IGlzc3Vlc0NsZWFuZWQgPSAwO1xuICAgICAgXG4gICAgICBhZGRDbGVhbmluZ0xvZyhgUHJvY2Vzc2luZyAke3Byb3BlcnRpZXMubGVuZ3RofSBwcm9wZXJ0aWVzLi4uYCwgXCJpbmZvXCIpO1xuICAgICAgXG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5LCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHlDbGVhbmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjbGVhbmluZ05vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaXggbWlzc2luZyBuYW1lcyB1c2luZyBhZGRyZXNzXG4gICAgICAgIGlmICghcHJvcGVydHkubmFtZSB8fCBwcm9wZXJ0eS5uYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkuYWRkcmVzcykge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWUgPSBgUHJvcGVydHkgYXQgJHtwcm9wZXJ0eS5hZGRyZXNzLnNwbGl0KCcsJylbMF19YDtcbiAgICAgICAgICAgIGFkZENsZWFuaW5nTG9nKGBHZW5lcmF0ZWQgbmFtZSBmb3IgcHJvcGVydHkgIyR7cHJvcGVydHkuaWR9OiBcIiR7Y2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWV9XCJgLCBcInN1Y2Nlc3NcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFuZWRQcm9wZXJ0aWVzW2luZGV4XS5uYW1lID0gYFVubmFtZWQgUHJvcGVydHkgJHtwcm9wZXJ0eS5pZC50b1N0cmluZygpLnN1YnN0cmluZygwLCA4KX1gO1xuICAgICAgICAgICAgYWRkQ2xlYW5pbmdMb2coYEdlbmVyYXRlZCBmYWxsYmFjayBuYW1lIGZvciBwcm9wZXJ0eSAjJHtwcm9wZXJ0eS5pZH06IFwiJHtjbGVhbmVkUHJvcGVydGllc1tpbmRleF0ubmFtZX1cImAsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGVhbmluZ05vdGVzLnB1c2goJ01pc3NpbmcgbmFtZSBmaXhlZCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGaXggbWlzc2luZyBjaXR5L3N0YXRlIGlmIGFkZHJlc3MgZXhpc3RzXG4gICAgICAgIGlmIChwcm9wZXJ0eS5hZGRyZXNzICYmICghcHJvcGVydHkuY2l0eSB8fCAhcHJvcGVydHkuc3RhdGUpKSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgY2l0eSBhbmQgc3RhdGUgZnJvbSBhZGRyZXNzXG4gICAgICAgICAgY29uc3QgYWRkcmVzc1BhcnRzID0gcHJvcGVydHkuYWRkcmVzcy5zcGxpdCgnLCcpLm1hcChwID0+IHAudHJpbSgpKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYWRkcmVzc1BhcnRzLmxlbmd0aCA+PSAyICYmICFwcm9wZXJ0eS5jaXR5KSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uY2l0eSA9IGFkZHJlc3NQYXJ0c1thZGRyZXNzUGFydHMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBhZGRDbGVhbmluZ0xvZyhgRXh0cmFjdGVkIGNpdHkgXCIke2NsZWFuZWRQcm9wZXJ0aWVzW2luZGV4XS5jaXR5fVwiIGZvciBwcm9wZXJ0eSAjJHtwcm9wZXJ0eS5pZH1gLCBcInN1Y2Nlc3NcIik7XG4gICAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdDaXR5IGV4dHJhY3RlZCBmcm9tIGFkZHJlc3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGFkZHJlc3NQYXJ0cy5sZW5ndGggPj0gMSAmJiAhcHJvcGVydHkuc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHN0YXRlIGZyb20gdGhlIGxhc3QgcGFydCBvZiB0aGUgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVQYXJ0ID0gYWRkcmVzc1BhcnRzW2FkZHJlc3NQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTWF0Y2ggPSBzdGF0ZVBhcnQubWF0Y2goL1tBLVpdezJ9Lyk7XG4gICAgICAgICAgICBpZiAoc3RhdGVNYXRjaCkge1xuICAgICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uc3RhdGUgPSBzdGF0ZU1hdGNoWzBdO1xuICAgICAgICAgICAgICBhZGRDbGVhbmluZ0xvZyhgRXh0cmFjdGVkIHN0YXRlIFwiJHtjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uc3RhdGV9XCIgZm9yIHByb3BlcnR5ICMke3Byb3BlcnR5LmlkfWAsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdTdGF0ZSBleHRyYWN0ZWQgZnJvbSBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGFkdmFuY2VkIGNsZWFuaW5nXG4gICAgICAgIGlmIChhZHZhbmNlZE9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocHJvcGVydHkubGF0aXR1ZGUgfHwgJycpO1xuICAgICAgICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwcm9wZXJ0eS5sb25naXR1ZGUgfHwgJycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zIGluIGNvb3JkaW5hdGVzXG4gICAgICAgICAgY29uc3QgaGFzTG93UHJlY2lzaW9uID0gXG4gICAgICAgICAgICAobGF0U3RyLmluY2x1ZGVzKCcuJykgJiYgbGF0U3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpIHx8XG4gICAgICAgICAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaGFzU3VzcGljaW91c1BhdHRlcm4gPSBcbiAgICAgICAgICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IC8vIFNhbWUgbGF0L2xuZyBpcyB2ZXJ5IHVubGlrZWx5XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjAnKSB8fFxuICAgICAgICAgICAgbG5nU3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJy41JykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy41Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzTG93UHJlY2lzaW9uIHx8IGhhc1N1c3BpY2lvdXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2lzX2dyaWRfcGF0dGVybiA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX25lZWRzX2dlb2NvZGluZyA9IHRydWU7XG4gICAgICAgICAgICBhZGRDbGVhbmluZ0xvZyhgRmxhZ2dlZCBzdXNwaWNpb3VzIGNvb3JkaW5hdGVzICgke2xhdFN0cn0sICR7bG5nU3RyfSkgZm9yIHByb3BlcnR5ICMke3Byb3BlcnR5LmlkfWAsIFwid2FybmluZ1wiKTtcbiAgICAgICAgICAgIHByb3BlcnR5Q2xlYW5lZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbmluZ05vdGVzLnB1c2goJ0ZsYWdnZWQgc3VzcGljaW91cyBjb29yZGluYXRlcyBmb3IgZ2VvY29kaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHRlc3QgcHJvcGVydGllc1xuICAgICAgICBpZiAoKHByb3BlcnR5Lm5hbWUgJiYgcHJvcGVydHkubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0ZXN0JykpIHx8IFxuICAgICAgICAgICAgKHByb3BlcnR5Lm5hbWUgJiYgcHJvcGVydHkubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdleGFtcGxlJykpIHx8XG4gICAgICAgICAgICAocHJvcGVydHkuYWRkcmVzcyAmJiBwcm9wZXJ0eS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3Rlc3QnKSkpIHtcbiAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2lzX3Rlc3RfcHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgIGFkZENsZWFuaW5nTG9nKGBGbGFnZ2VkIHRlc3QgcHJvcGVydHkgIyR7cHJvcGVydHkuaWR9OiBcIiR7cHJvcGVydHkubmFtZX1cImAsIFwid2FybmluZ1wiKTtcbiAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnRmxhZ2dlZCBhcyB0ZXN0IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZsYWcgc3VzcGljaW91cyB6ZXJvcyBmb3IgYWR2YW5jZWQgY2xlYW5pbmdcbiAgICAgICAgaWYgKGFkdmFuY2VkT3B0aW9ucyAmJiAocHJvcGVydHkudW5pdHMgPT09IDAgfHwgcHJvcGVydHkubnVtX3VuaXRzID09PSAwKSkge1xuICAgICAgICAgIC8vIFdlJ2xsIGp1c3QgZmxhZyB0aGVzZSBmb3Igbm93LCBtYW51YWwgcmV2aWV3IGlzIG5lZWRlZFxuICAgICAgICAgIGlmICghY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfcXVhbGl0eV9pc3N1ZXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzLnB1c2goJ3plcm9fdW5pdHMnKTtcbiAgICAgICAgICBhZGRDbGVhbmluZ0xvZyhgRmxhZ2dlZCB6ZXJvIHVuaXRzIGZvciBwcm9wZXJ0eSAjJHtwcm9wZXJ0eS5pZH1gLCBcIndhcm5pbmdcIik7XG4gICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGVhbmluZ05vdGVzLnB1c2goJ0ZsYWdnZWQgemVybyB1bml0cycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvcGVydHkgd2l0aCBjbGVhbmluZyBpbmZvcm1hdGlvblxuICAgICAgICBpZiAocHJvcGVydHlDbGVhbmVkKSB7XG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX2NsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFuZWRQcm9wZXJ0aWVzW2luZGV4XS5fY2xlYW5pbmdfbm90ZXMgPSBjbGVhbmluZ05vdGVzLmpvaW4oJywgJyk7XG4gICAgICAgICAgaXNzdWVzQ2xlYW5lZCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYWRkQ2xlYW5pbmdMb2coYEZpbmlzaGVkIHByb2Nlc3NpbmcuIENsZWFuZWQgJHtpc3N1ZXNDbGVhbmVkfSBwcm9wZXJ0aWVzLmAsIFwic3VjY2Vzc1wiKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggY2xlYW5lZCBwcm9wZXJ0aWVzXG4gICAgICBhZGRDbGVhbmluZ0xvZyhcIlVwZGF0aW5nIHByb3BlcnR5IGRhdGEgd2l0aCBjbGVhbmVkIHZhbHVlcy4uLlwiLCBcImluZm9cIik7XG4gICAgICBzZXRQcm9wZXJ0aWVzKGNsZWFuZWRQcm9wZXJ0aWVzKTtcbiAgICAgIGNhbGN1bGF0ZVN0YXRzKGNsZWFuZWRQcm9wZXJ0aWVzKTtcbiAgICAgIFxuICAgICAgLy8gQWxlcnQgdXNlciBvZiByZXN1bHRzXG4gICAgICBhZGRDbGVhbmluZ0xvZyhcIkRhdGEgY2xlYW5pbmcgY29tcGxldGUhXCIsIFwic3VjY2Vzc1wiKTtcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRGF0YSBjbGVhbmluZyBjb21wbGV0ZSFcXG5cXG5gICtcbiAgICAgICAgYC0gJHtpc3N1ZXNDbGVhbmVkfSBwcm9wZXJ0aWVzIHdlcmUgY2xlYW5lZFxcbmAgK1xuICAgICAgICBgLSBBZGRlZCBuYW1lcyB0byAke2RhdGFJc3N1ZXMubWlzc2luZ05hbWVzfSBwcm9wZXJ0aWVzXFxuYCArXG4gICAgICAgIGAtIEV4dHJhY3RlZCBjaXR5L3N0YXRlIGZvciAke2RhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3Nlc30gcHJvcGVydGllc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXN9IHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcbmAgK1xuICAgICAgICBgLSBJZGVudGlmaWVkICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGh9IGR1cGxpY2F0ZSBuYW1lc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllc30gdGVzdCBwcm9wZXJ0aWVzXFxuXFxuYCArXG4gICAgICAgIGBOZXh0IHN0ZXBzOlxcbmAgK1xuICAgICAgICBgMS4gVXNlIFwiQmF0Y2ggR2VvY29kZVwiIHRvIGZpeCBmbGFnZ2VkIGNvb3JkaW5hdGVzXFxuYCArXG4gICAgICAgIGAyLiBVc2UgXCJQcm9wZXJ0aWVzIEFuYWx5c2lzXCIgdG8gcmV2aWV3IGRhdGEgcXVhbGl0eVxcbmAgK1xuICAgICAgICBgMy4gU29tZSBwcm9wZXJ0aWVzIHN0aWxsIHJlcXVpcmUgbWFudWFsIHJldmlld2BcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFuaW5nIHByb3BlcnR5IGRhdGE6JywgZXJyb3IpO1xuICAgICAgYWRkQ2xlYW5pbmdMb2coYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIGFsZXJ0KGBFcnJvciBjbGVhbmluZyBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgc2V0Q2xlYW5pbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZHVwbGljYXRlcyBpbiBwcm9wZXJ0aWVzIGJ5IGZpZWxkXG4gIGZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGFycmF5LCBrZXkpIHtcbiAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gW107XG4gICAgXG4gICAgLy8gU2tpcCBlbnRyaWVzIHdpdGggZW1wdHkgdmFsdWVzXG4gICAgYXJyYXkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmIChpdGVtW2tleV0gJiYgaXRlbVtrZXldLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGNvdW50c1t2YWx1ZV0gPSAoY291bnRzW3ZhbHVlXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRmluZCB2YWx1ZXMgdGhhdCBhcHBlYXIgbW9yZSB0aGFuIG9uY2VcbiAgICBPYmplY3Qua2V5cyhjb3VudHMpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgaWYgKGNvdW50c1t2YWx1ZV0gPiAxKSB7XG4gICAgICAgIGR1cGxpY2F0ZXMucHVzaCh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY291bnQ6IGNvdW50c1t2YWx1ZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGR1cGxpY2F0ZXM7XG4gIH1cblxuICAvLyBGdW5jdGlvbiB0byBlbnJpY2ggcHJvcGVydHkgZGF0YSB3aXRoIHplcm8gdmFsdWVzXG4gIGFzeW5jIGZ1bmN0aW9uIGVucmljaFByb3BlcnR5RGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVucmljaGluZyh0cnVlKTtcbiAgICAgIGNsZWFyRW5yaWNoaW5nTG9ncygpO1xuICAgICAgc2V0U2hvd0VucmljaGluZ0xvZ3ModHJ1ZSk7XG4gICAgICBcbiAgICAgIGFkZEVucmljaGluZ0xvZyhcIlN0YXJ0aW5nIGRhdGEgZW5yaWNobWVudCBwcm9jZXNzLi4uXCIsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgLy8gSWRlbnRpZnkgcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXNcbiAgICAgIGFkZEVucmljaGluZ0xvZyhcIkFuYWx5emluZyBwcm9wZXJ0aWVzIGZvciBzdXNwaWNpb3VzIHplcm8gdmFsdWVzLi4uXCIsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3VzcGljaW91c1Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgICAgICAocC51bml0cyA9PT0gMCB8fCBwLm51bV91bml0cyA9PT0gMClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChzdXNwaWNpb3VzUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWRkRW5yaWNoaW5nTG9nKCdObyBwcm9wZXJ0aWVzIHdpdGggc3VzcGljaW91cyB6ZXJvIHZhbHVlcyBmb3VuZCcsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgYWxlcnQoJ05vIHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzIGZvdW5kJyk7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICBzZXRFbnJpY2hpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGFkZEVucmljaGluZ0xvZyhgRm91bmQgJHtzdXNwaWNpb3VzUHJvcGVydGllcy5sZW5ndGh9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzOmAsIFwiaW5mb1wiKTtcbiAgICAgIGFkZEVucmljaGluZ0xvZyhgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAudW5pdHMgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gdW5pdHNgLCBcImRldGFpbFwiKTtcbiAgICAgIGFkZEVucmljaGluZ0xvZyhgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAubnVtX3VuaXRzID09PSAwKS5sZW5ndGh9IHByb3BlcnRpZXMgd2l0aCB6ZXJvIHVuaXRzYCwgXCJkZXRhaWxcIik7XG4gICAgICBcbiAgICAgIC8vIENvbmZpcm0gd2l0aCB1c2VyXG4gICAgICBjb25zdCBjb25maXJtYXRpb24gPSBjb25maXJtKFxuICAgICAgICBgRm91bmQgJHtzdXNwaWNpb3VzUHJvcGVydGllcy5sZW5ndGh9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzOlxcblxcbmAgK1xuICAgICAgICBgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAudW5pdHMgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gdW5pdHNcXG5gICtcbiAgICAgICAgYC0gJHtzdXNwaWNpb3VzUHJvcGVydGllcy5maWx0ZXIocCA9PiBwLm51bV91bml0cyA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyB1bml0c1xcblxcbmAgK1xuICAgICAgICBgV291bGQgeW91IGxpa2UgdG8gYXR0ZW1wdCB0byBlbnJpY2ggdGhlc2UgcHJvcGVydGllcz9gXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIWNvbmZpcm1hdGlvbikge1xuICAgICAgICBhZGRFbnJpY2hpbmdMb2coJ0VucmljaG1lbnQgY2FuY2VsbGVkIGJ5IHVzZXInLCBcIndhcm5pbmdcIik7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICBzZXRFbnJpY2hpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBwcm9wZXJ0aWVzIGZvciBlbnJpY2htZW50XG4gICAgICBjb25zdCBlbnJpY2hlZFByb3BlcnRpZXMgPSBbLi4ucHJvcGVydGllc107XG4gICAgICBsZXQgZW5yaWNoZWRDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIC8vIEFuYWx5emUgY29sbGVjdGlvbnMgb2Ygc2ltaWxhciBwcm9wZXJ0aWVzIHRvIGRlcml2ZSBlc3RpbWF0ZXNcbiAgICAgIGFkZEVucmljaGluZ0xvZyhcIkFuYWx5emluZyBwcm9wZXJ0eSBkYXRhIGZvciBzdGF0aXN0aWNhbCBlbnJpY2htZW50Li4uXCIsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgLy8gR3JvdXAgcHJvcGVydGllcyBieSBjaXR5L3N0YXRlIGZvciBiZXR0ZXIgY29tcGFyaXNvblxuICAgICAgY29uc3QgY2l0eVN0YXRlR3JvdXBzID0ge307XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmIChwLmNpdHkgJiYgcC5zdGF0ZSAmJiBwLnByaWNlICYmIHAucHJpY2UgPiAwICYmIChwLnVuaXRzID4gMCB8fCBwLm51bV91bml0cyA+IDApKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cC5jaXR5LnRvTG93ZXJDYXNlKCl9LCR7cC5zdGF0ZS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgICAgaWYgKCFjaXR5U3RhdGVHcm91cHNba2V5XSkge1xuICAgICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0ucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4gdmFsdWVzIHBlciBjaXR5L3N0YXRlXG4gICAgICBjb25zdCBtZWRpYW5WYWx1ZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNpdHlTdGF0ZUdyb3VwcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGNpdHlTdGF0ZUdyb3Vwc1trZXldO1xuICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID49IDMpIHsgLy8gT25seSB1c2UgZ3JvdXBzIHdpdGggZW5vdWdoIGRhdGEgcG9pbnRzXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG1lZGlhbiBwcmljZSBwZXIgdW5pdFxuICAgICAgICAgIGNvbnN0IHByaWNlc1BlclVuaXQgPSBncm91cC5tYXAocCA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bml0cyA9IHAudW5pdHMgfHwgcC5udW1fdW5pdHMgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA+IDAgPyBwLnByaWNlIC8gdW5pdHMgOiAwO1xuICAgICAgICAgIH0pLmZpbHRlcih2ID0+IHYgPiAwKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbWVkaWFuUHJpY2VQZXJVbml0ID0gcHJpY2VzUGVyVW5pdFtNYXRoLmZsb29yKHByaWNlc1BlclVuaXQubGVuZ3RoIC8gMildO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4geWVhciBidWlsdFxuICAgICAgICAgIGNvbnN0IHllYXJCdWlsdCA9IGdyb3VwLm1hcChwID0+IHAueWVhcl9idWlsdCkuZmlsdGVyKHkgPT4geSAmJiB5ID4gMTkwMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgIGNvbnN0IG1lZGlhblllYXJCdWlsdCA9IHllYXJCdWlsdC5sZW5ndGggPiAwID8geWVhckJ1aWx0W01hdGguZmxvb3IoeWVhckJ1aWx0Lmxlbmd0aCAvIDIpXSA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgbWVkaWFuVmFsdWVzW2tleV0gPSB7XG4gICAgICAgICAgICBtZWRpYW5QcmljZVBlclVuaXQsXG4gICAgICAgICAgICBtZWRpYW5ZZWFyQnVpbHQsXG4gICAgICAgICAgICBzYW1wbGVTaXplOiBncm91cC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGFkZEVucmljaGluZ0xvZyhgR3JvdXAgJHtrZXl9OiAke2dyb3VwLmxlbmd0aH0gcHJvcGVydGllcywgJCR7TWF0aC5yb3VuZChtZWRpYW5QcmljZVBlclVuaXQpLnRvTG9jYWxlU3RyaW5nKCl9L3VuaXRgLCBcImRldGFpbFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGFkZEVucmljaGluZ0xvZyhgQ3JlYXRlZCAke09iamVjdC5rZXlzKG1lZGlhblZhbHVlcykubGVuZ3RofSBzdGF0aXN0aWNhbCBncm91cHMgZm9yIGNvbXBhcmlzb25gLCBcImluZm9cIik7XG4gICAgICBhZGRFbnJpY2hpbmdMb2coYFN0YXJ0aW5nIHRvIHByb2Nlc3MgJHtzdXNwaWNpb3VzUHJvcGVydGllcy5sZW5ndGh9IHByb3BlcnRpZXMgd2l0aCB6ZXJvIHZhbHVlcy4uLmAsIFwiaW5mb1wiKTtcbiAgICAgIFxuICAgICAgLy8gRW5yaWNoIHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzXG4gICAgICBzdXNwaWNpb3VzUHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBlbnJpY2hlZFByb3BlcnRpZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcHJvcGVydHkuaWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBsZXQgaXNFbnJpY2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZW5yaWNobWVudE5vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IHJlZmVyZW5jZSBncm91cCBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICBsZXQgcmVmZXJlbmNlR3JvdXAgPSBudWxsO1xuICAgICAgICBsZXQgcmVmZXJlbmNlS2V5ID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9wZXJ0eS5jaXR5ICYmIHByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cHJvcGVydHkuY2l0eS50b0xvd2VyQ2FzZSgpfSwke3Byb3BlcnR5LnN0YXRlLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgICBpZiAobWVkaWFuVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwID0gbWVkaWFuVmFsdWVzW2tleV07XG4gICAgICAgICAgICByZWZlcmVuY2VLZXkgPSBrZXk7XG4gICAgICAgICAgICBhZGRFbnJpY2hpbmdMb2coYFByb3BlcnR5ICMke3Byb3BlcnR5LmlkfTogRm91bmQgZXhhY3QgY2l0eS9zdGF0ZSBtYXRjaCAoJHtrZXl9KWAsIFwiZGV0YWlsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgbm8gZGlyZWN0IGNpdHkvc3RhdGUgbWF0Y2gsIHVzZSB0aGUgY2xvc2VzdCBnZW9ncmFwaGljYWxseSBvciBhIGdlbmVyYWwgYXZlcmFnZVxuICAgICAgICBpZiAoIXJlZmVyZW5jZUdyb3VwKSB7XG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHN0YXRlLWxldmVsIGRhdGEgb3IgZ2VuZXJhbCBhdmVyYWdlXG4gICAgICAgICAgaWYgKHByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUdyb3VwcyA9IE9iamVjdC5rZXlzKG1lZGlhblZhbHVlcykuZmlsdGVyKGtleSA9PiBcbiAgICAgICAgICAgICAga2V5LmVuZHNXaXRoKGAsJHtwcm9wZXJ0eS5zdGF0ZS50b0xvd2VyQ2FzZSgpfWApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc3RhdGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGxhcmdlc3Qgc2FtcGxlIGZyb20gdGhlIHN0YXRlXG4gICAgICAgICAgICAgIHJlZmVyZW5jZUtleSA9IHN0YXRlR3JvdXBzLnNvcnQoKGEsIGIpID0+IFxuICAgICAgICAgICAgICAgIG1lZGlhblZhbHVlc1tiXS5zYW1wbGVTaXplIC0gbWVkaWFuVmFsdWVzW2FdLnNhbXBsZVNpemVcbiAgICAgICAgICAgICAgKVswXTtcbiAgICAgICAgICAgICAgcmVmZXJlbmNlR3JvdXAgPSBtZWRpYW5WYWx1ZXNbcmVmZXJlbmNlS2V5XTtcbiAgICAgICAgICAgICAgYWRkRW5yaWNoaW5nTG9nKGBQcm9wZXJ0eSAjJHtwcm9wZXJ0eS5pZH06IEZvdW5kIHN0YXRlLWxldmVsIG1hdGNoICgke3JlZmVyZW5jZUtleX0pYCwgXCJkZXRhaWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHN0aWxsIG5vIG1hdGNoLCB1c2UgdGhlIG92ZXJhbGwgYXZlcmFnZVxuICAgICAgICAgIGlmICghcmVmZXJlbmNlR3JvdXApIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFByaWNlc1BlclVuaXQgPSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwLnByaWNlICYmIHAucHJpY2UgPiAwICYmIChwLnVuaXRzID4gMCB8fCBwLm51bV91bml0cyA+IDApKVxuICAgICAgICAgICAgICAubWFwKHAgPT4gcC5wcmljZSAvIChwLnVuaXRzIHx8IHAubnVtX3VuaXRzKSlcbiAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYWxsUHJpY2VzUGVyVW5pdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwID0ge1xuICAgICAgICAgICAgICAgIG1lZGlhblByaWNlUGVyVW5pdDogYWxsUHJpY2VzUGVyVW5pdFtNYXRoLmZsb29yKGFsbFByaWNlc1BlclVuaXQubGVuZ3RoIC8gMildLFxuICAgICAgICAgICAgICAgIG1lZGlhblllYXJCdWlsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplOiBhbGxQcmljZXNQZXJVbml0Lmxlbmd0aFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZWZlcmVuY2VLZXkgPSBcImFsbF9wcm9wZXJ0aWVzXCI7XG4gICAgICAgICAgICAgIGFkZEVucmljaGluZ0xvZyhgUHJvcGVydHkgIyR7cHJvcGVydHkuaWR9OiBVc2luZyBnbG9iYWwgYXZlcmFnZSAoJHthbGxQcmljZXNQZXJVbml0Lmxlbmd0aH0gcHJvcGVydGllcylgLCBcImRldGFpbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtaXNzaW5nIHZhbHVlc1xuICAgICAgICBpZiAocmVmZXJlbmNlR3JvdXApIHtcbiAgICAgICAgICAvLyBGaXggemVybyB1bml0cyBpZiBwcmljZSBpcyBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoKHByb3BlcnR5LnVuaXRzID09PSAwIHx8ICFwcm9wZXJ0eS51bml0cykgJiYgXG4gICAgICAgICAgICAgIChwcm9wZXJ0eS5udW1fdW5pdHMgPT09IDAgfHwgIXByb3BlcnR5Lm51bV91bml0cykgJiYgXG4gICAgICAgICAgICAgIHByb3BlcnR5LnByaWNlID4gMCAmJiBcbiAgICAgICAgICAgICAgcmVmZXJlbmNlR3JvdXAubWVkaWFuUHJpY2VQZXJVbml0ID4gMCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkVW5pdHMgPSBNYXRoLnJvdW5kKHByb3BlcnR5LnByaWNlIC8gcmVmZXJlbmNlR3JvdXAubWVkaWFuUHJpY2VQZXJVbml0KTtcbiAgICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0udW5pdHMgPSBlc3RpbWF0ZWRVbml0cztcbiAgICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0ubnVtX3VuaXRzID0gZXN0aW1hdGVkVW5pdHM7XG4gICAgICAgICAgICBhZGRFbnJpY2hpbmdMb2coYFByb3BlcnR5ICMke3Byb3BlcnR5LmlkfTogRXN0aW1hdGVkICR7ZXN0aW1hdGVkVW5pdHN9IHVuaXRzIGJhc2VkIG9uICQke3Byb3BlcnR5LnByaWNlLnRvTG9jYWxlU3RyaW5nKCl9IHByaWNlYCwgXCJzdWNjZXNzXCIpO1xuICAgICAgICAgICAgaXNFbnJpY2hlZCA9IHRydWU7XG4gICAgICAgICAgICBlbnJpY2htZW50Tm90ZXMucHVzaChgRXN0aW1hdGVkICR7ZXN0aW1hdGVkVW5pdHN9IHVuaXRzIGJhc2VkIG9uIHByaWNlIGFuZCAke3JlZmVyZW5jZUtleX0gbWVkaWFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIHllYXIgYnVpbHQgaWYgd2UgaGF2ZSBhIHJlZmVyZW5jZVxuICAgICAgICAgIGlmICgoIXByb3BlcnR5LnllYXJfYnVpbHQgfHwgcHJvcGVydHkueWVhcl9idWlsdCA8IDE5MDApICYmIHJlZmVyZW5jZUdyb3VwLm1lZGlhblllYXJCdWlsdCkge1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS55ZWFyX2J1aWx0ID0gcmVmZXJlbmNlR3JvdXAubWVkaWFuWWVhckJ1aWx0O1xuICAgICAgICAgICAgYWRkRW5yaWNoaW5nTG9nKGBQcm9wZXJ0eSAjJHtwcm9wZXJ0eS5pZH06IEVzdGltYXRlZCB5ZWFyIGJ1aWx0IGFzICR7cmVmZXJlbmNlR3JvdXAubWVkaWFuWWVhckJ1aWx0fWAsIFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgIGlzRW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5yaWNobWVudE5vdGVzLnB1c2goYEVzdGltYXRlZCB5ZWFyIGJ1aWx0IGFzICR7cmVmZXJlbmNlR3JvdXAubWVkaWFuWWVhckJ1aWx0fSBiYXNlZCBvbiAke3JlZmVyZW5jZUtleX0gbWVkaWFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHByb3BlcnR5IGFzIG5lZWRpbmcgaHVtYW4gcmV2aWV3IGlmIHdlIGNvdWxkbid0IGVucmljaCBpdFxuICAgICAgICBpZiAoIWlzRW5yaWNoZWQpIHtcbiAgICAgICAgICAvLyBNYXJrIGFzIG5lZWRpbmcgbWFudWFsIHJldmlld1xuICAgICAgICAgIGlmICghZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3Vlcykge1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3VlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnJpY2hlZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzLnB1c2goJ25lZWRzX21hbnVhbF9yZXZpZXcnKTtcbiAgICAgICAgICBhZGRFbnJpY2hpbmdMb2coYFByb3BlcnR5ICMke3Byb3BlcnR5LmlkfTogSW5zdWZmaWNpZW50IGRhdGEgZm9yIGVucmljaG1lbnQsIG1hcmtlZCBmb3IgbWFudWFsIHJldmlld2AsIFwid2FybmluZ1wiKTtcbiAgICAgICAgICBpc0VucmljaGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbnJpY2htZW50Tm90ZXMucHVzaCgnTWFya2VkIGZvciBtYW51YWwgcmV2aWV3IC0gaW5zdWZmaWNpZW50IGRhdGEgdG8gbWFrZSBlc3RpbWF0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb3BlcnR5IHdpdGggZW5yaWNobWVudCBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoaXNFbnJpY2hlZCkge1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfZW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2VucmljaG1lbnRfbm90ZXMgPSBlbnJpY2htZW50Tm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICBlbnJpY2hlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhZGRFbnJpY2hpbmdMb2coYEVucmljaG1lbnQgcHJvY2Vzc2luZyBjb21wbGV0ZS4gRW5yaWNoZWQgJHtlbnJpY2hlZENvdW50fSBwcm9wZXJ0aWVzLmAsIFwic3VjY2Vzc1wiKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggZW5yaWNoZWQgcHJvcGVydGllc1xuICAgICAgYWRkRW5yaWNoaW5nTG9nKFwiVXBkYXRpbmcgcHJvcGVydHkgZGF0YSB3aXRoIGVucmljaGVkIHZhbHVlcy4uLlwiLCBcImluZm9cIik7XG4gICAgICBzZXRQcm9wZXJ0aWVzKGVucmljaGVkUHJvcGVydGllcyk7XG4gICAgICBjYWxjdWxhdGVTdGF0cyhlbnJpY2hlZFByb3BlcnRpZXMpO1xuICAgICAgXG4gICAgICAvLyBBbGVydCB1c2VyIG9mIHJlc3VsdHNcbiAgICAgIGFkZEVucmljaGluZ0xvZyhcIkRhdGEgZW5yaWNobWVudCBjb21wbGV0ZSFcIiwgXCJzdWNjZXNzXCIpO1xuICAgICAgYWxlcnQoXG4gICAgICAgIGBEYXRhIGVucmljaG1lbnQgY29tcGxldGUhXFxuXFxuYCArXG4gICAgICAgIGAtICR7ZW5yaWNoZWRDb3VudH0gcHJvcGVydGllcyB3ZXJlIGVucmljaGVkIG9yIG1hcmtlZCBmb3IgcmV2aWV3XFxuYCArXG4gICAgICAgIGAtICR7c3VzcGljaW91c1Byb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC51bml0cyA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyB1bml0cyBwcm9jZXNzZWRcXG5gICtcbiAgICAgICAgYC0gJHtzdXNwaWNpb3VzUHJvcGVydGllcy5maWx0ZXIocCA9PiBwLm51bV91bml0cyA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyB1bml0cyBwcm9jZXNzZWRcXG5cXG5gICtcbiAgICAgICAgYE5leHQgc3RlcHM6XFxuYCArXG4gICAgICAgIGAxLiBSZXZpZXcgdGhlIGVucmljaGVkIGRhdGEgZm9yIGFjY3VyYWN5XFxuYCArXG4gICAgICAgIGAyLiBQcm9wZXJ0aWVzIG1hcmtlZCBmb3IgbWFudWFsIHJldmlldyBuZWVkIGh1bWFuIGF0dGVudGlvblxcbmAgK1xuICAgICAgICBgMy4gVXNlIFwiUHJvcGVydGllcyBBbmFseXNpc1wiIHRvIHZlcmlmeSBkYXRhIHF1YWxpdHlgXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJpY2hpbmcgcHJvcGVydHkgZGF0YTonLCBlcnJvcik7XG4gICAgICBhZGRFbnJpY2hpbmdMb2coYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIGFsZXJ0KGBFcnJvciBlbnJpY2hpbmcgZGF0YTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHNldEVucmljaGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbG9nIGVudHJ5IHdpdGggdGltZXN0YW1wXG4gIGNvbnN0IGFkZEdlb2NvZGluZ0xvZyA9IHVzZUNhbGxiYWNrKChtZXNzYWdlLCB0eXBlID0gJ2luZm8nKSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKHByZXZMb2dzID0+IFtcbiAgICAgIHsgbWVzc2FnZSwgdGltZXN0YW1wLCB0eXBlIH0sXG4gICAgICAuLi5wcmV2TG9ncy5zbGljZSgwLCA5OSkgLy8gS2VlcCBvbmx5IHRoZSBsYXN0IDEwMCBsb2dzXG4gICAgXSk7XG4gIH0sIFtdKTtcblxuICAvLyBDbGVhciBsb2dzIHdoZW4gc3RhcnRpbmcgbmV3IGdlb2NvZGluZyBwcm9jZXNzXG4gIGNvbnN0IGNsZWFyR2VvY29kaW5nTG9ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKFtdKTtcbiAgfSwgW10pO1xuICBcbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgY2xlYW5pbmcgbG9nIGVudHJ5IHdpdGggdGltZXN0YW1wXG4gIGNvbnN0IGFkZENsZWFuaW5nTG9nID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2UsIHR5cGUgPSAnaW5mbycpID0+IHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIHNldENsZWFuaW5nTG9ncyhwcmV2TG9ncyA9PiBbXG4gICAgICB7IG1lc3NhZ2UsIHRpbWVzdGFtcCwgdHlwZSB9LFxuICAgICAgLi4ucHJldkxvZ3Muc2xpY2UoMCwgOTkpIC8vIEtlZXAgb25seSB0aGUgbGFzdCAxMDAgbG9nc1xuICAgIF0pO1xuICB9LCBbXSk7XG5cbiAgLy8gQ2xlYXIgbG9ncyB3aGVuIHN0YXJ0aW5nIG5ldyBjbGVhbmluZyBwcm9jZXNzXG4gIGNvbnN0IGNsZWFyQ2xlYW5pbmdMb2dzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldENsZWFuaW5nTG9ncyhbXSk7XG4gIH0sIFtdKTtcbiAgXG4gIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBlbnJpY2htZW50IGxvZyBlbnRyeSB3aXRoIHRpbWVzdGFtcFxuICBjb25zdCBhZGRFbnJpY2hpbmdMb2cgPSB1c2VDYWxsYmFjaygobWVzc2FnZSwgdHlwZSA9ICdpbmZvJykgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgc2V0RW5yaWNoaW5nTG9ncyhwcmV2TG9ncyA9PiBbXG4gICAgICB7IG1lc3NhZ2UsIHRpbWVzdGFtcCwgdHlwZSB9LFxuICAgICAgLi4ucHJldkxvZ3Muc2xpY2UoMCwgOTkpIC8vIEtlZXAgb25seSB0aGUgbGFzdCAxMDAgbG9nc1xuICAgIF0pO1xuICB9LCBbXSk7XG5cbiAgLy8gQ2xlYXIgbG9ncyB3aGVuIHN0YXJ0aW5nIG5ldyBlbnJpY2htZW50IHByb2Nlc3NcbiAgY29uc3QgY2xlYXJFbnJpY2hpbmdMb2dzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEVucmljaGluZ0xvZ3MoW10pO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8TGF5b3V0IHRpdGxlPVwiUHJvcGVydHkgTWFwIHwgQWNxdWlyZSBBcGFydG1lbnRzXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIGJnLXdoaXRlIG1pbi1oLXNjcmVlblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaC1bY2FsYygxMDB2aC00cmVtKV0gb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00IHB5LTQgZmxleC1zaHJpbmstMFwiPlxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LWdyYXktODAwXCI+TWFwIFZpZXc8L2gxPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPkJyb3dzZSBwcm9wZXJ0aWVzIG9uIHRoZSBtYXAgb3IgdXNlIGZpbHRlcnMgdG8gcmVmaW5lIHlvdXIgc2VhcmNoPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC1ncm93IGZsZXhcIj5cbiAgICAgICAgICAgIHsvKiBQcm9wZXJ0eSBTaWRlYmFyICovfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BmbGV4LXNocmluay0wIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCAke1xuICAgICAgICAgICAgICBzaWRlYmFyU3RhdGUgPT09ICdjb2xsYXBzZWQnID8gJ3ctMTInIDogXG4gICAgICAgICAgICAgIHNpZGViYXJTdGF0ZSA9PT0gJ2Z1bGxzY3JlZW4nID8gJ3ctZnVsbCcgOiBcbiAgICAgICAgICAgICAgJ3ctZnVsbCBtZDp3LTEvMyBsZzp3LTEvNCdcbiAgICAgICAgICAgIH1gfT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTRcIj5cbiAgICAgICAgICAgICAgICB7UmVhY3QuY3JlYXRlRWxlbWVudChkeW5hbWljKCgpID0+IGltcG9ydCgnLi4vc3JjL2NvbXBvbmVudHMvUHJvcGVydHlTaWRlYmFyJykpLCB7XG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgc2lkZWJhclN0YXRlLFxuICAgICAgICAgICAgICAgICAgb25TaWRlYmFyU3RhdGVDaGFuZ2U6IGhhbmRsZVNpZGViYXJTdGF0ZUNoYW5nZVxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICB7LyogTWFwIENvbnRhaW5lciAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgZmxleC1ncm93IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCAke1xuICAgICAgICAgICAgICBzaWRlYmFyU3RhdGUgPT09ICdmdWxsc2NyZWVuJyA/ICdoaWRkZW4nIDogJ2Jsb2NrJ1xuICAgICAgICAgICAgfWB9PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtZnVsbCByb3VuZGVkLWxnIHNoYWRvdyBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8TWFwQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzPXtwcm9wZXJ0aWVzfVxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQcm9wZXJ0eT17c2VsZWN0ZWRQcm9wZXJ0eX1cbiAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUHJvcGVydHk9e3NldFNlbGVjdGVkUHJvcGVydHl9XG4gICAgICAgICAgICAgICAgICBvbkJvdW5kc0NoYW5nZT17aGFuZGxlQm91bmRzQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogR2VvY29kaW5nIExvZ3MgKi99XG4gICAgICAgICAge3Nob3dHZW9jb2RpbmdMb2dzICYmIGdlb2NvZGluZ0xvZ3MubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGJvdHRvbS00IHJpZ2h0LTQgdy05NiBtYXgtaC02NCBiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1sZyBvdmVyZmxvdy1hdXRvIHAtNCB6LTUwXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTJcIj5cbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkdlb2NvZGluZyBMb2dzPC9oMz5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFNob3dHZW9jb2RpbmdMb2dzKGZhbHNlKX0gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMCBob3Zlcjp0ZXh0LWdyYXktNzAwXCI+XG4gICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cInctNSBoLTVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD17Mn0gZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTFcIj5cbiAgICAgICAgICAgICAgICB7Z2VvY29kaW5nTG9ncy5tYXAoKGxvZywgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPXtgdGV4dC1zbSBwLTEgJHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnR5cGUgPT09ICdlcnJvcicgPyAndGV4dC1yZWQtNjAwJyA6XG4gICAgICAgICAgICAgICAgICAgIGxvZy50eXBlID09PSAnd2FybmluZycgPyAndGV4dC1hbWJlci02MDAnIDpcbiAgICAgICAgICAgICAgICAgICAgbG9nLnR5cGUgPT09ICdzdWNjZXNzJyA/ICd0ZXh0LWdyZWVuLTYwMCcgOlxuICAgICAgICAgICAgICAgICAgICAndGV4dC1ncmF5LTYwMCdcbiAgICAgICAgICAgICAgICAgIH1gfT5cbiAgICAgICAgICAgICAgICAgICAge2xvZy5tZXNzYWdlfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHsvKiBTaW1pbGFyIGJsb2NrcyBmb3Igb3RoZXIgbG9ncyAtIGNsZWFuaW5nIGFuZCBlbnJpY2hpbmcgbG9ncyByZW1haW4gdW5jaGFuZ2VkICovfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvTGF5b3V0PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZHluYW1pYyIsIkxheW91dCIsImZldGNoUHJvcGVydGllcyIsImVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMiLCJNYXBDb21wb25lbnQiLCJzc3IiLCJNYXBQYWdlIiwicHJvcGVydGllcyIsInNldFByb3BlcnRpZXMiLCJzZWxlY3RlZFByb3BlcnR5Iiwic2V0U2VsZWN0ZWRQcm9wZXJ0eSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZ2VvY29kaW5nIiwic2V0R2VvY29kaW5nIiwiZ2VvY29kaW5nTG9ncyIsInNldEdlb2NvZGluZ0xvZ3MiLCJzaG93R2VvY29kaW5nTG9ncyIsInNldFNob3dHZW9jb2RpbmdMb2dzIiwiY2xlYW5pbmciLCJzZXRDbGVhbmluZyIsImNsZWFuaW5nTG9ncyIsInNldENsZWFuaW5nTG9ncyIsInNob3dDbGVhbmluZ0xvZ3MiLCJzZXRTaG93Q2xlYW5pbmdMb2dzIiwiZW5yaWNoaW5nIiwic2V0RW5yaWNoaW5nIiwiZW5yaWNoaW5nTG9ncyIsInNldEVucmljaGluZ0xvZ3MiLCJzaG93RW5yaWNoaW5nTG9ncyIsInNldFNob3dFbnJpY2hpbmdMb2dzIiwibWFwQm91bmRzIiwic2V0TWFwQm91bmRzIiwidG90YWxGZXRjaGVkIiwic2V0VG90YWxGZXRjaGVkIiwic2lkZWJhclN0YXRlIiwic2V0U2lkZWJhclN0YXRlIiwiZGF0YVN0YXRzIiwic2V0RGF0YVN0YXRzIiwidG90YWxQcm9wZXJ0aWVzIiwiaW52YWxpZENvb3JkaW5hdGVzIiwibWlzc2luZ0Nvb3JkaW5hdGVzIiwiemVyb0Nvb3JkaW5hdGVzIiwiaW52YWxpZFJhbmdlIiwiZHVwbGljYXRlZExvY2F0aW9ucyIsImxhc3RCb3VuZHMiLCJzZXRMYXN0Qm91bmRzIiwibG9hZFByb3BlcnRpZXMiLCJjb25zb2xlIiwibG9nIiwiaGFuZGxlQm91bmRzQ2hhbmdlIiwiYm91bmRzIiwiY2FsY3VsYXRlU3RhdHMiLCJwcm9wRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIm1pc3NpbmdDb29yZHMiLCJmaWx0ZXIiLCJwIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJsZW5ndGgiLCJ6ZXJvQ29vcmRzIiwibGF0IiwicGFyc2VGbG9hdCIsIlN0cmluZyIsImxuZyIsImlzTmFOIiwiY29vcmRNYXAiLCJNYXAiLCJkdXBsaWNhdGVkQ29vcmRzIiwiZm9yRWFjaCIsImNvb3JkS2V5IiwiaGFzIiwic2V0IiwiZ2V0IiwidW5pcXVlTG9jYXRpb25zIiwic2l6ZSIsIm9wdGlvbnMiLCJzb3J0QnkiLCJzb3J0QXNjIiwicGFnZSIsInBhZ2VTaXplIiwiZmlsdGVycyIsImluY2x1ZGVJbmNvbXBsZXRlIiwiaW5jbHVkZVJlc2VhcmNoIiwibm9MaW1pdCIsImJvdW5kc0NoYW5nZWQiLCJoYXNTaWduaWZpY2FudEJvdW5kc0NoYW5nZSIsImRhdGEiLCJ2YWxpZFByb3BlcnRpZXMiLCJlcnJvciIsIm5ld0JvdW5kcyIsIm9sZEJvdW5kcyIsIm9sZEFyZWEiLCJub3J0aCIsInNvdXRoIiwiZWFzdCIsIndlc3QiLCJuZXdBcmVhIiwib2xkQ2VudGVyTGF0Iiwib2xkQ2VudGVyTG5nIiwibmV3Q2VudGVyTGF0IiwibmV3Q2VudGVyTG5nIiwiY2VudGVyU2hpZnQiLCJNYXRoIiwic3FydCIsInBvdyIsImFyZWFSYXRpbyIsIm1heCIsImhhbmRsZVNpZGViYXJTdGF0ZUNoYW5nZSIsInN0YXRlIiwiYmF0Y2hHZW9jb2RlUHJvcGVydGllcyIsImNsZWFyR2VvY29kaW5nTG9ncyIsInByb3BzVG9HZW9jb2RlIiwiX2Nvb3JkaW5hdGVzX21pc3NpbmciLCJfbmVlZHNfZ2VvY29kaW5nIiwiX2lzX2dyaWRfcGF0dGVybiIsImFkZEdlb2NvZGluZ0xvZyIsImFsZXJ0IiwiY29uZmlybSIsImJhdGNoU2l6ZSIsImJhdGNoZXMiLCJjZWlsIiwic3VjY2Vzc0NvdW50IiwiZmFpbENvdW50IiwiaSIsInN0YXJ0IiwiZW5kIiwibWluIiwiYmF0Y2giLCJzbGljZSIsInByb3BlcnR5IiwiaWR4IiwicHJvcGVydHlOYW1lIiwibmFtZSIsImlkIiwiZ2VvY29kZWRCYXRjaCIsInN0YXR1cyIsImRldGFpbHMiLCJiYXRjaFN1Y2Nlc3MiLCJfZ2VvY29kZWQiLCJiYXRjaEZhaWwiLCJfZ2VvY29kaW5nX2ZhaWxlZCIsInVwZGF0ZWRQcm9wZXJ0aWVzIiwiZ2VvY29kZWRQcm9wIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtZXNzYWdlIiwicnVuUHJvcGVydHlBbmFseXNpcyIsIm11bHRpcGxlUHJvcHNMb2NhdGlvbnMiLCJmcm9tIiwiZW50cmllcyIsIl8iLCJjb3VudCIsInNvcnQiLCJhIiwiYiIsIm11bHRpcGxlUHJvcHNDb3VudCIsInJlZHVjZSIsInN1bSIsImJ5U291cmNlIiwiZXhpc3RpbmciLCJfZ2VvY29kaW5nX3NvdXJjZSIsInZlcmlmaWVkX2FkZHJlc3MiLCJmdWxsX2FkZHJlc3MiLCJwcm9wZXJ0eV9uYW1lIiwidW5rbm93biIsIm1hcCIsImNvb3JkcyIsImpvaW4iLCJjbGVhblByb3BlcnR5RGF0YSIsImNsZWFyQ2xlYW5pbmdMb2dzIiwiYWRkQ2xlYW5pbmdMb2ciLCJkYXRhSXNzdWVzIiwibWlzc2luZ05hbWVzIiwidHJpbSIsImluY29tcGxldGVBZGRyZXNzZXMiLCJhZGRyZXNzIiwiY2l0eSIsInN1c3BpY2lvdXNaZXJvcyIsInVuaXRzIiwibnVtX3VuaXRzIiwic3VzcGljaW91c0Nvb3JkaW5hdGVzIiwibGF0U3RyIiwibG5nU3RyIiwiaW5jbHVkZXMiLCJzcGxpdCIsImVuZHNXaXRoIiwiZHVwbGljYXRlTmFtZXMiLCJmaW5kRHVwbGljYXRlcyIsImR1cGxpY2F0ZUFkZHJlc3NlcyIsInRlc3RQcm9wZXJ0aWVzIiwidG9Mb3dlckNhc2UiLCJfaXNfdGVzdF9wcm9wZXJ0eSIsInRvdGFsSXNzdWVzIiwiY29uZmlybWF0aW9uIiwiYWR2YW5jZWRPcHRpb25zIiwiY2xlYW5lZFByb3BlcnRpZXMiLCJpc3N1ZXNDbGVhbmVkIiwicHJvcGVydHlDbGVhbmVkIiwiY2xlYW5pbmdOb3RlcyIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwicHVzaCIsImFkZHJlc3NQYXJ0cyIsInN0YXRlUGFydCIsInN0YXRlTWF0Y2giLCJtYXRjaCIsImhhc0xvd1ByZWNpc2lvbiIsImhhc1N1c3BpY2lvdXNQYXR0ZXJuIiwiX2RhdGFfcXVhbGl0eV9pc3N1ZXMiLCJfZGF0YV9jbGVhbmVkIiwiX2NsZWFuaW5nX25vdGVzIiwiYXJyYXkiLCJrZXkiLCJjb3VudHMiLCJkdXBsaWNhdGVzIiwiaXRlbSIsInZhbHVlIiwiT2JqZWN0Iiwia2V5cyIsImVucmljaFByb3BlcnR5RGF0YSIsImNsZWFyRW5yaWNoaW5nTG9ncyIsImFkZEVucmljaGluZ0xvZyIsInN1c3BpY2lvdXNQcm9wZXJ0aWVzIiwiZW5yaWNoZWRQcm9wZXJ0aWVzIiwiZW5yaWNoZWRDb3VudCIsImNpdHlTdGF0ZUdyb3VwcyIsInByaWNlIiwibWVkaWFuVmFsdWVzIiwiZ3JvdXAiLCJwcmljZXNQZXJVbml0IiwidiIsIm1lZGlhblByaWNlUGVyVW5pdCIsImZsb29yIiwieWVhckJ1aWx0IiwieWVhcl9idWlsdCIsInkiLCJtZWRpYW5ZZWFyQnVpbHQiLCJzYW1wbGVTaXplIiwicm91bmQiLCJ0b0xvY2FsZVN0cmluZyIsImlzRW5yaWNoZWQiLCJlbnJpY2htZW50Tm90ZXMiLCJyZWZlcmVuY2VHcm91cCIsInJlZmVyZW5jZUtleSIsInN0YXRlR3JvdXBzIiwiYWxsUHJpY2VzUGVyVW5pdCIsImVzdGltYXRlZFVuaXRzIiwiX2RhdGFfZW5yaWNoZWQiLCJfZW5yaWNobWVudF9ub3RlcyIsInR5cGUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwicHJldkxvZ3MiLCJ0aXRsZSIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwiY3JlYXRlRWxlbWVudCIsIm9uU2lkZWJhclN0YXRlQ2hhbmdlIiwib25Cb3VuZHNDaGFuZ2UiLCJoMyIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzdmciLCJmaWxsIiwic3Ryb2tlIiwidmlld0JveCIsInhtbG5zIiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/map.js\n"));

/***/ })

});
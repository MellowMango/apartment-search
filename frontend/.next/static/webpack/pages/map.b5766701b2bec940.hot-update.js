"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/map",{

/***/ "./pages/map.js":
/*!**********************!*\
  !*** ./pages/map.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _src_components_Layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/components/Layout */ \"./src/components/Layout.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/supabase */ \"./lib/supabase.js\");\n/* harmony import */ var _lib_geocoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/geocoding */ \"./lib/geocoding.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Import the map component dynamically to avoid SSR issues with Leaflet\nconst MapComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"src_components_MapComponent_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../src/components/MapComponent */ \"./src/components/MapComponent.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"map.js -> \" + \"../src/components/MapComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = MapComponent;\nfunction MapPage() {\n    _s();\n    const [properties, setProperties] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedProperty, setSelectedProperty] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [geocoding, setGeocoding] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [geocodingLogs, setGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showGeocodingLogs, setShowGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [mapBounds, setMapBounds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [totalFetched, setTotalFetched] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [dataStats, setDataStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalProperties: 0,\n        invalidCoordinates: 0,\n        missingCoordinates: 0,\n        zeroCoordinates: 0,\n        invalidRange: 0,\n        duplicatedLocations: 0\n    });\n    // Initial property load on page load\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        loadProperties();\n    }, []);\n    // Reload properties when map bounds change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (mapBounds) {\n            console.log(\"Map bounds changed, loading properties in the visible area\");\n            loadProperties(mapBounds);\n        }\n    }, [\n        mapBounds\n    ]);\n    // Handle map bounds changes\n    const handleBoundsChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((bounds)=>{\n        setMapBounds(bounds);\n    }, []);\n    // Calculate statistics about the property data\n    const calculateStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((propData)=>{\n        if (!propData || !Array.isArray(propData)) return;\n        const missingCoords = propData.filter((p)=>!p.latitude || !p.longitude).length;\n        const zeroCoords = propData.filter((p)=>p.latitude === 0 && p.longitude === 0).length;\n        const invalidRange = propData.filter((p)=>{\n            if (!p.latitude || !p.longitude) return false;\n            const lat = typeof p.latitude === \"number\" ? p.latitude : parseFloat(String(p.latitude));\n            const lng = typeof p.longitude === \"number\" ? p.longitude : parseFloat(String(p.longitude));\n            return isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180;\n        }).length;\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        propData.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        setDataStats({\n            totalProperties: propData.length,\n            invalidCoordinates: missingCoords + zeroCoords + invalidRange,\n            missingCoordinates: missingCoords,\n            zeroCoordinates: zeroCoords,\n            invalidRange: invalidRange,\n            duplicatedLocations: duplicatedCoords,\n            uniqueLocations: coordMap.size\n        });\n    }, []);\n    // Function to load properties with optional bounds filter\n    async function loadProperties() {\n        let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        try {\n            setLoading(true);\n            const options = {\n                sortBy: \"created_at\",\n                sortAsc: false,\n                page: 1,\n                pageSize: 1000,\n                filters: {},\n                includeIncomplete: true,\n                includeResearch: true,\n                noLimit: true // Bypass pagination to get all properties\n            };\n            // Apply bounds filter if provided\n            if (bounds) {\n                options.bounds = bounds;\n            }\n            const data = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_4__.fetchProperties)(options);\n            // Calculate statistics\n            calculateStats(data);\n            // Enhanced logging for debugging\n            console.log(\"===== MAP DEBUG =====\");\n            console.log(\"Loaded \".concat(data.length, \" properties for map\"));\n            // Check coordinate validity\n            const validCoords = data.filter((p)=>p.latitude && p.longitude && typeof p.latitude === \"number\" && typeof p.longitude === \"number\" && !(p.latitude === 0 && p.longitude === 0));\n            console.log(\"Properties with valid coordinates: \".concat(validCoords.length));\n            // Check Austin area coordinates\n            const austinCoords = validCoords.filter((p)=>p.latitude >= 29.5 && p.latitude <= 31.0 && p.longitude >= -98.0 && p.longitude <= -97.0);\n            console.log(\"Properties with coordinates in Austin area: \".concat(austinCoords.length));\n            // Look for suspicious patterns\n            const suspiciousCoords = validCoords.filter((p)=>{\n                const latStr = String(p.latitude);\n                const lngStr = String(p.longitude);\n                const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 1 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 1;\n                const hasSuspiciousPattern = latStr === lngStr || latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\");\n                return hasLowPrecision || hasSuspiciousPattern;\n            });\n            console.log(\"Properties with suspicious coordinates: \".concat(suspiciousCoords.length));\n            console.log(\"===== END DEBUG =====\");\n            setProperties(data);\n            setTotalFetched(data.length);\n        } catch (error) {\n            console.error(\"Error fetching properties:\", error);\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Function to batch geocode properties with missing coordinates\n    async function batchGeocodeProperties() {\n        try {\n            setGeocoding(true);\n            clearGeocodingLogs();\n            setShowGeocodingLogs(true);\n            // Filter properties that need geocoding\n            const propsToGeocode = properties.filter((p)=>!p.latitude || !p.longitude || p.latitude === 0 || p.longitude === 0 || p._coordinates_missing || p._needs_geocoding || p._is_grid_pattern);\n            if (propsToGeocode.length === 0) {\n                addGeocodingLog(\"No properties need geocoding\", \"info\");\n                alert(\"No properties need geocoding\");\n                setGeocoding(false);\n                return;\n            }\n            // Confirm with user\n            addGeocodingLog(\"Found \".concat(propsToGeocode.length, \" properties that need geocoding\"), \"info\");\n            if (!confirm(\"This will attempt to geocode \".concat(propsToGeocode.length, \" properties with missing or invalid coordinates. Continue?\"))) {\n                addGeocodingLog(\"Geocoding cancelled by user\", \"warning\");\n                setGeocoding(false);\n                return;\n            }\n            addGeocodingLog(\"Starting batch geocoding of \".concat(propsToGeocode.length, \" properties\"), \"info\");\n            // Process in batches of 25 to avoid rate limits\n            const batchSize = 25;\n            const batches = Math.ceil(propsToGeocode.length / batchSize);\n            let successCount = 0;\n            let failCount = 0;\n            for(let i = 0; i < batches; i++){\n                const start = i * batchSize;\n                const end = Math.min(start + batchSize, propsToGeocode.length);\n                const batch = propsToGeocode.slice(start, end);\n                addGeocodingLog(\"Processing batch \".concat(i + 1, \"/\").concat(batches, \" (\").concat(batch.length, \" properties)\"), \"info\");\n                console.log(\"Processing batch \".concat(i + 1, \"/\").concat(batches, \" (\").concat(batch.length, \" properties)\"));\n                try {\n                    // For each property in the batch, log the property being processed\n                    batch.forEach((property, idx)=>{\n                        const propertyName = property.name || \"Property #\".concat(property.id);\n                        addGeocodingLog(\"[\".concat(i + 1, \".\").concat(idx + 1, \"] Queuing \").concat(propertyName), \"detail\");\n                    });\n                    const geocodedBatch = await (0,_lib_geocoding__WEBPACK_IMPORTED_MODULE_5__.enhancedGeocodeProperties)(batch, (property, status, details)=>{\n                        // This is a callback that will be called for each property as it's processed\n                        const propertyName = property.name || \"Property #\".concat(property.id);\n                        if (status === \"success\") {\n                            addGeocodingLog(\"Geocoded: \".concat(propertyName, \" (\").concat(details, \")\"), \"success\");\n                        } else if (status === \"error\") {\n                            addGeocodingLog(\"Failed: \".concat(propertyName, \" (\").concat(details, \")\"), \"error\");\n                        } else {\n                            addGeocodingLog(\"\".concat(status, \": \").concat(propertyName, \" \").concat(details ? \"(\".concat(details, \")\") : \"\"), \"info\");\n                        }\n                    });\n                    // Count successes and failures\n                    const batchSuccess = geocodedBatch.filter((p)=>p._geocoded).length;\n                    const batchFail = geocodedBatch.filter((p)=>p._geocoding_failed).length;\n                    successCount += batchSuccess;\n                    failCount += batchFail;\n                    addGeocodingLog(\"Batch \".concat(i + 1, \" complete: \").concat(batchSuccess, \" successes, \").concat(batchFail, \" failures\"), batchSuccess > batchFail ? \"success\" : \"warning\");\n                    // Merge geocoded properties back into the main array\n                    const updatedProperties = [\n                        ...properties\n                    ];\n                    geocodedBatch.forEach((geocodedProp)=>{\n                        const index = updatedProperties.findIndex((p)=>p.id === geocodedProp.id);\n                        if (index !== -1) {\n                            updatedProperties[index] = geocodedProp;\n                        }\n                    });\n                    // Update the properties state\n                    setProperties(updatedProperties);\n                    calculateStats(updatedProperties);\n                    // Wait a bit between batches to avoid rate limits\n                    if (i < batches - 1) {\n                        addGeocodingLog(\"Waiting 2 seconds before next batch to avoid rate limits\", \"info\");\n                        await new Promise((resolve)=>setTimeout(resolve, 2000));\n                    }\n                } catch (error) {\n                    console.error(\"Error geocoding batch \".concat(i + 1, \":\"), error);\n                    addGeocodingLog(\"Error with batch \".concat(i + 1, \": \").concat(error.message), \"error\");\n                    failCount += batch.length;\n                }\n            }\n            addGeocodingLog(\"Geocoding complete: \".concat(successCount, \" successes, \").concat(failCount, \" failures\"), successCount > failCount ? \"success\" : \"error\");\n            alert(\"Geocoding complete:\\n\\n\".concat(successCount, \" properties successfully geocoded\\n\").concat(failCount, \" properties failed to geocode\"));\n        } catch (error) {\n            console.error(\"Error in batch geocoding:\", error);\n            addGeocodingLog(\"Geocoding error: \".concat(error.message), \"error\");\n            alert(\"Error geocoding properties: \".concat(error.message));\n        } finally{\n            setGeocoding(false);\n        }\n    }\n    function runPropertyAnalysis() {\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        properties.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        // Find coordinates with multiple properties\n        const multiplePropsLocations = Array.from(coordMap.entries()).filter((param)=>{\n            let [_, count] = param;\n            return count > 1;\n        }).sort((a, b)=>b[1] - a[1]); // Sort by count descending\n        const multiplePropsCount = multiplePropsLocations.reduce((sum, param)=>{\n            let [_, count] = param;\n            return sum + count;\n        }, 0);\n        const uniqueLocations = coordMap.size;\n        // Count by geocoding source if available\n        const bySource = {\n            existing: properties.filter((p)=>p._geocoding_source === \"existing\").length,\n            verified_address: properties.filter((p)=>p._geocoding_source === \"verified_address\").length,\n            full_address: properties.filter((p)=>p._geocoding_source === \"full_address\").length,\n            property_name: properties.filter((p)=>p._geocoding_source === \"property_name\").length,\n            unknown: properties.filter((p)=>p.latitude && p.longitude && !p._geocoding_source).length\n        };\n        alert(\"Map Properties Analysis:\\n\\n\" + \"- Total properties: \".concat(properties.length, \"\\n\") + \"- Properties with invalid coordinates: \".concat(dataStats.invalidCoordinates, \"\\n\") + \"   • Missing coordinates: \".concat(dataStats.missingCoordinates, \"\\n\") + \"   • Zero coordinates: \".concat(dataStats.zeroCoordinates, \"\\n\") + \"   • Invalid coordinate range: \".concat(dataStats.invalidRange, \"\\n\\n\") + \"- Unique locations on map: \".concat(uniqueLocations, \"\\n\") + \"- Properties sharing exact coordinates: \".concat(duplicatedCoords, \"\\n\") + \"- Number of shared locations: \".concat(multiplePropsLocations.length, \"\\n\\n\") + (multiplePropsLocations.length > 0 ? \"Top shared locations:\\n\" + multiplePropsLocations.slice(0, 5).map((param)=>{\n            let [coords, count] = param;\n            return \"   • \".concat(count, \" properties at \").concat(coords);\n        }).join(\"\\n\") : \"\") + \"\\n\\n\" + \"Geocoding sources:\\n\" + \"   • Existing valid: \".concat(bySource.existing, \"\\n\") + \"   • Verified address: \".concat(bySource.verified_address, \"\\n\") + \"   • Full address: \".concat(bySource.full_address, \"\\n\") + \"   • Property name: \".concat(bySource.property_name, \"\\n\") + \"   • Unknown source: \".concat(bySource.unknown, \"\\n\\n\") + \"Note: Properties at identical coordinates will appear as a single marker until clicked.\");\n    }\n    // Function to clean property data\n    async function cleanPropertyData() {\n        try {\n            // Start the cleaning process\n            setLoading(true);\n            // First, analyze the data to identify issues\n            const dataIssues = {\n                missingNames: properties.filter((p)=>!p.name || p.name.trim() === \"\").length,\n                incompleteAddresses: properties.filter((p)=>p.address && (!p.city || !p.state)).length,\n                suspiciousZeros: properties.filter((p)=>p.price === 0 || p.units === 0 || p.num_units === 0).length,\n                suspiciousCoordinates: properties.filter((p)=>{\n                    // Check for suspicious patterns in coordinates\n                    if (!p.latitude || !p.longitude) return false;\n                    const latStr = String(p.latitude);\n                    const lngStr = String(p.longitude);\n                    // Check for very low precision or suspicious patterns\n                    return latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2 || latStr === lngStr || // Same lat/lng is suspicious\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                }).length,\n                duplicateNames: findDuplicates(properties, \"name\"),\n                duplicateAddresses: findDuplicates(properties, \"address\"),\n                testProperties: properties.filter((p)=>p.name && p.name.toLowerCase().includes(\"test\") || p.name && p.name.toLowerCase().includes(\"example\") || p.address && p.address.toLowerCase().includes(\"test\") || p._is_test_property).length\n            };\n            const totalIssues = dataIssues.missingNames + dataIssues.incompleteAddresses + dataIssues.suspiciousZeros + dataIssues.suspiciousCoordinates + dataIssues.duplicateNames.length + dataIssues.duplicateAddresses.length + dataIssues.testProperties;\n            // No issues found\n            if (totalIssues === 0) {\n                alert(\"No data issues found that need cleaning\");\n                setLoading(false);\n                return;\n            }\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(totalIssues, \" data quality issues:\\n\\n\") + \"- \".concat(dataIssues.missingNames, \" properties missing names\\n\") + \"- \".concat(dataIssues.incompleteAddresses, \" properties with incomplete addresses\\n\") + \"- \".concat(dataIssues.suspiciousZeros, \" properties with suspicious zero values\\n\") + \"- \".concat(dataIssues.suspiciousCoordinates, \" properties with suspicious coordinates\\n\") + \"- \".concat(dataIssues.duplicateNames.length, \" duplicate property names\\n\") + \"- \".concat(dataIssues.duplicateAddresses.length, \" duplicate addresses\\n\") + \"- \".concat(dataIssues.testProperties, \" potential test/example properties\\n\\n\") + \"Would you like to clean these issues?\");\n            if (!confirmation) {\n                setLoading(false);\n                return;\n            }\n            // Optional: offer advanced options\n            const advancedOptions = confirm(\"Would you like to use advanced cleaning options?\\n\\n\" + \"- Fix missing names and extract city/state from addresses\\n\" + \"- Flag suspicious coordinates for geocoding\\n\" + \"- Identify and flag duplicate properties\\n\" + \"- Flag test properties for filtering\\n\\n\" + \"Select 'Cancel' for basic cleaning only.\");\n            // Apply fixes to a copy of the properties\n            const cleanedProperties = [\n                ...properties\n            ];\n            // Clean property names\n            let issuesCleaned = 0;\n            properties.forEach((property, index)=>{\n                let propertyCleaned = false;\n                let cleaningNotes = [];\n                // Fix missing names using address\n                if (!property.name || property.name.trim() === \"\") {\n                    if (property.address) {\n                        cleanedProperties[index].name = \"Property at \".concat(property.address.split(\",\")[0]);\n                    } else {\n                        cleanedProperties[index].name = \"Unnamed Property \".concat(property.id.toString().substring(0, 8));\n                    }\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Missing name fixed\");\n                }\n                // Fix missing city/state if address exists\n                if (property.address && (!property.city || !property.state)) {\n                    // Try to extract city and state from address\n                    const addressParts = property.address.split(\",\").map((p)=>p.trim());\n                    if (addressParts.length >= 2 && !property.city) {\n                        cleanedProperties[index].city = addressParts[addressParts.length - 2];\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"City extracted from address\");\n                    }\n                    if (addressParts.length >= 1 && !property.state) {\n                        // Try to extract state from the last part of the address\n                        const statePart = addressParts[addressParts.length - 1];\n                        const stateMatch = statePart.match(/[A-Z]{2}/);\n                        if (stateMatch) {\n                            cleanedProperties[index].state = stateMatch[0];\n                            propertyCleaned = true;\n                            cleaningNotes.push(\"State extracted from address\");\n                        }\n                    }\n                }\n                // Flag suspicious coordinates for advanced cleaning\n                if (advancedOptions) {\n                    const latStr = String(property.latitude || \"\");\n                    const lngStr = String(property.longitude || \"\");\n                    // Check for suspicious patterns in coordinates\n                    const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2;\n                    const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                    if (hasLowPrecision || hasSuspiciousPattern) {\n                        cleanedProperties[index]._is_grid_pattern = true;\n                        cleanedProperties[index]._needs_geocoding = true;\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged suspicious coordinates for geocoding\");\n                    }\n                }\n                // Flag test properties\n                if (property.name && property.name.toLowerCase().includes(\"test\") || property.name && property.name.toLowerCase().includes(\"example\") || property.address && property.address.toLowerCase().includes(\"test\")) {\n                    cleanedProperties[index]._is_test_property = true;\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Flagged as test property\");\n                }\n                // Flag suspicious zeros for advanced cleaning\n                if (advancedOptions && (property.price === 0 || property.units === 0 || property.num_units === 0)) {\n                    // We'll just flag these for now, manual review is needed\n                    if (!cleanedProperties[index]._data_quality_issues) {\n                        cleanedProperties[index]._data_quality_issues = [];\n                    }\n                    if (property.price === 0) {\n                        cleanedProperties[index]._data_quality_issues.push(\"zero_price\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged zero price\");\n                    }\n                    if (property.units === 0 || property.num_units === 0) {\n                        cleanedProperties[index]._data_quality_issues.push(\"zero_units\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged zero units\");\n                    }\n                }\n                // Update property with cleaning information\n                if (propertyCleaned) {\n                    cleanedProperties[index]._data_cleaned = true;\n                    cleanedProperties[index]._cleaning_notes = cleaningNotes.join(\", \");\n                    issuesCleaned++;\n                }\n            });\n            // Update state with cleaned properties\n            setProperties(cleanedProperties);\n            calculateStats(cleanedProperties);\n            // Alert user of results\n            alert(\"Data cleaning complete!\\n\\n\" + \"- \".concat(issuesCleaned, \" properties were cleaned\\n\") + \"- Added names to \".concat(dataIssues.missingNames, \" properties\\n\") + \"- Extracted city/state for \".concat(dataIssues.incompleteAddresses, \" properties\\n\") + \"- Flagged \".concat(dataIssues.suspiciousCoordinates, \" suspicious coordinates for geocoding\\n\") + \"- Identified \".concat(dataIssues.duplicateNames.length, \" duplicate names\\n\") + \"- Flagged \".concat(dataIssues.testProperties, \" test properties\\n\\n\") + \"Next steps:\\n\" + '1. Use \"Batch Geocode\" to fix flagged coordinates\\n' + '2. Use \"Properties Analysis\" to review data quality\\n' + \"3. Some properties still require manual review\");\n        } catch (error) {\n            console.error(\"Error cleaning property data:\", error);\n            alert(\"Error cleaning data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Helper function to find duplicates in properties by field\n    function findDuplicates(array, key) {\n        const counts = {};\n        const duplicates = [];\n        // Skip entries with empty values\n        array.forEach((item)=>{\n            if (item[key] && item[key].trim() !== \"\") {\n                const value = item[key].toLowerCase().trim();\n                counts[value] = (counts[value] || 0) + 1;\n            }\n        });\n        // Find values that appear more than once\n        Object.keys(counts).forEach((value)=>{\n            if (counts[value] > 1) {\n                duplicates.push({\n                    value,\n                    count: counts[value]\n                });\n            }\n        });\n        return duplicates;\n    }\n    // Function to enrich property data with zero values\n    async function enrichPropertyData() {\n        try {\n            setLoading(true);\n            // Identify properties with suspicious zero values\n            const suspiciousProperties = properties.filter((p)=>p.price === 0 || p.units === 0 || p.num_units === 0);\n            if (suspiciousProperties.length === 0) {\n                alert(\"No properties with suspicious zero values found\");\n                setLoading(false);\n                return;\n            }\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(suspiciousProperties.length, \" properties with suspicious zero values:\\n\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.price === 0).length, \" properties with zero price\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0 || p.num_units === 0).length, \" properties with zero units\\n\\n\") + \"Would you like to attempt to enrich these properties?\");\n            if (!confirmation) {\n                setLoading(false);\n                return;\n            }\n            // Make a copy of the properties for enrichment\n            const enrichedProperties = [\n                ...properties\n            ];\n            let enrichedCount = 0;\n            // Analyze collections of similar properties to derive estimates\n            // Group properties by city/state for better comparison\n            const cityStateGroups = {};\n            properties.forEach((p)=>{\n                if (p.city && p.state && p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)) {\n                    const key = \"\".concat(p.city.toLowerCase(), \",\").concat(p.state.toLowerCase());\n                    if (!cityStateGroups[key]) {\n                        cityStateGroups[key] = [];\n                    }\n                    cityStateGroups[key].push(p);\n                }\n            });\n            // Calculate median values per city/state\n            const medianValues = {};\n            Object.keys(cityStateGroups).forEach((key)=>{\n                const group = cityStateGroups[key];\n                if (group.length >= 3) {\n                    // Calculate median price per unit\n                    const pricesPerUnit = group.map((p)=>{\n                        const units = p.units || p.num_units || 0;\n                        return units > 0 ? p.price / units : 0;\n                    }).filter((v)=>v > 0).sort((a, b)=>a - b);\n                    const medianPricePerUnit = pricesPerUnit[Math.floor(pricesPerUnit.length / 2)];\n                    // Calculate median year built\n                    const yearBuilt = group.map((p)=>p.year_built).filter((y)=>y && y > 1900).sort((a, b)=>a - b);\n                    const medianYearBuilt = yearBuilt.length > 0 ? yearBuilt[Math.floor(yearBuilt.length / 2)] : null;\n                    medianValues[key] = {\n                        medianPricePerUnit,\n                        medianYearBuilt,\n                        sampleSize: group.length\n                    };\n                }\n            });\n            // Enrich properties with suspicious zero values\n            suspiciousProperties.forEach((property)=>{\n                const index = enrichedProperties.findIndex((p)=>p.id === property.id);\n                if (index === -1) return;\n                let isEnriched = false;\n                let enrichmentNotes = [];\n                // Find the best reference group for this property\n                let referenceGroup = null;\n                let referenceKey = null;\n                if (property.city && property.state) {\n                    const key = \"\".concat(property.city.toLowerCase(), \",\").concat(property.state.toLowerCase());\n                    if (medianValues[key]) {\n                        referenceGroup = medianValues[key];\n                        referenceKey = key;\n                    }\n                }\n                // If no direct city/state match, use the closest geographically or a general average\n                if (!referenceGroup) {\n                    // Fall back to state-level data or general average\n                    if (property.state) {\n                        const stateGroups = Object.keys(medianValues).filter((key)=>key.endsWith(\",\".concat(property.state.toLowerCase())));\n                        if (stateGroups.length > 0) {\n                            // Use the largest sample from the state\n                            referenceKey = stateGroups.sort((a, b)=>medianValues[b].sampleSize - medianValues[a].sampleSize)[0];\n                            referenceGroup = medianValues[referenceKey];\n                        }\n                    }\n                    // If still no match, use the overall average\n                    if (!referenceGroup) {\n                        const allPricesPerUnit = properties.filter((p)=>p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)).map((p)=>p.price / (p.units || p.num_units)).sort((a, b)=>a - b);\n                        if (allPricesPerUnit.length > 0) {\n                            referenceGroup = {\n                                medianPricePerUnit: allPricesPerUnit[Math.floor(allPricesPerUnit.length / 2)],\n                                medianYearBuilt: null,\n                                sampleSize: allPricesPerUnit.length\n                            };\n                            referenceKey = \"all_properties\";\n                        }\n                    }\n                }\n                // Calculate missing values\n                if (referenceGroup) {\n                    // Fix zero price if units are available\n                    if (property.price === 0 && (property.units > 0 || property.num_units > 0)) {\n                        const units = property.units || property.num_units;\n                        enrichedProperties[index].price = Math.round(referenceGroup.medianPricePerUnit * units);\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated price based on \".concat(referenceKey, \" median ($\").concat(Math.round(referenceGroup.medianPricePerUnit).toLocaleString(), \"/unit)\"));\n                    }\n                    // Fix zero units if price is available\n                    if ((property.units === 0 || !property.units) && (property.num_units === 0 || !property.num_units) && property.price > 0 && referenceGroup.medianPricePerUnit > 0) {\n                        const estimatedUnits = Math.round(property.price / referenceGroup.medianPricePerUnit);\n                        enrichedProperties[index].units = estimatedUnits;\n                        enrichedProperties[index].num_units = estimatedUnits;\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated \".concat(estimatedUnits, \" units based on price and \").concat(referenceKey, \" median\"));\n                    }\n                    // Add missing year built if we have a reference\n                    if ((!property.year_built || property.year_built < 1900) && referenceGroup.medianYearBuilt) {\n                        enrichedProperties[index].year_built = referenceGroup.medianYearBuilt;\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated year built as \".concat(referenceGroup.medianYearBuilt, \" based on \").concat(referenceKey, \" median\"));\n                    }\n                }\n                // Flag property as needing human review if we couldn't enrich it\n                if (!isEnriched) {\n                    // Mark as needing manual review\n                    if (!enrichedProperties[index]._data_quality_issues) {\n                        enrichedProperties[index]._data_quality_issues = [];\n                    }\n                    enrichedProperties[index]._data_quality_issues.push(\"needs_manual_review\");\n                    isEnriched = true;\n                    enrichmentNotes.push(\"Marked for manual review - insufficient data to make estimates\");\n                }\n                // Update property with enrichment information\n                if (isEnriched) {\n                    enrichedProperties[index]._data_enriched = true;\n                    enrichedProperties[index]._enrichment_notes = enrichmentNotes.join(\", \");\n                    enrichedCount++;\n                }\n            });\n            // Update state with enriched properties\n            setProperties(enrichedProperties);\n            calculateStats(enrichedProperties);\n            // Alert user of results\n            alert(\"Data enrichment complete!\\n\\n\" + \"- \".concat(enrichedCount, \" properties were enriched or marked for review\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.price === 0).length, \" properties with zero price processed\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0 || p.num_units === 0).length, \" properties with zero units processed\\n\\n\") + \"Next steps:\\n\" + \"1. Review the enriched data for accuracy\\n\" + \"2. Properties marked for manual review need human attention\\n\" + '3. Use \"Properties Analysis\" to verify data quality');\n        } catch (error) {\n            console.error(\"Error enriching property data:\", error);\n            alert(\"Error enriching data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Function to add a log entry with timestamp\n    const addGeocodingLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"info\";\n        const timestamp = new Date().toLocaleTimeString();\n        setGeocodingLogs((prevLogs)=>[\n                {\n                    message,\n                    timestamp,\n                    type\n                },\n                ...prevLogs.slice(0, 99) // Keep only the last 100 logs\n            ]);\n    }, []);\n    // Clear logs when starting new geocoding process\n    const clearGeocodingLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setGeocodingLogs([]);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_components_Layout__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        title: \"Property Map | Austin Multifamily\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container mx-auto px-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex justify-between items-center mb-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-2xl font-bold\",\n                            children: [\n                                \"Property Map \",\n                                loading ? \"(Loading...)\" : \"(\".concat(properties.length, \" properties shown)\")\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                            lineNumber: 796,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm text-gray-500\",\n                                children: \"Loading properties...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 802,\n                                columnNumber: 15\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-sm bg-white shadow-sm border border-gray-200 rounded px-3 py-1\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-medium\",\n                                                children: totalFetched\n                                            }, void 0, false, {\n                                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                                lineNumber: 806,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" properties fetched\",\n                                            properties.length !== totalFetched && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-gray-500 ml-1\",\n                                                children: [\n                                                    \"(\",\n                                                    totalFetched - properties.length,\n                                                    \" filtered)\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                                lineNumber: 808,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 805,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm bg-blue-100 hover:bg-blue-200 text-blue-700 rounded px-3 py-1 transition\",\n                                        onClick: runPropertyAnalysis,\n                                        children: \"Properties Analysis\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 814,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(geocoding ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-indigo-100 hover:bg-indigo-200 text-indigo-700\"),\n                                        onClick: batchGeocodeProperties,\n                                        disabled: geocoding,\n                                        children: geocoding ? \"Geocoding...\" : \"Batch Geocode\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 821,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(loading ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-amber-100 hover:bg-amber-200 text-amber-700\"),\n                                        onClick: cleanPropertyData,\n                                        disabled: loading,\n                                        children: \"Clean Data\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 833,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(loading ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-purple-100 hover:bg-purple-200 text-purple-700\"),\n                                        onClick: enrichPropertyData,\n                                        disabled: loading,\n                                        children: \"Enrich Data\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 845,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded px-3 py-1 transition\",\n                                        onClick: ()=>loadProperties(),\n                                        children: \"Refresh Map\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 857,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true)\n                        }, void 0, false, {\n                            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                            lineNumber: 800,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                    lineNumber: 795,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"h-[80vh]\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MapComponent, {\n                        properties: properties,\n                        selectedProperty: selectedProperty,\n                        setSelectedProperty: setSelectedProperty,\n                        onBoundsChange: handleBoundsChange\n                    }, void 0, false, {\n                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                        lineNumber: 869,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                    lineNumber: 868,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n            lineNumber: 794,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n        lineNumber: 793,\n        columnNumber: 5\n    }, this);\n}\n_s(MapPage, \"cjXAp6+U/cZXiYPZLymjp+NrESk=\");\n_c1 = MapPage;\nvar _c, _c1;\n$RefreshReg$(_c, \"MapComponent\");\n$RefreshReg$(_c1, \"MapPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TjtrREFDWDs7Ozs7O2tEQUlELDhEQUFDd047d0NBQ0NILFdBQVU7d0NBQ1ZJLFNBQVMsSUFBTXJNO2tEQUNoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFRVCw4REFBQ2dNO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDNU47d0JBQ0NHLFlBQVlBO3dCQUNaRSxrQkFBa0JBO3dCQUNsQkMscUJBQXFCQTt3QkFDckI0TixnQkFBZ0JwTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU01QjtHQWwyQndCNUI7TUFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvbWFwLmpzP2QyNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vc3JjL2NvbXBvbmVudHMvTGF5b3V0JztcbmltcG9ydCB7IGZldGNoUHJvcGVydGllcyB9IGZyb20gJy4uL2xpYi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBlbmhhbmNlZEdlb2NvZGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vbGliL2dlb2NvZGluZyc7XG5cbi8vIEltcG9ydCB0aGUgbWFwIGNvbXBvbmVudCBkeW5hbWljYWxseSB0byBhdm9pZCBTU1IgaXNzdWVzIHdpdGggTGVhZmxldFxuY29uc3QgTWFwQ29tcG9uZW50ID0gZHluYW1pYyhcbiAgKCkgPT4gaW1wb3J0KCcuLi9zcmMvY29tcG9uZW50cy9NYXBDb21wb25lbnQnKSxcbiAgeyBzc3I6IGZhbHNlIH1cbik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcFBhZ2UoKSB7XG4gIGNvbnN0IFtwcm9wZXJ0aWVzLCBzZXRQcm9wZXJ0aWVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3NlbGVjdGVkUHJvcGVydHksIHNldFNlbGVjdGVkUHJvcGVydHldID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZ2VvY29kaW5nLCBzZXRHZW9jb2RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZ2VvY29kaW5nTG9ncywgc2V0R2VvY29kaW5nTG9nc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtzaG93R2VvY29kaW5nTG9ncywgc2V0U2hvd0dlb2NvZGluZ0xvZ3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbWFwQm91bmRzLCBzZXRNYXBCb3VuZHNdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFt0b3RhbEZldGNoZWQsIHNldFRvdGFsRmV0Y2hlZF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2RhdGFTdGF0cywgc2V0RGF0YVN0YXRzXSA9IHVzZVN0YXRlKHtcbiAgICB0b3RhbFByb3BlcnRpZXM6IDAsXG4gICAgaW52YWxpZENvb3JkaW5hdGVzOiAwLFxuICAgIG1pc3NpbmdDb29yZGluYXRlczogMCxcbiAgICB6ZXJvQ29vcmRpbmF0ZXM6IDAsXG4gICAgaW52YWxpZFJhbmdlOiAwLFxuICAgIGR1cGxpY2F0ZWRMb2NhdGlvbnM6IDBcbiAgfSk7XG5cbiAgLy8gSW5pdGlhbCBwcm9wZXJ0eSBsb2FkIG9uIHBhZ2UgbG9hZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRQcm9wZXJ0aWVzKCk7XG4gIH0sIFtdKTtcblxuICAvLyBSZWxvYWQgcHJvcGVydGllcyB3aGVuIG1hcCBib3VuZHMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcEJvdW5kcykge1xuICAgICAgY29uc29sZS5sb2coJ01hcCBib3VuZHMgY2hhbmdlZCwgbG9hZGluZyBwcm9wZXJ0aWVzIGluIHRoZSB2aXNpYmxlIGFyZWEnKTtcbiAgICAgIGxvYWRQcm9wZXJ0aWVzKG1hcEJvdW5kcyk7XG4gICAgfVxuICB9LCBbbWFwQm91bmRzXSk7XG5cbiAgLy8gSGFuZGxlIG1hcCBib3VuZHMgY2hhbmdlc1xuICBjb25zdCBoYW5kbGVCb3VuZHNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoYm91bmRzKSA9PiB7XG4gICAgc2V0TWFwQm91bmRzKGJvdW5kcyk7XG4gIH0sIFtdKTtcblxuICAvLyBDYWxjdWxhdGUgc3RhdGlzdGljcyBhYm91dCB0aGUgcHJvcGVydHkgZGF0YVxuICBjb25zdCBjYWxjdWxhdGVTdGF0cyA9IHVzZUNhbGxiYWNrKChwcm9wRGF0YSkgPT4ge1xuICAgIGlmICghcHJvcERhdGEgfHwgIUFycmF5LmlzQXJyYXkocHJvcERhdGEpKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgbWlzc2luZ0Nvb3JkcyA9IHByb3BEYXRhLmZpbHRlcihwID0+ICFwLmxhdGl0dWRlIHx8ICFwLmxvbmdpdHVkZSkubGVuZ3RoO1xuICAgIGNvbnN0IHplcm9Db29yZHMgPSBwcm9wRGF0YS5maWx0ZXIocCA9PiBwLmxhdGl0dWRlID09PSAwICYmIHAubG9uZ2l0dWRlID09PSAwKS5sZW5ndGg7XG4gICAgY29uc3QgaW52YWxpZFJhbmdlID0gcHJvcERhdGEuZmlsdGVyKHAgPT4ge1xuICAgICAgaWYgKCFwLmxhdGl0dWRlIHx8ICFwLmxvbmdpdHVkZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgbGF0ID0gdHlwZW9mIHAubGF0aXR1ZGUgPT09ICdudW1iZXInID8gcC5sYXRpdHVkZSA6IHBhcnNlRmxvYXQoU3RyaW5nKHAubGF0aXR1ZGUpKTtcbiAgICAgIGNvbnN0IGxuZyA9IHR5cGVvZiBwLmxvbmdpdHVkZSA9PT0gJ251bWJlcicgPyBwLmxvbmdpdHVkZSA6IHBhcnNlRmxvYXQoU3RyaW5nKHAubG9uZ2l0dWRlKSk7XG4gICAgICByZXR1cm4gKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSB8fCBsYXQgPCAtOTAgfHwgbGF0ID4gOTAgfHwgbG5nIDwgLTE4MCB8fCBsbmcgPiAxODApO1xuICAgIH0pLmxlbmd0aDtcbiAgICBcbiAgICAvLyBDb3VudCBwcm9wZXJ0aWVzIGF0IGlkZW50aWNhbCBjb29yZGluYXRlc1xuICAgIGNvbnN0IGNvb3JkTWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBkdXBsaWNhdGVkQ29vcmRzID0gMDtcbiAgICBcbiAgICBwcm9wRGF0YS5mb3JFYWNoKHAgPT4ge1xuICAgICAgaWYgKHAubGF0aXR1ZGUgJiYgcC5sb25naXR1ZGUpIHtcbiAgICAgICAgY29uc3QgY29vcmRLZXkgPSBgJHtwLmxhdGl0dWRlfSwke3AubG9uZ2l0dWRlfWA7XG4gICAgICAgIGlmIChjb29yZE1hcC5oYXMoY29vcmRLZXkpKSB7XG4gICAgICAgICAgY29vcmRNYXAuc2V0KGNvb3JkS2V5LCBjb29yZE1hcC5nZXQoY29vcmRLZXkpICsgMSk7XG4gICAgICAgICAgZHVwbGljYXRlZENvb3JkcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb3JkTWFwLnNldChjb29yZEtleSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzZXREYXRhU3RhdHMoe1xuICAgICAgdG90YWxQcm9wZXJ0aWVzOiBwcm9wRGF0YS5sZW5ndGgsXG4gICAgICBpbnZhbGlkQ29vcmRpbmF0ZXM6IG1pc3NpbmdDb29yZHMgKyB6ZXJvQ29vcmRzICsgaW52YWxpZFJhbmdlLFxuICAgICAgbWlzc2luZ0Nvb3JkaW5hdGVzOiBtaXNzaW5nQ29vcmRzLFxuICAgICAgemVyb0Nvb3JkaW5hdGVzOiB6ZXJvQ29vcmRzLFxuICAgICAgaW52YWxpZFJhbmdlOiBpbnZhbGlkUmFuZ2UsXG4gICAgICBkdXBsaWNhdGVkTG9jYXRpb25zOiBkdXBsaWNhdGVkQ29vcmRzLFxuICAgICAgdW5pcXVlTG9jYXRpb25zOiBjb29yZE1hcC5zaXplXG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICAvLyBGdW5jdGlvbiB0byBsb2FkIHByb3BlcnRpZXMgd2l0aCBvcHRpb25hbCBib3VuZHMgZmlsdGVyXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRQcm9wZXJ0aWVzKGJvdW5kcyA9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IFxuICAgICAgICBzb3J0Qnk6ICdjcmVhdGVkX2F0JywgXG4gICAgICAgIHNvcnRBc2M6IGZhbHNlLFxuICAgICAgICBwYWdlOiAxLFxuICAgICAgICBwYWdlU2l6ZTogMTAwMCxcbiAgICAgICAgZmlsdGVyczoge30sXG4gICAgICAgIGluY2x1ZGVJbmNvbXBsZXRlOiB0cnVlLFxuICAgICAgICBpbmNsdWRlUmVzZWFyY2g6IHRydWUsXG4gICAgICAgIG5vTGltaXQ6IHRydWUgLy8gQnlwYXNzIHBhZ2luYXRpb24gdG8gZ2V0IGFsbCBwcm9wZXJ0aWVzXG4gICAgICB9O1xuXG4gICAgICAvLyBBcHBseSBib3VuZHMgZmlsdGVyIGlmIHByb3ZpZGVkXG4gICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgIG9wdGlvbnMuYm91bmRzID0gYm91bmRzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc3RhdGlzdGljc1xuICAgICAgY2FsY3VsYXRlU3RhdHMoZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEVuaGFuY2VkIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5sb2coYD09PT09IE1BUCBERUJVRyA9PT09PWApO1xuICAgICAgY29uc29sZS5sb2coYExvYWRlZCAke2RhdGEubGVuZ3RofSBwcm9wZXJ0aWVzIGZvciBtYXBgKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgY29vcmRpbmF0ZSB2YWxpZGl0eVxuICAgICAgY29uc3QgdmFsaWRDb29yZHMgPSBkYXRhLmZpbHRlcihwID0+IFxuICAgICAgICBwLmxhdGl0dWRlICYmIFxuICAgICAgICBwLmxvbmdpdHVkZSAmJiBcbiAgICAgICAgdHlwZW9mIHAubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIFxuICAgICAgICB0eXBlb2YgcC5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICEocC5sYXRpdHVkZSA9PT0gMCAmJiBwLmxvbmdpdHVkZSA9PT0gMClcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhgUHJvcGVydGllcyB3aXRoIHZhbGlkIGNvb3JkaW5hdGVzOiAke3ZhbGlkQ29vcmRzLmxlbmd0aH1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgQXVzdGluIGFyZWEgY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IGF1c3RpbkNvb3JkcyA9IHZhbGlkQ29vcmRzLmZpbHRlcihwID0+IFxuICAgICAgICBwLmxhdGl0dWRlID49IDI5LjUgJiYgcC5sYXRpdHVkZSA8PSAzMS4wICYmIFxuICAgICAgICBwLmxvbmdpdHVkZSA+PSAtOTguMCAmJiBwLmxvbmdpdHVkZSA8PSAtOTcuMFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9wZXJ0aWVzIHdpdGggY29vcmRpbmF0ZXMgaW4gQXVzdGluIGFyZWE6ICR7YXVzdGluQ29vcmRzLmxlbmd0aH1gKTtcbiAgICAgIFxuICAgICAgLy8gTG9vayBmb3Igc3VzcGljaW91cyBwYXR0ZXJuc1xuICAgICAgY29uc3Qgc3VzcGljaW91c0Nvb3JkcyA9IHZhbGlkQ29vcmRzLmZpbHRlcihwID0+IHtcbiAgICAgICAgY29uc3QgbGF0U3RyID0gU3RyaW5nKHAubGF0aXR1ZGUpO1xuICAgICAgICBjb25zdCBsbmdTdHIgPSBTdHJpbmcocC5sb25naXR1ZGUpO1xuICAgICAgICBjb25zdCBoYXNMb3dQcmVjaXNpb24gPSBcbiAgICAgICAgICAobGF0U3RyLmluY2x1ZGVzKCcuJykgJiYgbGF0U3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDEpIHx8XG4gICAgICAgICAgKGxuZ1N0ci5pbmNsdWRlcygnLicpICYmIGxuZ1N0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAxKTtcbiAgICAgICAgY29uc3QgaGFzU3VzcGljaW91c1BhdHRlcm4gPSBcbiAgICAgICAgICBsYXRTdHIgPT09IGxuZ1N0ciB8fCBcbiAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgICAgICAgbG5nU3RyLmVuZHNXaXRoKCcwMDAwMCcpO1xuICAgICAgICByZXR1cm4gaGFzTG93UHJlY2lzaW9uIHx8IGhhc1N1c3BpY2lvdXNQYXR0ZXJuO1xuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhgUHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXM6ICR7c3VzcGljaW91c0Nvb3Jkcy5sZW5ndGh9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgPT09PT0gRU5EIERFQlVHID09PT09YCk7XG4gICAgICBcbiAgICAgIHNldFByb3BlcnRpZXMoZGF0YSk7XG4gICAgICBzZXRUb3RhbEZldGNoZWQoZGF0YS5sZW5ndGgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9wZXJ0aWVzOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gYmF0Y2ggZ2VvY29kZSBwcm9wZXJ0aWVzIHdpdGggbWlzc2luZyBjb29yZGluYXRlc1xuICBhc3luYyBmdW5jdGlvbiBiYXRjaEdlb2NvZGVQcm9wZXJ0aWVzKCkge1xuICAgIHRyeSB7XG4gICAgICBzZXRHZW9jb2RpbmcodHJ1ZSk7XG4gICAgICBjbGVhckdlb2NvZGluZ0xvZ3MoKTtcbiAgICAgIHNldFNob3dHZW9jb2RpbmdMb2dzKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgcHJvcGVydGllcyB0aGF0IG5lZWQgZ2VvY29kaW5nXG4gICAgICBjb25zdCBwcm9wc1RvR2VvY29kZSA9IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gXG4gICAgICAgICFwLmxhdGl0dWRlIHx8ICFwLmxvbmdpdHVkZSB8fCBcbiAgICAgICAgcC5sYXRpdHVkZSA9PT0gMCB8fCBwLmxvbmdpdHVkZSA9PT0gMCB8fFxuICAgICAgICBwLl9jb29yZGluYXRlc19taXNzaW5nIHx8IHAuX25lZWRzX2dlb2NvZGluZyB8fFxuICAgICAgICBwLl9pc19ncmlkX3BhdHRlcm5cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChwcm9wc1RvR2VvY29kZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWRkR2VvY29kaW5nTG9nKCdObyBwcm9wZXJ0aWVzIG5lZWQgZ2VvY29kaW5nJywgJ2luZm8nKTtcbiAgICAgICAgYWxlcnQoJ05vIHByb3BlcnRpZXMgbmVlZCBnZW9jb2RpbmcnKTtcbiAgICAgICAgc2V0R2VvY29kaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb25maXJtIHdpdGggdXNlclxuICAgICAgYWRkR2VvY29kaW5nTG9nKGBGb3VuZCAke3Byb3BzVG9HZW9jb2RlLmxlbmd0aH0gcHJvcGVydGllcyB0aGF0IG5lZWQgZ2VvY29kaW5nYCwgJ2luZm8nKTtcbiAgICAgIGlmICghY29uZmlybShgVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ2VvY29kZSAke3Byb3BzVG9HZW9jb2RlLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIG1pc3Npbmcgb3IgaW52YWxpZCBjb29yZGluYXRlcy4gQ29udGludWU/YCkpIHtcbiAgICAgICAgYWRkR2VvY29kaW5nTG9nKCdHZW9jb2RpbmcgY2FuY2VsbGVkIGJ5IHVzZXInLCAnd2FybmluZycpO1xuICAgICAgICBzZXRHZW9jb2RpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGFkZEdlb2NvZGluZ0xvZyhgU3RhcnRpbmcgYmF0Y2ggZ2VvY29kaW5nIG9mICR7cHJvcHNUb0dlb2NvZGUubGVuZ3RofSBwcm9wZXJ0aWVzYCwgJ2luZm8nKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBpbiBiYXRjaGVzIG9mIDI1IHRvIGF2b2lkIHJhdGUgbGltaXRzXG4gICAgICBjb25zdCBiYXRjaFNpemUgPSAyNTtcbiAgICAgIGNvbnN0IGJhdGNoZXMgPSBNYXRoLmNlaWwocHJvcHNUb0dlb2NvZGUubGVuZ3RoIC8gYmF0Y2hTaXplKTtcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgbGV0IGZhaWxDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIGJhdGNoU2l6ZTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBiYXRjaFNpemUsIHByb3BzVG9HZW9jb2RlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gcHJvcHNUb0dlb2NvZGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIFxuICAgICAgICBhZGRHZW9jb2RpbmdMb2coYFByb2Nlc3NpbmcgYmF0Y2ggJHtpKzF9LyR7YmF0Y2hlc30gKCR7YmF0Y2gubGVuZ3RofSBwcm9wZXJ0aWVzKWAsICdpbmZvJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGJhdGNoICR7aSsxfS8ke2JhdGNoZXN9ICgke2JhdGNoLmxlbmd0aH0gcHJvcGVydGllcylgKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRm9yIGVhY2ggcHJvcGVydHkgaW4gdGhlIGJhdGNoLCBsb2cgdGhlIHByb3BlcnR5IGJlaW5nIHByb2Nlc3NlZFxuICAgICAgICAgIGJhdGNoLmZvckVhY2goKHByb3BlcnR5LCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5Lm5hbWUgfHwgYFByb3BlcnR5ICMke3Byb3BlcnR5LmlkfWA7XG4gICAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYFske2krMX0uJHtpZHgrMX1dIFF1ZXVpbmcgJHtwcm9wZXJ0eU5hbWV9YCwgJ2RldGFpbCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGdlb2NvZGVkQmF0Y2ggPSBhd2FpdCBlbmhhbmNlZEdlb2NvZGVQcm9wZXJ0aWVzKGJhdGNoLCAocHJvcGVydHksIHN0YXR1cywgZGV0YWlscykgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggcHJvcGVydHkgYXMgaXQncyBwcm9jZXNzZWRcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5Lm5hbWUgfHwgYFByb3BlcnR5ICMke3Byb3BlcnR5LmlkfWA7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgYWRkR2VvY29kaW5nTG9nKGBHZW9jb2RlZDogJHtwcm9wZXJ0eU5hbWV9ICgke2RldGFpbHN9KWAsICdzdWNjZXNzJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYEZhaWxlZDogJHtwcm9wZXJ0eU5hbWV9ICgke2RldGFpbHN9KWAsICdlcnJvcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkR2VvY29kaW5nTG9nKGAke3N0YXR1c306ICR7cHJvcGVydHlOYW1lfSAke2RldGFpbHMgPyBgKCR7ZGV0YWlsc30pYCA6ICcnfWAsICdpbmZvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ291bnQgc3VjY2Vzc2VzIGFuZCBmYWlsdXJlc1xuICAgICAgICAgIGNvbnN0IGJhdGNoU3VjY2VzcyA9IGdlb2NvZGVkQmF0Y2guZmlsdGVyKHAgPT4gcC5fZ2VvY29kZWQpLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBiYXRjaEZhaWwgPSBnZW9jb2RlZEJhdGNoLmZpbHRlcihwID0+IHAuX2dlb2NvZGluZ19mYWlsZWQpLmxlbmd0aDtcbiAgICAgICAgICBcbiAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gYmF0Y2hTdWNjZXNzO1xuICAgICAgICAgIGZhaWxDb3VudCArPSBiYXRjaEZhaWw7XG4gICAgICAgICAgXG4gICAgICAgICAgYWRkR2VvY29kaW5nTG9nKGBCYXRjaCAke2krMX0gY29tcGxldGU6ICR7YmF0Y2hTdWNjZXNzfSBzdWNjZXNzZXMsICR7YmF0Y2hGYWlsfSBmYWlsdXJlc2AsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFN1Y2Nlc3MgPiBiYXRjaEZhaWwgPyAnc3VjY2VzcycgOiAnd2FybmluZycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1lcmdlIGdlb2NvZGVkIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBtYWluIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb3BlcnRpZXMgPSBbLi4ucHJvcGVydGllc107XG4gICAgICAgICAgZ2VvY29kZWRCYXRjaC5mb3JFYWNoKGdlb2NvZGVkUHJvcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHVwZGF0ZWRQcm9wZXJ0aWVzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IGdlb2NvZGVkUHJvcC5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRQcm9wZXJ0aWVzW2luZGV4XSA9IGdlb2NvZGVkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3BlcnRpZXMgc3RhdGVcbiAgICAgICAgICBzZXRQcm9wZXJ0aWVzKHVwZGF0ZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBjYWxjdWxhdGVTdGF0cyh1cGRhdGVkUHJvcGVydGllcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBhIGJpdCBiZXR3ZWVuIGJhdGNoZXMgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcbiAgICAgICAgICBpZiAoaSA8IGJhdGNoZXMgLSAxKSB7XG4gICAgICAgICAgICBhZGRHZW9jb2RpbmdMb2coYFdhaXRpbmcgMiBzZWNvbmRzIGJlZm9yZSBuZXh0IGJhdGNoIHRvIGF2b2lkIHJhdGUgbGltaXRzYCwgJ2luZm8nKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdlb2NvZGluZyBiYXRjaCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgIGFkZEdlb2NvZGluZ0xvZyhgRXJyb3Igd2l0aCBiYXRjaCAke2krMX06ICR7ZXJyb3IubWVzc2FnZX1gLCAnZXJyb3InKTtcbiAgICAgICAgICBmYWlsQ291bnQgKz0gYmF0Y2gubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGFkZEdlb2NvZGluZ0xvZyhgR2VvY29kaW5nIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0gc3VjY2Vzc2VzLCAke2ZhaWxDb3VudH0gZmFpbHVyZXNgLCBcbiAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgPiBmYWlsQ291bnQgPyAnc3VjY2VzcycgOiAnZXJyb3InKTtcbiAgICAgIFxuICAgICAgYWxlcnQoYEdlb2NvZGluZyBjb21wbGV0ZTpcXG5cXG4ke3N1Y2Nlc3NDb3VudH0gcHJvcGVydGllcyBzdWNjZXNzZnVsbHkgZ2VvY29kZWRcXG4ke2ZhaWxDb3VudH0gcHJvcGVydGllcyBmYWlsZWQgdG8gZ2VvY29kZWApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGJhdGNoIGdlb2NvZGluZzonLCBlcnJvcik7XG4gICAgICBhZGRHZW9jb2RpbmdMb2coYEdlb2NvZGluZyBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsICdlcnJvcicpO1xuICAgICAgYWxlcnQoYEVycm9yIGdlb2NvZGluZyBwcm9wZXJ0aWVzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEdlb2NvZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuUHJvcGVydHlBbmFseXNpcygpIHtcbiAgICAvLyBDb3VudCBwcm9wZXJ0aWVzIGF0IGlkZW50aWNhbCBjb29yZGluYXRlc1xuICAgIGNvbnN0IGNvb3JkTWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBkdXBsaWNhdGVkQ29vcmRzID0gMDtcbiAgICBcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICBpZiAocC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSkge1xuICAgICAgICBjb25zdCBjb29yZEtleSA9IGAke3AubGF0aXR1ZGV9LCR7cC5sb25naXR1ZGV9YDtcbiAgICAgICAgaWYgKGNvb3JkTWFwLmhhcyhjb29yZEtleSkpIHtcbiAgICAgICAgICBjb29yZE1hcC5zZXQoY29vcmRLZXksIGNvb3JkTWFwLmdldChjb29yZEtleSkgKyAxKTtcbiAgICAgICAgICBkdXBsaWNhdGVkQ29vcmRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRNYXAuc2V0KGNvb3JkS2V5LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZpbmQgY29vcmRpbmF0ZXMgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgY29uc3QgbXVsdGlwbGVQcm9wc0xvY2F0aW9ucyA9IEFycmF5LmZyb20oY29vcmRNYXAuZW50cmllcygpKVxuICAgICAgLmZpbHRlcigoW18sIGNvdW50XSkgPT4gY291bnQgPiAxKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTsgLy8gU29ydCBieSBjb3VudCBkZXNjZW5kaW5nXG4gICAgXG4gICAgY29uc3QgbXVsdGlwbGVQcm9wc0NvdW50ID0gbXVsdGlwbGVQcm9wc0xvY2F0aW9ucy5yZWR1Y2UoKHN1bSwgW18sIGNvdW50XSkgPT4gc3VtICsgY291bnQsIDApO1xuICAgIGNvbnN0IHVuaXF1ZUxvY2F0aW9ucyA9IGNvb3JkTWFwLnNpemU7XG4gICAgXG4gICAgLy8gQ291bnQgYnkgZ2VvY29kaW5nIHNvdXJjZSBpZiBhdmFpbGFibGVcbiAgICBjb25zdCBieVNvdXJjZSA9IHtcbiAgICAgIGV4aXN0aW5nOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAuX2dlb2NvZGluZ19zb3VyY2UgPT09ICdleGlzdGluZycpLmxlbmd0aCxcbiAgICAgIHZlcmlmaWVkX2FkZHJlc3M6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ3ZlcmlmaWVkX2FkZHJlc3MnKS5sZW5ndGgsXG4gICAgICBmdWxsX2FkZHJlc3M6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ2Z1bGxfYWRkcmVzcycpLmxlbmd0aCxcbiAgICAgIHByb3BlcnR5X25hbWU6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ3Byb3BlcnR5X25hbWUnKS5sZW5ndGgsXG4gICAgICB1bmtub3duOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAubGF0aXR1ZGUgJiYgcC5sb25naXR1ZGUgJiYgIXAuX2dlb2NvZGluZ19zb3VyY2UpLmxlbmd0aFxuICAgIH07XG4gICAgXG4gICAgYWxlcnQoXG4gICAgICBgTWFwIFByb3BlcnRpZXMgQW5hbHlzaXM6XFxuXFxuYCArXG4gICAgICBgLSBUb3RhbCBwcm9wZXJ0aWVzOiAke3Byb3BlcnRpZXMubGVuZ3RofVxcbmAgK1xuICAgICAgYC0gUHJvcGVydGllcyB3aXRoIGludmFsaWQgY29vcmRpbmF0ZXM6ICR7ZGF0YVN0YXRzLmludmFsaWRDb29yZGluYXRlc31cXG5gICtcbiAgICAgIGAgICDigKIgTWlzc2luZyBjb29yZGluYXRlczogJHtkYXRhU3RhdHMubWlzc2luZ0Nvb3JkaW5hdGVzfVxcbmAgK1xuICAgICAgYCAgIOKAoiBaZXJvIGNvb3JkaW5hdGVzOiAke2RhdGFTdGF0cy56ZXJvQ29vcmRpbmF0ZXN9XFxuYCArXG4gICAgICBgICAg4oCiIEludmFsaWQgY29vcmRpbmF0ZSByYW5nZTogJHtkYXRhU3RhdHMuaW52YWxpZFJhbmdlfVxcblxcbmAgK1xuICAgICAgYC0gVW5pcXVlIGxvY2F0aW9ucyBvbiBtYXA6ICR7dW5pcXVlTG9jYXRpb25zfVxcbmAgK1xuICAgICAgYC0gUHJvcGVydGllcyBzaGFyaW5nIGV4YWN0IGNvb3JkaW5hdGVzOiAke2R1cGxpY2F0ZWRDb29yZHN9XFxuYCArXG4gICAgICBgLSBOdW1iZXIgb2Ygc2hhcmVkIGxvY2F0aW9uczogJHttdWx0aXBsZVByb3BzTG9jYXRpb25zLmxlbmd0aH1cXG5cXG5gICtcbiAgICAgIChtdWx0aXBsZVByb3BzTG9jYXRpb25zLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgYFRvcCBzaGFyZWQgbG9jYXRpb25zOlxcbmAgK1xuICAgICAgICBtdWx0aXBsZVByb3BzTG9jYXRpb25zLnNsaWNlKDAsIDUpLm1hcCgoW2Nvb3JkcywgY291bnRdKSA9PiBcbiAgICAgICAgICBgICAg4oCiICR7Y291bnR9IHByb3BlcnRpZXMgYXQgJHtjb29yZHN9YFxuICAgICAgICApLmpvaW4oJ1xcbicpIDogJycpICtcbiAgICAgIGBcXG5cXG5gICtcbiAgICAgIGBHZW9jb2Rpbmcgc291cmNlczpcXG5gICtcbiAgICAgIGAgICDigKIgRXhpc3RpbmcgdmFsaWQ6ICR7YnlTb3VyY2UuZXhpc3Rpbmd9XFxuYCArXG4gICAgICBgICAg4oCiIFZlcmlmaWVkIGFkZHJlc3M6ICR7YnlTb3VyY2UudmVyaWZpZWRfYWRkcmVzc31cXG5gICtcbiAgICAgIGAgICDigKIgRnVsbCBhZGRyZXNzOiAke2J5U291cmNlLmZ1bGxfYWRkcmVzc31cXG5gICtcbiAgICAgIGAgICDigKIgUHJvcGVydHkgbmFtZTogJHtieVNvdXJjZS5wcm9wZXJ0eV9uYW1lfVxcbmAgK1xuICAgICAgYCAgIOKAoiBVbmtub3duIHNvdXJjZTogJHtieVNvdXJjZS51bmtub3dufVxcblxcbmAgK1xuICAgICAgYE5vdGU6IFByb3BlcnRpZXMgYXQgaWRlbnRpY2FsIGNvb3JkaW5hdGVzIHdpbGwgYXBwZWFyIGFzIGEgc2luZ2xlIG1hcmtlciB1bnRpbCBjbGlja2VkLmBcbiAgICApO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gY2xlYW4gcHJvcGVydHkgZGF0YVxuICBhc3luYyBmdW5jdGlvbiBjbGVhblByb3BlcnR5RGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgdGhlIGNsZWFuaW5nIHByb2Nlc3NcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0LCBhbmFseXplIHRoZSBkYXRhIHRvIGlkZW50aWZ5IGlzc3Vlc1xuICAgICAgY29uc3QgZGF0YUlzc3VlcyA9IHtcbiAgICAgICAgbWlzc2luZ05hbWVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+ICFwLm5hbWUgfHwgcC5uYW1lLnRyaW0oKSA9PT0gJycpLmxlbmd0aCxcbiAgICAgICAgaW5jb21wbGV0ZUFkZHJlc3NlczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLmFkZHJlc3MgJiYgKCFwLmNpdHkgfHwgIXAuc3RhdGUpKS5sZW5ndGgsXG4gICAgICAgIHN1c3BpY2lvdXNaZXJvczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBcbiAgICAgICAgICAocC5wcmljZSA9PT0gMCB8fCBwLnVuaXRzID09PSAwIHx8IHAubnVtX3VuaXRzID09PSAwKVxuICAgICAgICApLmxlbmd0aCxcbiAgICAgICAgc3VzcGljaW91c0Nvb3JkaW5hdGVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJucyBpbiBjb29yZGluYXRlc1xuICAgICAgICAgIGlmICghcC5sYXRpdHVkZSB8fCAhcC5sb25naXR1ZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocC5sYXRpdHVkZSk7XG4gICAgICAgICAgY29uc3QgbG5nU3RyID0gU3RyaW5nKHAubG9uZ2l0dWRlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBmb3IgdmVyeSBsb3cgcHJlY2lzaW9uIG9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGxhdFN0ci5pbmNsdWRlcygnLicpICYmIGxhdFN0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAyKSB8fFxuICAgICAgICAgICAgKGxuZ1N0ci5pbmNsdWRlcygnLicpICYmIGxuZ1N0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAyKSB8fFxuICAgICAgICAgICAgbGF0U3RyID09PSBsbmdTdHIgfHwgLy8gU2FtZSBsYXQvbG5nIGlzIHN1c3BpY2lvdXNcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fCBcbiAgICAgICAgICAgIGxuZ1N0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fFxuICAgICAgICAgICAgbGF0U3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy4wJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjUnKSB8fCBcbiAgICAgICAgICAgIGxuZ1N0ci5lbmRzV2l0aCgnLjUnKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLmxlbmd0aCxcbiAgICAgICAgZHVwbGljYXRlTmFtZXM6IGZpbmREdXBsaWNhdGVzKHByb3BlcnRpZXMsICduYW1lJyksXG4gICAgICAgIGR1cGxpY2F0ZUFkZHJlc3NlczogZmluZER1cGxpY2F0ZXMocHJvcGVydGllcywgJ2FkZHJlc3MnKSxcbiAgICAgICAgdGVzdFByb3BlcnRpZXM6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gXG4gICAgICAgICAgKHAubmFtZSAmJiBwLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICAocC5uYW1lICYmIHAubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdleGFtcGxlJykpIHx8XG4gICAgICAgICAgKHAuYWRkcmVzcyAmJiBwLmFkZHJlc3MudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICBwLl9pc190ZXN0X3Byb3BlcnR5XG4gICAgICAgICkubGVuZ3RoXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbElzc3VlcyA9IGRhdGFJc3N1ZXMubWlzc2luZ05hbWVzICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3NlcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLnN1c3BpY2lvdXNaZXJvcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLnN1c3BpY2lvdXNDb29yZGluYXRlcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLmR1cGxpY2F0ZU5hbWVzLmxlbmd0aCArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLmR1cGxpY2F0ZUFkZHJlc3Nlcy5sZW5ndGggKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllcztcbiAgICAgIFxuICAgICAgLy8gTm8gaXNzdWVzIGZvdW5kXG4gICAgICBpZiAodG90YWxJc3N1ZXMgPT09IDApIHtcbiAgICAgICAgYWxlcnQoJ05vIGRhdGEgaXNzdWVzIGZvdW5kIHRoYXQgbmVlZCBjbGVhbmluZycpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb25maXJtIHdpdGggdXNlclxuICAgICAgY29uc3QgY29uZmlybWF0aW9uID0gY29uZmlybShcbiAgICAgICAgYEZvdW5kICR7dG90YWxJc3N1ZXN9IGRhdGEgcXVhbGl0eSBpc3N1ZXM6XFxuXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5taXNzaW5nTmFtZXN9IHByb3BlcnRpZXMgbWlzc2luZyBuYW1lc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3Nlc30gcHJvcGVydGllcyB3aXRoIGluY29tcGxldGUgYWRkcmVzc2VzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzWmVyb3N9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXN9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIGNvb3JkaW5hdGVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGh9IGR1cGxpY2F0ZSBwcm9wZXJ0eSBuYW1lc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMuZHVwbGljYXRlQWRkcmVzc2VzLmxlbmd0aH0gZHVwbGljYXRlIGFkZHJlc3Nlc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMudGVzdFByb3BlcnRpZXN9IHBvdGVudGlhbCB0ZXN0L2V4YW1wbGUgcHJvcGVydGllc1xcblxcbmAgK1xuICAgICAgICBgV291bGQgeW91IGxpa2UgdG8gY2xlYW4gdGhlc2UgaXNzdWVzP2BcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmICghY29uZmlybWF0aW9uKSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9wdGlvbmFsOiBvZmZlciBhZHZhbmNlZCBvcHRpb25zXG4gICAgICBjb25zdCBhZHZhbmNlZE9wdGlvbnMgPSBjb25maXJtKFxuICAgICAgICBcIldvdWxkIHlvdSBsaWtlIHRvIHVzZSBhZHZhbmNlZCBjbGVhbmluZyBvcHRpb25zP1xcblxcblwiICtcbiAgICAgICAgXCItIEZpeCBtaXNzaW5nIG5hbWVzIGFuZCBleHRyYWN0IGNpdHkvc3RhdGUgZnJvbSBhZGRyZXNzZXNcXG5cIiArXG4gICAgICAgIFwiLSBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcblwiICtcbiAgICAgICAgXCItIElkZW50aWZ5IGFuZCBmbGFnIGR1cGxpY2F0ZSBwcm9wZXJ0aWVzXFxuXCIgK1xuICAgICAgICBcIi0gRmxhZyB0ZXN0IHByb3BlcnRpZXMgZm9yIGZpbHRlcmluZ1xcblxcblwiICtcbiAgICAgICAgXCJTZWxlY3QgJ0NhbmNlbCcgZm9yIGJhc2ljIGNsZWFuaW5nIG9ubHkuXCJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGZpeGVzIHRvIGEgY29weSBvZiB0aGUgcHJvcGVydGllc1xuICAgICAgY29uc3QgY2xlYW5lZFByb3BlcnRpZXMgPSBbLi4ucHJvcGVydGllc107XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHByb3BlcnR5IG5hbWVzXG4gICAgICBsZXQgaXNzdWVzQ2xlYW5lZCA9IDA7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5LCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHlDbGVhbmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjbGVhbmluZ05vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaXggbWlzc2luZyBuYW1lcyB1c2luZyBhZGRyZXNzXG4gICAgICAgIGlmICghcHJvcGVydHkubmFtZSB8fCBwcm9wZXJ0eS5uYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkuYWRkcmVzcykge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWUgPSBgUHJvcGVydHkgYXQgJHtwcm9wZXJ0eS5hZGRyZXNzLnNwbGl0KCcsJylbMF19YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWUgPSBgVW5uYW1lZCBQcm9wZXJ0eSAke3Byb3BlcnR5LmlkLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BlcnR5Q2xlYW5lZCA9IHRydWU7XG4gICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdNaXNzaW5nIG5hbWUgZml4ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRml4IG1pc3NpbmcgY2l0eS9zdGF0ZSBpZiBhZGRyZXNzIGV4aXN0c1xuICAgICAgICBpZiAocHJvcGVydHkuYWRkcmVzcyAmJiAoIXByb3BlcnR5LmNpdHkgfHwgIXByb3BlcnR5LnN0YXRlKSkge1xuICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IGNpdHkgYW5kIHN0YXRlIGZyb20gYWRkcmVzc1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NQYXJ0cyA9IHByb3BlcnR5LmFkZHJlc3Muc3BsaXQoJywnKS5tYXAocCA9PiBwLnRyaW0oKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGFkZHJlc3NQYXJ0cy5sZW5ndGggPj0gMiAmJiAhcHJvcGVydHkuY2l0eSkge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLmNpdHkgPSBhZGRyZXNzUGFydHNbYWRkcmVzc1BhcnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnQ2l0eSBleHRyYWN0ZWQgZnJvbSBhZGRyZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhZGRyZXNzUGFydHMubGVuZ3RoID49IDEgJiYgIXByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBzdGF0ZSBmcm9tIHRoZSBsYXN0IHBhcnQgb2YgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlUGFydCA9IGFkZHJlc3NQYXJ0c1thZGRyZXNzUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU1hdGNoID0gc3RhdGVQYXJ0Lm1hdGNoKC9bQS1aXXsyfS8pO1xuICAgICAgICAgICAgaWYgKHN0YXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLnN0YXRlID0gc3RhdGVNYXRjaFswXTtcbiAgICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdTdGF0ZSBleHRyYWN0ZWQgZnJvbSBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGFkdmFuY2VkIGNsZWFuaW5nXG4gICAgICAgIGlmIChhZHZhbmNlZE9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocHJvcGVydHkubGF0aXR1ZGUgfHwgJycpO1xuICAgICAgICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwcm9wZXJ0eS5sb25naXR1ZGUgfHwgJycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zIGluIGNvb3JkaW5hdGVzXG4gICAgICAgICAgY29uc3QgaGFzTG93UHJlY2lzaW9uID0gXG4gICAgICAgICAgICAobGF0U3RyLmluY2x1ZGVzKCcuJykgJiYgbGF0U3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpIHx8XG4gICAgICAgICAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaGFzU3VzcGljaW91c1BhdHRlcm4gPSBcbiAgICAgICAgICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IC8vIFNhbWUgbGF0L2xuZyBpcyB2ZXJ5IHVubGlrZWx5XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjAnKSB8fFxuICAgICAgICAgICAgbG5nU3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJy41JykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy41Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzTG93UHJlY2lzaW9uIHx8IGhhc1N1c3BpY2lvdXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2lzX2dyaWRfcGF0dGVybiA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX25lZWRzX2dlb2NvZGluZyA9IHRydWU7XG4gICAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdGbGFnZ2VkIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmxhZyB0ZXN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKChwcm9wZXJ0eS5uYW1lICYmIHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICAgIChwcm9wZXJ0eS5uYW1lICYmIHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZXhhbXBsZScpKSB8fFxuICAgICAgICAgICAgKHByb3BlcnR5LmFkZHJlc3MgJiYgcHJvcGVydHkuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0ZXN0JykpKSB7XG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9pc190ZXN0X3Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnRmxhZ2dlZCBhcyB0ZXN0IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZsYWcgc3VzcGljaW91cyB6ZXJvcyBmb3IgYWR2YW5jZWQgY2xlYW5pbmdcbiAgICAgICAgaWYgKGFkdmFuY2VkT3B0aW9ucyAmJiAocHJvcGVydHkucHJpY2UgPT09IDAgfHwgcHJvcGVydHkudW5pdHMgPT09IDAgfHwgcHJvcGVydHkubnVtX3VuaXRzID09PSAwKSkge1xuICAgICAgICAgIC8vIFdlJ2xsIGp1c3QgZmxhZyB0aGVzZSBmb3Igbm93LCBtYW51YWwgcmV2aWV3IGlzIG5lZWRlZFxuICAgICAgICAgIGlmICghY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfcXVhbGl0eV9pc3N1ZXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHByb3BlcnR5LnByaWNlID09PSAwKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfcXVhbGl0eV9pc3N1ZXMucHVzaCgnemVyb19wcmljZScpO1xuICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnRmxhZ2dlZCB6ZXJvIHByaWNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9wZXJ0eS51bml0cyA9PT0gMCB8fCBwcm9wZXJ0eS5udW1fdW5pdHMgPT09IDApIHtcbiAgICAgICAgICAgIGNsZWFuZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3Vlcy5wdXNoKCd6ZXJvX3VuaXRzJyk7XG4gICAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdGbGFnZ2VkIHplcm8gdW5pdHMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9wZXJ0eSB3aXRoIGNsZWFuaW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChwcm9wZXJ0eUNsZWFuZWQpIHtcbiAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfY2xlYW5lZCA9IHRydWU7XG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9jbGVhbmluZ19ub3RlcyA9IGNsZWFuaW5nTm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICBpc3N1ZXNDbGVhbmVkKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBjbGVhbmVkIHByb3BlcnRpZXNcbiAgICAgIHNldFByb3BlcnRpZXMoY2xlYW5lZFByb3BlcnRpZXMpO1xuICAgICAgY2FsY3VsYXRlU3RhdHMoY2xlYW5lZFByb3BlcnRpZXMpO1xuICAgICAgXG4gICAgICAvLyBBbGVydCB1c2VyIG9mIHJlc3VsdHNcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRGF0YSBjbGVhbmluZyBjb21wbGV0ZSFcXG5cXG5gICtcbiAgICAgICAgYC0gJHtpc3N1ZXNDbGVhbmVkfSBwcm9wZXJ0aWVzIHdlcmUgY2xlYW5lZFxcbmAgK1xuICAgICAgICBgLSBBZGRlZCBuYW1lcyB0byAke2RhdGFJc3N1ZXMubWlzc2luZ05hbWVzfSBwcm9wZXJ0aWVzXFxuYCArXG4gICAgICAgIGAtIEV4dHJhY3RlZCBjaXR5L3N0YXRlIGZvciAke2RhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3Nlc30gcHJvcGVydGllc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXN9IHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcbmAgK1xuICAgICAgICBgLSBJZGVudGlmaWVkICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGh9IGR1cGxpY2F0ZSBuYW1lc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllc30gdGVzdCBwcm9wZXJ0aWVzXFxuXFxuYCArXG4gICAgICAgIGBOZXh0IHN0ZXBzOlxcbmAgK1xuICAgICAgICBgMS4gVXNlIFwiQmF0Y2ggR2VvY29kZVwiIHRvIGZpeCBmbGFnZ2VkIGNvb3JkaW5hdGVzXFxuYCArXG4gICAgICAgIGAyLiBVc2UgXCJQcm9wZXJ0aWVzIEFuYWx5c2lzXCIgdG8gcmV2aWV3IGRhdGEgcXVhbGl0eVxcbmAgK1xuICAgICAgICBgMy4gU29tZSBwcm9wZXJ0aWVzIHN0aWxsIHJlcXVpcmUgbWFudWFsIHJldmlld2BcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFuaW5nIHByb3BlcnR5IGRhdGE6JywgZXJyb3IpO1xuICAgICAgYWxlcnQoYEVycm9yIGNsZWFuaW5nIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBkdXBsaWNhdGVzIGluIHByb3BlcnRpZXMgYnkgZmllbGRcbiAgZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoYXJyYXksIGtleSkge1xuICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBbXTtcbiAgICBcbiAgICAvLyBTa2lwIGVudHJpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcbiAgICBhcnJheS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW1ba2V5XSAmJiBpdGVtW2tleV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgY291bnRzW3ZhbHVlXSA9IChjb3VudHNbdmFsdWVdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBGaW5kIHZhbHVlcyB0aGF0IGFwcGVhciBtb3JlIHRoYW4gb25jZVxuICAgIE9iamVjdC5rZXlzKGNvdW50cykuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoY291bnRzW3ZhbHVlXSA+IDEpIHtcbiAgICAgICAgZHVwbGljYXRlcy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjb3VudDogY291bnRzW3ZhbHVlXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZHVwbGljYXRlcztcbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGVucmljaCBwcm9wZXJ0eSBkYXRhIHdpdGggemVybyB2YWx1ZXNcbiAgYXN5bmMgZnVuY3Rpb24gZW5yaWNoUHJvcGVydHlEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBJZGVudGlmeSBwcm9wZXJ0aWVzIHdpdGggc3VzcGljaW91cyB6ZXJvIHZhbHVlc1xuICAgICAgY29uc3Qgc3VzcGljaW91c1Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgICAgICAocC5wcmljZSA9PT0gMCB8fCBwLnVuaXRzID09PSAwIHx8IHAubnVtX3VuaXRzID09PSAwKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKHN1c3BpY2lvdXNQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhbGVydCgnTm8gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXMgZm91bmQnKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29uZmlybSB3aXRoIHVzZXJcbiAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbiA9IGNvbmZpcm0oXG4gICAgICAgIGBGb3VuZCAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXM6XFxuXFxuYCArXG4gICAgICAgIGAtICR7c3VzcGljaW91c1Byb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5wcmljZSA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyBwcmljZVxcbmAgK1xuICAgICAgICBgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAudW5pdHMgPT09IDAgfHwgcC5udW1fdW5pdHMgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gdW5pdHNcXG5cXG5gICtcbiAgICAgICAgYFdvdWxkIHlvdSBsaWtlIHRvIGF0dGVtcHQgdG8gZW5yaWNoIHRoZXNlIHByb3BlcnRpZXM/YFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKCFjb25maXJtYXRpb24pIHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIHByb3BlcnRpZXMgZm9yIGVucmljaG1lbnRcbiAgICAgIGNvbnN0IGVucmljaGVkUHJvcGVydGllcyA9IFsuLi5wcm9wZXJ0aWVzXTtcbiAgICAgIGxldCBlbnJpY2hlZENvdW50ID0gMDtcbiAgICAgIFxuICAgICAgLy8gQW5hbHl6ZSBjb2xsZWN0aW9ucyBvZiBzaW1pbGFyIHByb3BlcnRpZXMgdG8gZGVyaXZlIGVzdGltYXRlc1xuICAgICAgLy8gR3JvdXAgcHJvcGVydGllcyBieSBjaXR5L3N0YXRlIGZvciBiZXR0ZXIgY29tcGFyaXNvblxuICAgICAgY29uc3QgY2l0eVN0YXRlR3JvdXBzID0ge307XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmIChwLmNpdHkgJiYgcC5zdGF0ZSAmJiBwLnByaWNlICYmIHAucHJpY2UgPiAwICYmIChwLnVuaXRzID4gMCB8fCBwLm51bV91bml0cyA+IDApKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cC5jaXR5LnRvTG93ZXJDYXNlKCl9LCR7cC5zdGF0ZS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgICAgaWYgKCFjaXR5U3RhdGVHcm91cHNba2V5XSkge1xuICAgICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0ucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4gdmFsdWVzIHBlciBjaXR5L3N0YXRlXG4gICAgICBjb25zdCBtZWRpYW5WYWx1ZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNpdHlTdGF0ZUdyb3VwcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGNpdHlTdGF0ZUdyb3Vwc1trZXldO1xuICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID49IDMpIHsgLy8gT25seSB1c2UgZ3JvdXBzIHdpdGggZW5vdWdoIGRhdGEgcG9pbnRzXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG1lZGlhbiBwcmljZSBwZXIgdW5pdFxuICAgICAgICAgIGNvbnN0IHByaWNlc1BlclVuaXQgPSBncm91cC5tYXAocCA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bml0cyA9IHAudW5pdHMgfHwgcC5udW1fdW5pdHMgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA+IDAgPyBwLnByaWNlIC8gdW5pdHMgOiAwO1xuICAgICAgICAgIH0pLmZpbHRlcih2ID0+IHYgPiAwKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbWVkaWFuUHJpY2VQZXJVbml0ID0gcHJpY2VzUGVyVW5pdFtNYXRoLmZsb29yKHByaWNlc1BlclVuaXQubGVuZ3RoIC8gMildO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4geWVhciBidWlsdFxuICAgICAgICAgIGNvbnN0IHllYXJCdWlsdCA9IGdyb3VwLm1hcChwID0+IHAueWVhcl9idWlsdCkuZmlsdGVyKHkgPT4geSAmJiB5ID4gMTkwMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgIGNvbnN0IG1lZGlhblllYXJCdWlsdCA9IHllYXJCdWlsdC5sZW5ndGggPiAwID8geWVhckJ1aWx0W01hdGguZmxvb3IoeWVhckJ1aWx0Lmxlbmd0aCAvIDIpXSA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgbWVkaWFuVmFsdWVzW2tleV0gPSB7XG4gICAgICAgICAgICBtZWRpYW5QcmljZVBlclVuaXQsXG4gICAgICAgICAgICBtZWRpYW5ZZWFyQnVpbHQsXG4gICAgICAgICAgICBzYW1wbGVTaXplOiBncm91cC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRW5yaWNoIHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzXG4gICAgICBzdXNwaWNpb3VzUHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBlbnJpY2hlZFByb3BlcnRpZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcHJvcGVydHkuaWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBsZXQgaXNFbnJpY2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZW5yaWNobWVudE5vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IHJlZmVyZW5jZSBncm91cCBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICBsZXQgcmVmZXJlbmNlR3JvdXAgPSBudWxsO1xuICAgICAgICBsZXQgcmVmZXJlbmNlS2V5ID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9wZXJ0eS5jaXR5ICYmIHByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cHJvcGVydHkuY2l0eS50b0xvd2VyQ2FzZSgpfSwke3Byb3BlcnR5LnN0YXRlLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgICBpZiAobWVkaWFuVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwID0gbWVkaWFuVmFsdWVzW2tleV07XG4gICAgICAgICAgICByZWZlcmVuY2VLZXkgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBubyBkaXJlY3QgY2l0eS9zdGF0ZSBtYXRjaCwgdXNlIHRoZSBjbG9zZXN0IGdlb2dyYXBoaWNhbGx5IG9yIGEgZ2VuZXJhbCBhdmVyYWdlXG4gICAgICAgIGlmICghcmVmZXJlbmNlR3JvdXApIHtcbiAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gc3RhdGUtbGV2ZWwgZGF0YSBvciBnZW5lcmFsIGF2ZXJhZ2VcbiAgICAgICAgICBpZiAocHJvcGVydHkuc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlR3JvdXBzID0gT2JqZWN0LmtleXMobWVkaWFuVmFsdWVzKS5maWx0ZXIoa2V5ID0+IFxuICAgICAgICAgICAgICBrZXkuZW5kc1dpdGgoYCwke3Byb3BlcnR5LnN0YXRlLnRvTG93ZXJDYXNlKCl9YClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzdGF0ZUdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgbGFyZ2VzdCBzYW1wbGUgZnJvbSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgcmVmZXJlbmNlS2V5ID0gc3RhdGVHcm91cHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgICAgICAgICAgbWVkaWFuVmFsdWVzW2JdLnNhbXBsZVNpemUgLSBtZWRpYW5WYWx1ZXNbYV0uc2FtcGxlU2l6ZVxuICAgICAgICAgICAgICApWzBdO1xuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cCA9IG1lZGlhblZhbHVlc1tyZWZlcmVuY2VLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJZiBzdGlsbCBubyBtYXRjaCwgdXNlIHRoZSBvdmVyYWxsIGF2ZXJhZ2VcbiAgICAgICAgICBpZiAoIXJlZmVyZW5jZUdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxQcmljZXNQZXJVbml0ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcC5wcmljZSAmJiBwLnByaWNlID4gMCAmJiAocC51bml0cyA+IDAgfHwgcC5udW1fdW5pdHMgPiAwKSlcbiAgICAgICAgICAgICAgLm1hcChwID0+IHAucHJpY2UgLyAocC51bml0cyB8fCBwLm51bV91bml0cykpXG4gICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFsbFByaWNlc1BlclVuaXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cCA9IHtcbiAgICAgICAgICAgICAgICBtZWRpYW5QcmljZVBlclVuaXQ6IGFsbFByaWNlc1BlclVuaXRbTWF0aC5mbG9vcihhbGxQcmljZXNQZXJVbml0Lmxlbmd0aCAvIDIpXSxcbiAgICAgICAgICAgICAgICBtZWRpYW5ZZWFyQnVpbHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZTogYWxsUHJpY2VzUGVyVW5pdC5sZW5ndGhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVmZXJlbmNlS2V5ID0gXCJhbGxfcHJvcGVydGllc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1pc3NpbmcgdmFsdWVzXG4gICAgICAgIGlmIChyZWZlcmVuY2VHcm91cCkge1xuICAgICAgICAgIC8vIEZpeCB6ZXJvIHByaWNlIGlmIHVuaXRzIGFyZSBhdmFpbGFibGVcbiAgICAgICAgICBpZiAocHJvcGVydHkucHJpY2UgPT09IDAgJiYgKHByb3BlcnR5LnVuaXRzID4gMCB8fCBwcm9wZXJ0eS5udW1fdW5pdHMgPiAwKSkge1xuICAgICAgICAgICAgY29uc3QgdW5pdHMgPSBwcm9wZXJ0eS51bml0cyB8fCBwcm9wZXJ0eS5udW1fdW5pdHM7XG4gICAgICAgICAgICBlbnJpY2hlZFByb3BlcnRpZXNbaW5kZXhdLnByaWNlID0gTWF0aC5yb3VuZChyZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQgKiB1bml0cyk7XG4gICAgICAgICAgICBpc0VucmljaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVucmljaG1lbnROb3Rlcy5wdXNoKGBFc3RpbWF0ZWQgcHJpY2UgYmFzZWQgb24gJHtyZWZlcmVuY2VLZXl9IG1lZGlhbiAoJCR7TWF0aC5yb3VuZChyZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQpLnRvTG9jYWxlU3RyaW5nKCl9L3VuaXQpYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpeCB6ZXJvIHVuaXRzIGlmIHByaWNlIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIGlmICgocHJvcGVydHkudW5pdHMgPT09IDAgfHwgIXByb3BlcnR5LnVuaXRzKSAmJiBcbiAgICAgICAgICAgICAgKHByb3BlcnR5Lm51bV91bml0cyA9PT0gMCB8fCAhcHJvcGVydHkubnVtX3VuaXRzKSAmJiBcbiAgICAgICAgICAgICAgcHJvcGVydHkucHJpY2UgPiAwICYmIFxuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRVbml0cyA9IE1hdGgucm91bmQocHJvcGVydHkucHJpY2UgLyByZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQpO1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS51bml0cyA9IGVzdGltYXRlZFVuaXRzO1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5udW1fdW5pdHMgPSBlc3RpbWF0ZWRVbml0cztcbiAgICAgICAgICAgIGlzRW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5yaWNobWVudE5vdGVzLnB1c2goYEVzdGltYXRlZCAke2VzdGltYXRlZFVuaXRzfSB1bml0cyBiYXNlZCBvbiBwcmljZSBhbmQgJHtyZWZlcmVuY2VLZXl9IG1lZGlhbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgbWlzc2luZyB5ZWFyIGJ1aWx0IGlmIHdlIGhhdmUgYSByZWZlcmVuY2VcbiAgICAgICAgICBpZiAoKCFwcm9wZXJ0eS55ZWFyX2J1aWx0IHx8IHByb3BlcnR5LnllYXJfYnVpbHQgPCAxOTAwKSAmJiByZWZlcmVuY2VHcm91cC5tZWRpYW5ZZWFyQnVpbHQpIHtcbiAgICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0ueWVhcl9idWlsdCA9IHJlZmVyZW5jZUdyb3VwLm1lZGlhblllYXJCdWlsdDtcbiAgICAgICAgICAgIGlzRW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5yaWNobWVudE5vdGVzLnB1c2goYEVzdGltYXRlZCB5ZWFyIGJ1aWx0IGFzICR7cmVmZXJlbmNlR3JvdXAubWVkaWFuWWVhckJ1aWx0fSBiYXNlZCBvbiAke3JlZmVyZW5jZUtleX0gbWVkaWFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHByb3BlcnR5IGFzIG5lZWRpbmcgaHVtYW4gcmV2aWV3IGlmIHdlIGNvdWxkbid0IGVucmljaCBpdFxuICAgICAgICBpZiAoIWlzRW5yaWNoZWQpIHtcbiAgICAgICAgICAvLyBNYXJrIGFzIG5lZWRpbmcgbWFudWFsIHJldmlld1xuICAgICAgICAgIGlmICghZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3Vlcykge1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3VlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnJpY2hlZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzLnB1c2goJ25lZWRzX21hbnVhbF9yZXZpZXcnKTtcbiAgICAgICAgICBpc0VucmljaGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbnJpY2htZW50Tm90ZXMucHVzaCgnTWFya2VkIGZvciBtYW51YWwgcmV2aWV3IC0gaW5zdWZmaWNpZW50IGRhdGEgdG8gbWFrZSBlc3RpbWF0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb3BlcnR5IHdpdGggZW5yaWNobWVudCBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoaXNFbnJpY2hlZCkge1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfZW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2VucmljaG1lbnRfbm90ZXMgPSBlbnJpY2htZW50Tm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICBlbnJpY2hlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBlbnJpY2hlZCBwcm9wZXJ0aWVzXG4gICAgICBzZXRQcm9wZXJ0aWVzKGVucmljaGVkUHJvcGVydGllcyk7XG4gICAgICBjYWxjdWxhdGVTdGF0cyhlbnJpY2hlZFByb3BlcnRpZXMpO1xuICAgICAgXG4gICAgICAvLyBBbGVydCB1c2VyIG9mIHJlc3VsdHNcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRGF0YSBlbnJpY2htZW50IGNvbXBsZXRlIVxcblxcbmAgK1xuICAgICAgICBgLSAke2VucmljaGVkQ291bnR9IHByb3BlcnRpZXMgd2VyZSBlbnJpY2hlZCBvciBtYXJrZWQgZm9yIHJldmlld1xcbmAgK1xuICAgICAgICBgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAucHJpY2UgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gcHJpY2UgcHJvY2Vzc2VkXFxuYCArXG4gICAgICAgIGAtICR7c3VzcGljaW91c1Byb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC51bml0cyA9PT0gMCB8fCBwLm51bV91bml0cyA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyB1bml0cyBwcm9jZXNzZWRcXG5cXG5gICtcbiAgICAgICAgYE5leHQgc3RlcHM6XFxuYCArXG4gICAgICAgIGAxLiBSZXZpZXcgdGhlIGVucmljaGVkIGRhdGEgZm9yIGFjY3VyYWN5XFxuYCArXG4gICAgICAgIGAyLiBQcm9wZXJ0aWVzIG1hcmtlZCBmb3IgbWFudWFsIHJldmlldyBuZWVkIGh1bWFuIGF0dGVudGlvblxcbmAgK1xuICAgICAgICBgMy4gVXNlIFwiUHJvcGVydGllcyBBbmFseXNpc1wiIHRvIHZlcmlmeSBkYXRhIHF1YWxpdHlgXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJpY2hpbmcgcHJvcGVydHkgZGF0YTonLCBlcnJvcik7XG4gICAgICBhbGVydChgRXJyb3IgZW5yaWNoaW5nIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbG9nIGVudHJ5IHdpdGggdGltZXN0YW1wXG4gIGNvbnN0IGFkZEdlb2NvZGluZ0xvZyA9IHVzZUNhbGxiYWNrKChtZXNzYWdlLCB0eXBlID0gJ2luZm8nKSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKHByZXZMb2dzID0+IFtcbiAgICAgIHsgbWVzc2FnZSwgdGltZXN0YW1wLCB0eXBlIH0sXG4gICAgICAuLi5wcmV2TG9ncy5zbGljZSgwLCA5OSkgLy8gS2VlcCBvbmx5IHRoZSBsYXN0IDEwMCBsb2dzXG4gICAgXSk7XG4gIH0sIFtdKTtcblxuICAvLyBDbGVhciBsb2dzIHdoZW4gc3RhcnRpbmcgbmV3IGdlb2NvZGluZyBwcm9jZXNzXG4gIGNvbnN0IGNsZWFyR2VvY29kaW5nTG9ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKFtdKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPExheW91dCB0aXRsZT1cIlByb3BlcnR5IE1hcCB8IEF1c3RpbiBNdWx0aWZhbWlseVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTRcIj5cbiAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkXCI+XG4gICAgICAgICAgICBQcm9wZXJ0eSBNYXAge2xvYWRpbmcgPyAnKExvYWRpbmcuLi4pJyA6IGAoJHtwcm9wZXJ0aWVzLmxlbmd0aH0gcHJvcGVydGllcyBzaG93bilgfVxuICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cbiAgICAgICAgICAgIHtsb2FkaW5nID8gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTUwMFwiPkxvYWRpbmcgcHJvcGVydGllcy4uLjwvZGl2PlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gYmctd2hpdGUgc2hhZG93LXNtIGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZCBweC0zIHB5LTFcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtXCI+e3RvdGFsRmV0Y2hlZH08L3NwYW4+IHByb3BlcnRpZXMgZmV0Y2hlZFxuICAgICAgICAgICAgICAgICAge3Byb3BlcnRpZXMubGVuZ3RoICE9PSB0b3RhbEZldGNoZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwIG1sLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAoe3RvdGFsRmV0Y2hlZCAtIHByb3BlcnRpZXMubGVuZ3RofSBmaWx0ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBiZy1ibHVlLTEwMCBob3ZlcjpiZy1ibHVlLTIwMCB0ZXh0LWJsdWUtNzAwIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17cnVuUHJvcGVydHlBbmFseXNpc31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBQcm9wZXJ0aWVzIEFuYWx5c2lzXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtc20gcm91bmRlZCBweC0zIHB5LTEgdHJhbnNpdGlvbiAke1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RpbmcgXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTUwMCBjdXJzb3Itbm90LWFsbG93ZWQnIFxuICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWluZGlnby0xMDAgaG92ZXI6YmctaW5kaWdvLTIwMCB0ZXh0LWluZGlnby03MDAnXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2JhdGNoR2VvY29kZVByb3BlcnRpZXN9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Z2VvY29kaW5nfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtnZW9jb2RpbmcgPyAnR2VvY29kaW5nLi4uJyA6ICdCYXRjaCBHZW9jb2RlJ31cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1zbSByb3VuZGVkIHB4LTMgcHktMSB0cmFuc2l0aW9uICR7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTUwMCBjdXJzb3Itbm90LWFsbG93ZWQnIFxuICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWFtYmVyLTEwMCBob3ZlcjpiZy1hbWJlci0yMDAgdGV4dC1hbWJlci03MDAnXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2NsZWFuUHJvcGVydHlEYXRhfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgQ2xlYW4gRGF0YVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B0ZXh0LXNtIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb24gJHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyBcbiAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ncmF5LTEwMCB0ZXh0LWdyYXktNTAwIGN1cnNvci1ub3QtYWxsb3dlZCcgXG4gICAgICAgICAgICAgICAgICAgICAgOiAnYmctcHVycGxlLTEwMCBob3ZlcjpiZy1wdXJwbGUtMjAwIHRleHQtcHVycGxlLTcwMCdcbiAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZW5yaWNoUHJvcGVydHlEYXRhfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgRW5yaWNoIERhdGFcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBiZy1ncmVlbi0xMDAgaG92ZXI6YmctZ3JlZW4tMjAwIHRleHQtZ3JlZW4tNzAwIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gbG9hZFByb3BlcnRpZXMoKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBSZWZyZXNoIE1hcFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLVs4MHZoXVwiPlxuICAgICAgICAgIDxNYXBDb21wb25lbnQgXG4gICAgICAgICAgICBwcm9wZXJ0aWVzPXtwcm9wZXJ0aWVzfSBcbiAgICAgICAgICAgIHNlbGVjdGVkUHJvcGVydHk9e3NlbGVjdGVkUHJvcGVydHl9XG4gICAgICAgICAgICBzZXRTZWxlY3RlZFByb3BlcnR5PXtzZXRTZWxlY3RlZFByb3BlcnR5fVxuICAgICAgICAgICAgb25Cb3VuZHNDaGFuZ2U9e2hhbmRsZUJvdW5kc0NoYW5nZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvTGF5b3V0PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZHluYW1pYyIsIkxheW91dCIsImZldGNoUHJvcGVydGllcyIsImVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMiLCJNYXBDb21wb25lbnQiLCJzc3IiLCJNYXBQYWdlIiwicHJvcGVydGllcyIsInNldFByb3BlcnRpZXMiLCJzZWxlY3RlZFByb3BlcnR5Iiwic2V0U2VsZWN0ZWRQcm9wZXJ0eSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZ2VvY29kaW5nIiwic2V0R2VvY29kaW5nIiwiZ2VvY29kaW5nTG9ncyIsInNldEdlb2NvZGluZ0xvZ3MiLCJzaG93R2VvY29kaW5nTG9ncyIsInNldFNob3dHZW9jb2RpbmdMb2dzIiwibWFwQm91bmRzIiwic2V0TWFwQm91bmRzIiwidG90YWxGZXRjaGVkIiwic2V0VG90YWxGZXRjaGVkIiwiZGF0YVN0YXRzIiwic2V0RGF0YVN0YXRzIiwidG90YWxQcm9wZXJ0aWVzIiwiaW52YWxpZENvb3JkaW5hdGVzIiwibWlzc2luZ0Nvb3JkaW5hdGVzIiwiemVyb0Nvb3JkaW5hdGVzIiwiaW52YWxpZFJhbmdlIiwiZHVwbGljYXRlZExvY2F0aW9ucyIsImxvYWRQcm9wZXJ0aWVzIiwiY29uc29sZSIsImxvZyIsImhhbmRsZUJvdW5kc0NoYW5nZSIsImJvdW5kcyIsImNhbGN1bGF0ZVN0YXRzIiwicHJvcERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJtaXNzaW5nQ29vcmRzIiwiZmlsdGVyIiwicCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwibGVuZ3RoIiwiemVyb0Nvb3JkcyIsImxhdCIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJsbmciLCJpc05hTiIsImNvb3JkTWFwIiwiTWFwIiwiZHVwbGljYXRlZENvb3JkcyIsImZvckVhY2giLCJjb29yZEtleSIsImhhcyIsInNldCIsImdldCIsInVuaXF1ZUxvY2F0aW9ucyIsInNpemUiLCJvcHRpb25zIiwic29ydEJ5Iiwic29ydEFzYyIsInBhZ2UiLCJwYWdlU2l6ZSIsImZpbHRlcnMiLCJpbmNsdWRlSW5jb21wbGV0ZSIsImluY2x1ZGVSZXNlYXJjaCIsIm5vTGltaXQiLCJkYXRhIiwidmFsaWRDb29yZHMiLCJhdXN0aW5Db29yZHMiLCJzdXNwaWNpb3VzQ29vcmRzIiwibGF0U3RyIiwibG5nU3RyIiwiaGFzTG93UHJlY2lzaW9uIiwiaW5jbHVkZXMiLCJzcGxpdCIsImhhc1N1c3BpY2lvdXNQYXR0ZXJuIiwiZW5kc1dpdGgiLCJlcnJvciIsImJhdGNoR2VvY29kZVByb3BlcnRpZXMiLCJjbGVhckdlb2NvZGluZ0xvZ3MiLCJwcm9wc1RvR2VvY29kZSIsIl9jb29yZGluYXRlc19taXNzaW5nIiwiX25lZWRzX2dlb2NvZGluZyIsIl9pc19ncmlkX3BhdHRlcm4iLCJhZGRHZW9jb2RpbmdMb2ciLCJhbGVydCIsImNvbmZpcm0iLCJiYXRjaFNpemUiLCJiYXRjaGVzIiwiTWF0aCIsImNlaWwiLCJzdWNjZXNzQ291bnQiLCJmYWlsQ291bnQiLCJpIiwic3RhcnQiLCJlbmQiLCJtaW4iLCJiYXRjaCIsInNsaWNlIiwicHJvcGVydHkiLCJpZHgiLCJwcm9wZXJ0eU5hbWUiLCJuYW1lIiwiaWQiLCJnZW9jb2RlZEJhdGNoIiwic3RhdHVzIiwiZGV0YWlscyIsImJhdGNoU3VjY2VzcyIsIl9nZW9jb2RlZCIsImJhdGNoRmFpbCIsIl9nZW9jb2RpbmdfZmFpbGVkIiwidXBkYXRlZFByb3BlcnRpZXMiLCJnZW9jb2RlZFByb3AiLCJpbmRleCIsImZpbmRJbmRleCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm1lc3NhZ2UiLCJydW5Qcm9wZXJ0eUFuYWx5c2lzIiwibXVsdGlwbGVQcm9wc0xvY2F0aW9ucyIsImZyb20iLCJlbnRyaWVzIiwiXyIsImNvdW50Iiwic29ydCIsImEiLCJiIiwibXVsdGlwbGVQcm9wc0NvdW50IiwicmVkdWNlIiwic3VtIiwiYnlTb3VyY2UiLCJleGlzdGluZyIsIl9nZW9jb2Rpbmdfc291cmNlIiwidmVyaWZpZWRfYWRkcmVzcyIsImZ1bGxfYWRkcmVzcyIsInByb3BlcnR5X25hbWUiLCJ1bmtub3duIiwibWFwIiwiY29vcmRzIiwiam9pbiIsImNsZWFuUHJvcGVydHlEYXRhIiwiZGF0YUlzc3VlcyIsIm1pc3NpbmdOYW1lcyIsInRyaW0iLCJpbmNvbXBsZXRlQWRkcmVzc2VzIiwiYWRkcmVzcyIsImNpdHkiLCJzdGF0ZSIsInN1c3BpY2lvdXNaZXJvcyIsInByaWNlIiwidW5pdHMiLCJudW1fdW5pdHMiLCJzdXNwaWNpb3VzQ29vcmRpbmF0ZXMiLCJkdXBsaWNhdGVOYW1lcyIsImZpbmREdXBsaWNhdGVzIiwiZHVwbGljYXRlQWRkcmVzc2VzIiwidGVzdFByb3BlcnRpZXMiLCJ0b0xvd2VyQ2FzZSIsIl9pc190ZXN0X3Byb3BlcnR5IiwidG90YWxJc3N1ZXMiLCJjb25maXJtYXRpb24iLCJhZHZhbmNlZE9wdGlvbnMiLCJjbGVhbmVkUHJvcGVydGllcyIsImlzc3Vlc0NsZWFuZWQiLCJwcm9wZXJ0eUNsZWFuZWQiLCJjbGVhbmluZ05vdGVzIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJwdXNoIiwiYWRkcmVzc1BhcnRzIiwic3RhdGVQYXJ0Iiwic3RhdGVNYXRjaCIsIm1hdGNoIiwiX2RhdGFfcXVhbGl0eV9pc3N1ZXMiLCJfZGF0YV9jbGVhbmVkIiwiX2NsZWFuaW5nX25vdGVzIiwiYXJyYXkiLCJrZXkiLCJjb3VudHMiLCJkdXBsaWNhdGVzIiwiaXRlbSIsInZhbHVlIiwiT2JqZWN0Iiwia2V5cyIsImVucmljaFByb3BlcnR5RGF0YSIsInN1c3BpY2lvdXNQcm9wZXJ0aWVzIiwiZW5yaWNoZWRQcm9wZXJ0aWVzIiwiZW5yaWNoZWRDb3VudCIsImNpdHlTdGF0ZUdyb3VwcyIsIm1lZGlhblZhbHVlcyIsImdyb3VwIiwicHJpY2VzUGVyVW5pdCIsInYiLCJtZWRpYW5QcmljZVBlclVuaXQiLCJmbG9vciIsInllYXJCdWlsdCIsInllYXJfYnVpbHQiLCJ5IiwibWVkaWFuWWVhckJ1aWx0Iiwic2FtcGxlU2l6ZSIsImlzRW5yaWNoZWQiLCJlbnJpY2htZW50Tm90ZXMiLCJyZWZlcmVuY2VHcm91cCIsInJlZmVyZW5jZUtleSIsInN0YXRlR3JvdXBzIiwiYWxsUHJpY2VzUGVyVW5pdCIsInJvdW5kIiwidG9Mb2NhbGVTdHJpbmciLCJlc3RpbWF0ZWRVbml0cyIsIl9kYXRhX2VucmljaGVkIiwiX2VucmljaG1lbnRfbm90ZXMiLCJ0eXBlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvTG9jYWxlVGltZVN0cmluZyIsInByZXZMb2dzIiwidGl0bGUiLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsInNwYW4iLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJvbkJvdW5kc0NoYW5nZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/map.js\n"));

/***/ })

});
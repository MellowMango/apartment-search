"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./lib/supabase.js":
/*!*************************!*\
  !*** ./lib/supabase.js ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTestProperty: function() { return /* binding */ createTestProperty; },\n/* harmony export */   fetchProperties: function() { return /* binding */ fetchProperties; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   signIn: function() { return /* binding */ signIn; },\n/* harmony export */   signOut: function() { return /* binding */ signOut; },\n/* harmony export */   signUp: function() { return /* binding */ signUp; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/**\n * Supabase client for frontend operations\n */ \n// Get Supabase credentials from environment variables\nconst supabaseUrl = \"https://your-project-id.supabase.co\";\nconst supabaseAnonKey = \"your-anon-key\";\nif (!supabaseUrl || !supabaseAnonKey) {\n    console.error(\"Supabase credentials not found. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY environment variables.\");\n}\n// Create Supabase client\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true\n    }\n});\n/**\n * Get the current authenticated user\n * @returns {Promise<Object|null>} The user object or null if not authenticated\n */ const getCurrentUser = async ()=>{\n    const { data: { user } } = await supabase.auth.getUser();\n    return user;\n};\n/**\n * Sign up a new user\n * @param {string} email - User's email\n * @param {string} password - User's password\n * @returns {Promise<Object>} The result of the sign up operation\n */ const signUp = async (email, password)=>{\n    return await supabase.auth.signUp({\n        email,\n        password\n    });\n};\n/**\n * Sign in a user\n * @param {string} email - User's email\n * @param {string} password - User's password\n * @returns {Promise<Object>} The result of the sign in operation\n */ const signIn = async (email, password)=>{\n    return await supabase.auth.signInWithPassword({\n        email,\n        password\n    });\n};\n/**\n * Sign out the current user\n * @returns {Promise<Object>} The result of the sign out operation\n */ const signOut = async ()=>{\n    return await supabase.auth.signOut();\n};\n/**\n * Fetch properties from Supabase with enhanced error handling and data normalization\n * \n * @param {Object} options - Query options\n * @param {Object} options.filters - Key-value pairs for filtering (e.g. {status: 'For Sale'})\n * @param {number} options.page - Page number for pagination\n * @param {number} options.pageSize - Number of items per page\n * @param {string} options.sortBy - Field to sort by\n * @param {boolean} options.sortAsc - Sort in ascending order if true\n * @param {boolean} options.includeIncomplete - Whether to include properties with missing coordinates\n * @param {boolean} options.includeResearch - Whether to include enriched research data\n * @returns {Promise<Array>} Array of normalized properties\n */ const fetchProperties = async function() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    // Check if we should join with research data\n    if (options.includeResearch !== false) {\n        // Include research data in our query - we'll join with property_research table\n        try {\n            // Start with a query that joins properties with research data\n            let query = supabase.from(\"properties\").select(\"\\n          *,\\n          property_research:property_research(*)\\n        \");\n            // Apply filters if provided\n            if (options.filters) {\n                Object.entries(options.filters).forEach((param)=>{\n                    let [key, value] = param;\n                    if (value !== undefined && value !== null && value !== \"\") {\n                        // Handle special filter syntax\n                        if (key === \"or\") {\n                            query = query.or(value);\n                        } else if (key.endsWith(\"_gte\")) {\n                            const actualKey = key.replace(\"_gte\", \"\");\n                            query = query.gte(actualKey, value);\n                        } else if (key.endsWith(\"_lte\")) {\n                            const actualKey = key.replace(\"_lte\", \"\");\n                            query = query.lte(actualKey, value);\n                        } else if (key.endsWith(\"_gt\")) {\n                            const actualKey = key.replace(\"_gt\", \"\");\n                            query = query.gt(actualKey, value);\n                        } else if (key.endsWith(\"_lt\")) {\n                            const actualKey = key.replace(\"_lt\", \"\");\n                            query = query.lt(actualKey, value);\n                        } else if (key.endsWith(\"_ilike\")) {\n                            const actualKey = key.replace(\"_ilike\", \"\");\n                            query = query.ilike(actualKey, value);\n                        } else {\n                            // Default to equality matching\n                            query = query.eq(key, value);\n                        }\n                    }\n                });\n            }\n            // If we need complete properties with coordinates for the map\n            if (!options.includeIncomplete) {\n                // Use a more precise filter to avoid empty/zero coordinates\n                // First prioritize properties with valid coordinates (either direct or from research)\n                query = query.not(\"latitude\", \"is\", null).not(\"longitude\", \"is\", null).not(\"latitude\", \"eq\", 0).not(\"longitude\", \"eq\", 0).order(\"created_at\", {\n                    ascending: false\n                });\n                console.log(\"Querying for properties with valid coordinates only\");\n            } else {\n                console.log(\"Including all properties regardless of coordinates\");\n            }\n            // Apply pagination\n            if (options.page && options.pageSize) {\n                const start = (options.page - 1) * options.pageSize;\n                const end = start + options.pageSize - 1;\n                query = query.range(start, end);\n            }\n            // Apply sorting\n            if (options.sortBy) {\n                query = query.order(options.sortBy, {\n                    ascending: options.sortAsc !== false\n                });\n            }\n            // Execute query\n            const { data, error } = await query;\n            if (error) {\n                // If this fails, we'll fall back to the non-join query\n                console.warn(\"Error fetching properties with research join:\", error);\n            // Continue to fallback query below\n            } else if (data && data.length > 0) {\n                console.log(\"Found \".concat(data.length, \" properties with research data\"));\n                // Merge research data with property data\n                const normalizedProperties = data.map((property)=>{\n                    // Extract research data if available\n                    const researchData = property.property_research && property.property_research.length > 0 ? property.property_research[0] : null;\n                    // Delete the nested property_research to avoid confusion\n                    delete property.property_research;\n                    // Normalize the property\n                    const normalizedProperty = normalizeProperty(property);\n                    // If we have research data with valid coordinates, use them\n                    if (researchData && researchData.modules) {\n                        try {\n                            // Check for valid coordinates in property_details module\n                            const propertyDetails = researchData.modules.property_details || {};\n                            // Only use research coordinates if they're valid and property doesn't have them\n                            if (propertyDetails.latitude && propertyDetails.longitude && typeof propertyDetails.latitude === \"number\" && typeof propertyDetails.longitude === \"number\" && !normalizedProperty._is_grid_pattern) {\n                                normalizedProperty.latitude = propertyDetails.latitude;\n                                normalizedProperty.longitude = propertyDetails.longitude;\n                                normalizedProperty._coordinates_from_research = true;\n                                normalizedProperty._coordinates_missing = false;\n                                normalizedProperty._needs_geocoding = false;\n                                console.log(\"Using research coordinates for property \".concat(property.id, \": [\").concat(propertyDetails.latitude, \", \").concat(propertyDetails.longitude, \"]\"));\n                            }\n                            // Add research data to property\n                            normalizedProperty._research = {\n                                depth: researchData.research_depth,\n                                date: researchData.research_date,\n                                summary: researchData.executive_summary\n                            };\n                        } catch (e) {\n                            console.error(\"Error processing research data:\", e);\n                        }\n                    }\n                    return normalizedProperty;\n                });\n                // For map view, filter out properties without valid coordinates\n                if (!options.includeIncomplete) {\n                    const propertiesWithCoordinates = normalizedProperties.filter((p)=>p.latitude && p.longitude && (p._coordinates_from_research || !p._coordinates_missing && !p._is_grid_pattern));\n                    console.log(\"Filtered to \".concat(propertiesWithCoordinates.length, \" properties with valid coordinates\"));\n                    if (propertiesWithCoordinates.length > 0) {\n                        return propertiesWithCoordinates;\n                    }\n                    // If all properties were filtered out, return them anyway to avoid empty map\n                    console.warn(\"All properties were filtered out for having invalid coordinates\");\n                }\n                return normalizedProperties;\n            }\n        } catch (joinError) {\n            console.error(\"Error with research join query:\", joinError);\n        // Fall back to standard query\n        }\n    }\n    // Fallback - standard query without research data\n    console.log(\"Using standard property query without research data\");\n    let query = supabase.from(\"properties\").select(\"*\");\n    // Apply filters if provided\n    if (options.filters) {\n        Object.entries(options.filters).forEach((param)=>{\n            let [key, value] = param;\n            if (value !== undefined && value !== null && value !== \"\") {\n                // Handle special filter syntax\n                if (key === \"or\") {\n                    query = query.or(value);\n                } else if (key.endsWith(\"_gte\")) {\n                    const actualKey = key.replace(\"_gte\", \"\");\n                    query = query.gte(actualKey, value);\n                } else if (key.endsWith(\"_lte\")) {\n                    const actualKey = key.replace(\"_lte\", \"\");\n                    query = query.lte(actualKey, value);\n                } else if (key.endsWith(\"_gt\")) {\n                    const actualKey = key.replace(\"_gt\", \"\");\n                    query = query.gt(actualKey, value);\n                } else if (key.endsWith(\"_lt\")) {\n                    const actualKey = key.replace(\"_lt\", \"\");\n                    query = query.lt(actualKey, value);\n                } else if (key.endsWith(\"_ilike\")) {\n                    const actualKey = key.replace(\"_ilike\", \"\");\n                    query = query.ilike(actualKey, value);\n                } else {\n                    // Default to equality matching\n                    query = query.eq(key, value);\n                }\n            }\n        });\n    }\n    // If we need complete properties with coordinates for the map\n    if (!options.includeIncomplete) {\n        // Use a more precise filter to avoid empty/zero coordinates\n        // First prioritize properties with valid coordinates (either direct or from research)\n        query = query.not(\"latitude\", \"is\", null).not(\"longitude\", \"is\", null).not(\"latitude\", \"eq\", 0).not(\"longitude\", \"eq\", 0).order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"Querying for properties with valid coordinates only\");\n    } else {\n        console.log(\"Including all properties regardless of coordinates\");\n    }\n    // Apply pagination\n    if (options.page && options.pageSize) {\n        const start = (options.page - 1) * options.pageSize;\n        const end = start + options.pageSize - 1;\n        query = query.range(start, end);\n    }\n    // Apply sorting\n    if (options.sortBy) {\n        query = query.order(options.sortBy, {\n            ascending: options.sortAsc !== false\n        });\n    }\n    // Execute query\n    const { data, error } = await query;\n    if (error) {\n        console.error(\"Error fetching properties:\", error);\n        throw error;\n    }\n    if (!data || data.length === 0) {\n        console.warn(\"No properties found with the given criteria\");\n        return [];\n    }\n    // Normalize property data to handle inconsistencies\n    return data.map((property)=>normalizeProperty(property));\n};\n/**\n * Normalizes property data to handle inconsistent field names\n * \n * @param {Object} property - Raw property data from Supabase\n * @returns {Object} Normalized property data\n */ const normalizeProperty = (property)=>{\n    // Make copy to avoid mutating the original\n    const normalized = {\n        ...property\n    };\n    // Handle inconsistent unit field names\n    normalized.units = property.num_units || property.units || null;\n    // Use property name or derive from address if missing\n    if (!normalized.name || normalized.name.trim() === \"\") {\n        normalized.name = property.address ? \"Property at \".concat(property.address.split(\",\")[0]) : \"Property \".concat(property.id.substring(0, 8));\n    }\n    // Make sure we have status\n    normalized.status = property.status || property.property_status || \"Listed\";\n    // Check if this is likely a test property\n    normalized._is_test_property = isTestProperty(property);\n    // Add coordinate related flags\n    if (property.latitude && property.longitude && typeof property.latitude === \"number\" && typeof property.longitude === \"number\" && !(property.latitude === 0 && property.longitude === 0)) {\n        // Check if coordinates are valid (in proper lat/long ranges)\n        const isValidLatitude = property.latitude >= -90 && property.latitude <= 90;\n        const isValidLongitude = property.longitude >= -180 && property.longitude <= 180;\n        // Austin area boundaries (approximate) - helps detect obviously wrong coordinates\n        const isInAustinArea = property.latitude >= 29.5 && property.latitude <= 31.0 && property.longitude >= -98.0 && property.longitude <= -97.0;\n        // Check if coordinates are part of a grid pattern (low precision or suspicious patterns)\n        const latStr = String(property.latitude);\n        const lngStr = String(property.longitude);\n        // Only flag very low precision coordinates as suspicious (1 decimal place or less)\n        const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 1 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 1;\n        // Reduced set of suspicious patterns\n        const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n        latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\");\n        // Keep track of whether this is detected as a grid pattern\n        const isGridPattern = hasLowPrecision || hasSuspiciousPattern;\n        // Flag coordinates as missing if they're invalid or suspicious\n        if (!isValidLatitude || !isValidLongitude || isGridPattern) {\n            normalized._coordinates_missing = true;\n            normalized._needs_geocoding = true;\n            normalized._is_grid_pattern = isGridPattern;\n            normalized._is_invalid_range = !isValidLatitude || !isValidLongitude;\n            // Debug info for invalid coordinates\n            if (!isValidLatitude || !isValidLongitude) {\n                console.warn(\"Invalid coordinate range for property \".concat(property.id, \": [\").concat(property.latitude, \", \").concat(property.longitude, \"]\"));\n            }\n        } else {\n            // Set additional flags for coordinates outside Austin (might be valid but suspicious)\n            normalized._outside_austin = !isInAustinArea;\n            normalized._coordinates_missing = false;\n            normalized._needs_geocoding = false;\n        }\n    } else {\n        // No coordinates or invalid coordinates\n        normalized._coordinates_missing = true;\n        normalized._needs_geocoding = true;\n    }\n    return normalized;\n};\n/**\n * Determines if a property is likely a test/example property\n * \n * @param {Object} property - Property data to check\n * @returns {boolean} True if property is likely a test property\n */ const isTestProperty = (property)=>{\n    // Check for common test property indicators in name\n    const name = (property.name || \"\").toLowerCase();\n    const testIndicators = [\n        \"test\",\n        \"example\",\n        \"sample\",\n        \"demo\",\n        \"dummy\",\n        \"template\"\n    ];\n    for (const indicator of testIndicators){\n        if (name.includes(indicator)) {\n            return true;\n        }\n    }\n    // Check for unrealistic values\n    if (property.price === 0 || property.price === 1) {\n        return true;\n    }\n    if (property.units === 0 || property.units === 999 || property.num_units === 0 || property.num_units === 999) {\n        return true;\n    }\n    // Check for placeholder addresses\n    const address = (property.address || \"\").toLowerCase();\n    const placeholderIndicators = [\n        \"123 main\",\n        \"test address\",\n        \"example\",\n        \"placeholder\"\n    ];\n    for (const indicator of placeholderIndicators){\n        if (address.includes(indicator)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Creates a test property in the database for testing purposes\n * Use this to verify the database connection is working\n * \n * @returns {Promise<Object>} The created test property\n */ const createTestProperty = async ()=>{\n    // First, check if we can get the table structure\n    try {\n        // Try to get one record to see the schema\n        const { data: sampleProperty, error: sampleError } = await supabase.from(\"properties\").select(\"*\").limit(1);\n        // Basic test property that matches the schema from supabase-setup.md\n        const baseTestProperty = {\n            name: \"Test Property \".concat(new Date().toISOString().slice(0, 16)),\n            address: \"123 Test Street\",\n            city: \"Austin\",\n            state: \"TX\",\n            zip_code: \"78701\",\n            latitude: 30.2672,\n            longitude: -97.7431,\n            price: 5000000,\n            units: 50,\n            year_built: 2010,\n            property_type: \"MULTIFAMILY\",\n            status: \"available\",\n            description: \"This is a test property created to verify database connectivity.\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        };\n        // If we have a sample, adapt to its schema\n        let testProperty = baseTestProperty;\n        if (!sampleError && sampleProperty && sampleProperty.length > 0) {\n            console.log(\"Found existing property for schema reference:\", sampleProperty[0]);\n            // Adapt our test property to match the existing schema\n            const sample = sampleProperty[0];\n            // Create a new object with only the fields that exist in the sample\n            const adaptedProperty = {};\n            Object.keys(baseTestProperty).forEach((key)=>{\n                // If the field exists in the sample, use our test value\n                if (key in sample) {\n                    adaptedProperty[key] = baseTestProperty[key];\n                }\n            });\n            // Check key fields that might have different names\n            if (\"property_status\" in sample && !(\"status\" in sample)) {\n                adaptedProperty.property_status = baseTestProperty.status;\n                delete adaptedProperty.status;\n            }\n            if (\"num_units\" in sample && !(\"units\" in sample)) {\n                adaptedProperty.num_units = baseTestProperty.units;\n                delete adaptedProperty.units;\n            }\n            // Use the adapted property\n            testProperty = adaptedProperty;\n            console.log(\"Adapted test property to match schema:\", testProperty);\n        } else {\n            console.log(\"No sample property found, using default schema\");\n        }\n        // Try to insert the test property\n        const { data, error } = await supabase.from(\"properties\").insert(testProperty).select();\n        if (error) {\n            console.error(\"Error creating test property:\", error);\n            // Try again with minimal fields if this failed\n            if (error.message && (error.message.includes(\"violates not-null constraint\") || error.message.includes(\"missing\"))) {\n                console.log(\"Trying again with minimal required fields\");\n                // Try with just the bare minimum fields\n                const minimalProperty = {\n                    name: \"Test Property \".concat(new Date().toISOString().slice(0, 16)),\n                    address: \"123 Test Street\",\n                    city: \"Austin\",\n                    state: \"TX\"\n                };\n                const { data: minData, error: minError } = await supabase.from(\"properties\").insert(minimalProperty).select();\n                if (minError) {\n                    console.error(\"Error creating minimal property:\", minError);\n                    throw minError;\n                }\n                console.log(\"Successfully created minimal test property:\", minData);\n                return {\n                    data: minData,\n                    info: \"Created with minimal fields only\"\n                };\n            }\n            throw error;\n        }\n        console.log(\"Test property created:\", data);\n        return {\n            data,\n            info: \"Created with full fields\"\n        };\n    } catch (err) {\n        console.error(\"Error in createTestProperty:\", err);\n        throw err;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (supabase);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxNQUFNO1FBQ1I7SUFDRixFQUFFLE9BQU9DLEtBQUs7UUFDWjFJLFFBQVFDLEtBQUssQ0FBQyxnQ0FBZ0N5STtRQUM5QyxNQUFNQTtJQUNSO0FBQ0YsRUFBRTtBQUVGLCtEQUFleEksUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc3VwYWJhc2UuanM/MTU5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN1cGFiYXNlIGNsaWVudCBmb3IgZnJvbnRlbmQgb3BlcmF0aW9uc1xuICovXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG4vLyBHZXQgU3VwYWJhc2UgY3JlZGVudGlhbHMgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk7XG5cbmlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlQW5vbktleSkge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdTdXBhYmFzZSBjcmVkZW50aWFscyBub3QgZm91bmQuIFBsZWFzZSBzZXQgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJ1xuICApO1xufVxuXG4vLyBDcmVhdGUgU3VwYWJhc2UgY2xpZW50XG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICBhdXRoOiB7XG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWVcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlclxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSBUaGUgdXNlciBvYmplY3Qgb3IgbnVsbCBpZiBub3QgYXV0aGVudGljYXRlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFVzZXIgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICByZXR1cm4gdXNlcjtcbn07XG5cbi8qKlxuICogU2lnbiB1cCBhIG5ldyB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgLSBVc2VyJ3MgZW1haWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIncyBwYXNzd29yZFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIHJlc3VsdCBvZiB0aGUgc2lnbiB1cCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNpZ25VcCA9IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcbiAgcmV0dXJuIGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnblVwKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZCxcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNpZ24gaW4gYSB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgLSBVc2VyJ3MgZW1haWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFVzZXIncyBwYXNzd29yZFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIHJlc3VsdCBvZiB0aGUgc2lnbiBpbiBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNpZ25JbiA9IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcbiAgcmV0dXJuIGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICBlbWFpbCxcbiAgICBwYXNzd29yZCxcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNpZ24gb3V0IHRoZSBjdXJyZW50IHVzZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSByZXN1bHQgb2YgdGhlIHNpZ24gb3V0IG9wZXJhdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2lnbk91dCA9IGFzeW5jICgpID0+IHtcbiAgcmV0dXJuIGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpO1xufTtcblxuLyoqXG4gKiBGZXRjaCBwcm9wZXJ0aWVzIGZyb20gU3VwYWJhc2Ugd2l0aCBlbmhhbmNlZCBlcnJvciBoYW5kbGluZyBhbmQgZGF0YSBub3JtYWxpemF0aW9uXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZmlsdGVycyAtIEtleS12YWx1ZSBwYWlycyBmb3IgZmlsdGVyaW5nIChlLmcuIHtzdGF0dXM6ICdGb3IgU2FsZSd9KVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGFnZSAtIFBhZ2UgbnVtYmVyIGZvciBwYWdpbmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wYWdlU2l6ZSAtIE51bWJlciBvZiBpdGVtcyBwZXIgcGFnZVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc29ydEJ5IC0gRmllbGQgdG8gc29ydCBieVxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNvcnRBc2MgLSBTb3J0IGluIGFzY2VuZGluZyBvcmRlciBpZiB0cnVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaW5jbHVkZUluY29tcGxldGUgLSBXaGV0aGVyIHRvIGluY2x1ZGUgcHJvcGVydGllcyB3aXRoIG1pc3NpbmcgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pbmNsdWRlUmVzZWFyY2ggLSBXaGV0aGVyIHRvIGluY2x1ZGUgZW5yaWNoZWQgcmVzZWFyY2ggZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBcnJheSBvZiBub3JtYWxpemVkIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoUHJvcGVydGllcyA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGpvaW4gd2l0aCByZXNlYXJjaCBkYXRhXG4gIGlmIChvcHRpb25zLmluY2x1ZGVSZXNlYXJjaCAhPT0gZmFsc2UpIHtcbiAgICAvLyBJbmNsdWRlIHJlc2VhcmNoIGRhdGEgaW4gb3VyIHF1ZXJ5IC0gd2UnbGwgam9pbiB3aXRoIHByb3BlcnR5X3Jlc2VhcmNoIHRhYmxlXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0YXJ0IHdpdGggYSBxdWVyeSB0aGF0IGpvaW5zIHByb3BlcnRpZXMgd2l0aCByZXNlYXJjaCBkYXRhXG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKCdwcm9wZXJ0aWVzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgKixcbiAgICAgICAgICBwcm9wZXJ0eV9yZXNlYXJjaDpwcm9wZXJ0eV9yZXNlYXJjaCgqKVxuICAgICAgICBgKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgZmlsdGVycyBpZiBwcm92aWRlZFxuICAgICAgaWYgKG9wdGlvbnMuZmlsdGVycykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLmZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgZmlsdGVyIHN5bnRheFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29yJykge1xuICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdfZ3RlJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWN0dWFsS2V5ID0ga2V5LnJlcGxhY2UoJ19ndGUnLCAnJyk7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZ3RlKGFjdHVhbEtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ19sdGUnKSkge1xuICAgICAgICAgICAgICBjb25zdCBhY3R1YWxLZXkgPSBrZXkucmVwbGFjZSgnX2x0ZScsICcnKTtcbiAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5sdGUoYWN0dWFsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnX2d0JykpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWN0dWFsS2V5ID0ga2V5LnJlcGxhY2UoJ19ndCcsICcnKTtcbiAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5ndChhY3R1YWxLZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdfbHQnKSkge1xuICAgICAgICAgICAgICBjb25zdCBhY3R1YWxLZXkgPSBrZXkucmVwbGFjZSgnX2x0JywgJycpO1xuICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmx0KGFjdHVhbEtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ19pbGlrZScpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdHVhbEtleSA9IGtleS5yZXBsYWNlKCdfaWxpa2UnLCAnJyk7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuaWxpa2UoYWN0dWFsS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGVxdWFsaXR5IG1hdGNoaW5nXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgbmVlZCBjb21wbGV0ZSBwcm9wZXJ0aWVzIHdpdGggY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXBcbiAgICAgIGlmICghb3B0aW9ucy5pbmNsdWRlSW5jb21wbGV0ZSkge1xuICAgICAgICAvLyBVc2UgYSBtb3JlIHByZWNpc2UgZmlsdGVyIHRvIGF2b2lkIGVtcHR5L3plcm8gY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gRmlyc3QgcHJpb3JpdGl6ZSBwcm9wZXJ0aWVzIHdpdGggdmFsaWQgY29vcmRpbmF0ZXMgKGVpdGhlciBkaXJlY3Qgb3IgZnJvbSByZXNlYXJjaClcbiAgICAgICAgcXVlcnkgPSBxdWVyeVxuICAgICAgICAgIC5ub3QoJ2xhdGl0dWRlJywgJ2lzJywgbnVsbClcbiAgICAgICAgICAubm90KCdsb25naXR1ZGUnLCAnaXMnLCBudWxsKVxuICAgICAgICAgIC5ub3QoJ2xhdGl0dWRlJywgJ2VxJywgMClcbiAgICAgICAgICAubm90KCdsb25naXR1ZGUnLCAnZXEnLCAwKVxuICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdRdWVyeWluZyBmb3IgcHJvcGVydGllcyB3aXRoIHZhbGlkIGNvb3JkaW5hdGVzIG9ubHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdJbmNsdWRpbmcgYWxsIHByb3BlcnRpZXMgcmVnYXJkbGVzcyBvZiBjb29yZGluYXRlcycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBwYWdpbmF0aW9uXG4gICAgICBpZiAob3B0aW9ucy5wYWdlICYmIG9wdGlvbnMucGFnZVNpemUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAob3B0aW9ucy5wYWdlIC0gMSkgKiBvcHRpb25zLnBhZ2VTaXplO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIG9wdGlvbnMucGFnZVNpemUgLSAxO1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICBpZiAob3B0aW9ucy5zb3J0QnkpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5vcmRlcihvcHRpb25zLnNvcnRCeSwgeyBhc2NlbmRpbmc6IG9wdGlvbnMuc29ydEFzYyAhPT0gZmFsc2UgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4ZWN1dGUgcXVlcnlcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBub24tam9pbiBxdWVyeVxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGZldGNoaW5nIHByb3BlcnRpZXMgd2l0aCByZXNlYXJjaCBqb2luOicsIGVycm9yKTtcbiAgICAgICAgLy8gQ29udGludWUgdG8gZmFsbGJhY2sgcXVlcnkgYmVsb3dcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7ZGF0YS5sZW5ndGh9IHByb3BlcnRpZXMgd2l0aCByZXNlYXJjaCBkYXRhYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNZXJnZSByZXNlYXJjaCBkYXRhIHdpdGggcHJvcGVydHkgZGF0YVxuICAgICAgICBjb25zdCBub3JtYWxpemVkUHJvcGVydGllcyA9IGRhdGEubWFwKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAvLyBFeHRyYWN0IHJlc2VhcmNoIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgY29uc3QgcmVzZWFyY2hEYXRhID0gcHJvcGVydHkucHJvcGVydHlfcmVzZWFyY2ggJiYgcHJvcGVydHkucHJvcGVydHlfcmVzZWFyY2gubGVuZ3RoID4gMCBcbiAgICAgICAgICAgID8gcHJvcGVydHkucHJvcGVydHlfcmVzZWFyY2hbMF0gXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBuZXN0ZWQgcHJvcGVydHlfcmVzZWFyY2ggdG8gYXZvaWQgY29uZnVzaW9uXG4gICAgICAgICAgZGVsZXRlIHByb3BlcnR5LnByb3BlcnR5X3Jlc2VhcmNoO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkUHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSByZXNlYXJjaCBkYXRhIHdpdGggdmFsaWQgY29vcmRpbmF0ZXMsIHVzZSB0aGVtXG4gICAgICAgICAgaWYgKHJlc2VhcmNoRGF0YSAmJiByZXNlYXJjaERhdGEubW9kdWxlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhbGlkIGNvb3JkaW5hdGVzIGluIHByb3BlcnR5X2RldGFpbHMgbW9kdWxlXG4gICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5RGV0YWlscyA9IHJlc2VhcmNoRGF0YS5tb2R1bGVzLnByb3BlcnR5X2RldGFpbHMgfHwge307XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBPbmx5IHVzZSByZXNlYXJjaCBjb29yZGluYXRlcyBpZiB0aGV5J3JlIHZhbGlkIGFuZCBwcm9wZXJ0eSBkb2Vzbid0IGhhdmUgdGhlbVxuICAgICAgICAgICAgICBpZiAocHJvcGVydHlEZXRhaWxzLmxhdGl0dWRlICYmIHByb3BlcnR5RGV0YWlscy5sb25naXR1ZGUgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBwcm9wZXJ0eURldGFpbHMubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHByb3BlcnR5RGV0YWlscy5sb25naXR1ZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAhbm9ybWFsaXplZFByb3BlcnR5Ll9pc19ncmlkX3BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcGVydHkubGF0aXR1ZGUgPSBwcm9wZXJ0eURldGFpbHMubGF0aXR1ZGU7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3BlcnR5LmxvbmdpdHVkZSA9IHByb3BlcnR5RGV0YWlscy5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3BlcnR5Ll9jb29yZGluYXRlc19mcm9tX3Jlc2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcGVydHkuX2Nvb3JkaW5hdGVzX21pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyByZXNlYXJjaCBjb29yZGluYXRlcyBmb3IgcHJvcGVydHkgJHtwcm9wZXJ0eS5pZH06IFske3Byb3BlcnR5RGV0YWlscy5sYXRpdHVkZX0sICR7cHJvcGVydHlEZXRhaWxzLmxvbmdpdHVkZX1dYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFkZCByZXNlYXJjaCBkYXRhIHRvIHByb3BlcnR5XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wZXJ0eS5fcmVzZWFyY2ggPSB7XG4gICAgICAgICAgICAgICAgZGVwdGg6IHJlc2VhcmNoRGF0YS5yZXNlYXJjaF9kZXB0aCxcbiAgICAgICAgICAgICAgICBkYXRlOiByZXNlYXJjaERhdGEucmVzZWFyY2hfZGF0ZSxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiByZXNlYXJjaERhdGEuZXhlY3V0aXZlX3N1bW1hcnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyByZXNlYXJjaCBkYXRhOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZFByb3BlcnR5O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBtYXAgdmlldywgZmlsdGVyIG91dCBwcm9wZXJ0aWVzIHdpdGhvdXQgdmFsaWQgY29vcmRpbmF0ZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLmluY2x1ZGVJbmNvbXBsZXRlKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydGllc1dpdGhDb29yZGluYXRlcyA9IG5vcm1hbGl6ZWRQcm9wZXJ0aWVzLmZpbHRlcihcbiAgICAgICAgICAgIHAgPT4gcC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSAmJiBcbiAgICAgICAgICAgICAgICAocC5fY29vcmRpbmF0ZXNfZnJvbV9yZXNlYXJjaCB8fCBcbiAgICAgICAgICAgICAgICAgICghcC5fY29vcmRpbmF0ZXNfbWlzc2luZyAmJiAhcC5faXNfZ3JpZF9wYXR0ZXJuKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGaWx0ZXJlZCB0byAke3Byb3BlcnRpZXNXaXRoQ29vcmRpbmF0ZXMubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggdmFsaWQgY29vcmRpbmF0ZXNgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocHJvcGVydGllc1dpdGhDb29yZGluYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllc1dpdGhDb29yZGluYXRlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgYWxsIHByb3BlcnRpZXMgd2VyZSBmaWx0ZXJlZCBvdXQsIHJldHVybiB0aGVtIGFueXdheSB0byBhdm9pZCBlbXB0eSBtYXBcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0FsbCBwcm9wZXJ0aWVzIHdlcmUgZmlsdGVyZWQgb3V0IGZvciBoYXZpbmcgaW52YWxpZCBjb29yZGluYXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFByb3BlcnRpZXM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoam9pbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aXRoIHJlc2VhcmNoIGpvaW4gcXVlcnk6Jywgam9pbkVycm9yKTtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBzdGFuZGFyZCBxdWVyeVxuICAgIH1cbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgLSBzdGFuZGFyZCBxdWVyeSB3aXRob3V0IHJlc2VhcmNoIGRhdGFcbiAgY29uc29sZS5sb2coJ1VzaW5nIHN0YW5kYXJkIHByb3BlcnR5IHF1ZXJ5IHdpdGhvdXQgcmVzZWFyY2ggZGF0YScpO1xuICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKCdwcm9wZXJ0aWVzJykuc2VsZWN0KCcqJyk7XG4gIFxuICAvLyBBcHBseSBmaWx0ZXJzIGlmIHByb3ZpZGVkXG4gIGlmIChvcHRpb25zLmZpbHRlcnMpIHtcbiAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLmZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGZpbHRlciBzeW50YXhcbiAgICAgICAgaWYgKGtleSA9PT0gJ29yJykge1xuICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkub3IodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnX2d0ZScpKSB7XG4gICAgICAgICAgY29uc3QgYWN0dWFsS2V5ID0ga2V5LnJlcGxhY2UoJ19ndGUnLCAnJyk7XG4gICAgICAgICAgcXVlcnkgPSBxdWVyeS5ndGUoYWN0dWFsS2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdfbHRlJykpIHtcbiAgICAgICAgICBjb25zdCBhY3R1YWxLZXkgPSBrZXkucmVwbGFjZSgnX2x0ZScsICcnKTtcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmx0ZShhY3R1YWxLZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ19ndCcpKSB7XG4gICAgICAgICAgY29uc3QgYWN0dWFsS2V5ID0ga2V5LnJlcGxhY2UoJ19ndCcsICcnKTtcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmd0KGFjdHVhbEtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5lbmRzV2l0aCgnX2x0JykpIHtcbiAgICAgICAgICBjb25zdCBhY3R1YWxLZXkgPSBrZXkucmVwbGFjZSgnX2x0JywgJycpO1xuICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkubHQoYWN0dWFsS2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdfaWxpa2UnKSkge1xuICAgICAgICAgIGNvbnN0IGFjdHVhbEtleSA9IGtleS5yZXBsYWNlKCdfaWxpa2UnLCAnJyk7XG4gICAgICAgICAgcXVlcnkgPSBxdWVyeS5pbGlrZShhY3R1YWxLZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIGVxdWFsaXR5IG1hdGNoaW5nXG4gICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBJZiB3ZSBuZWVkIGNvbXBsZXRlIHByb3BlcnRpZXMgd2l0aCBjb29yZGluYXRlcyBmb3IgdGhlIG1hcFxuICBpZiAoIW9wdGlvbnMuaW5jbHVkZUluY29tcGxldGUpIHtcbiAgICAvLyBVc2UgYSBtb3JlIHByZWNpc2UgZmlsdGVyIHRvIGF2b2lkIGVtcHR5L3plcm8gY29vcmRpbmF0ZXNcbiAgICAvLyBGaXJzdCBwcmlvcml0aXplIHByb3BlcnRpZXMgd2l0aCB2YWxpZCBjb29yZGluYXRlcyAoZWl0aGVyIGRpcmVjdCBvciBmcm9tIHJlc2VhcmNoKVxuICAgIHF1ZXJ5ID0gcXVlcnlcbiAgICAgIC5ub3QoJ2xhdGl0dWRlJywgJ2lzJywgbnVsbClcbiAgICAgIC5ub3QoJ2xvbmdpdHVkZScsICdpcycsIG51bGwpXG4gICAgICAubm90KCdsYXRpdHVkZScsICdlcScsIDApXG4gICAgICAubm90KCdsb25naXR1ZGUnLCAnZXEnLCAwKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdRdWVyeWluZyBmb3IgcHJvcGVydGllcyB3aXRoIHZhbGlkIGNvb3JkaW5hdGVzIG9ubHknKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnSW5jbHVkaW5nIGFsbCBwcm9wZXJ0aWVzIHJlZ2FyZGxlc3Mgb2YgY29vcmRpbmF0ZXMnKTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgcGFnaW5hdGlvblxuICBpZiAob3B0aW9ucy5wYWdlICYmIG9wdGlvbnMucGFnZVNpemUpIHtcbiAgICBjb25zdCBzdGFydCA9IChvcHRpb25zLnBhZ2UgLSAxKSAqIG9wdGlvbnMucGFnZVNpemU7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBvcHRpb25zLnBhZ2VTaXplIC0gMTtcbiAgICBxdWVyeSA9IHF1ZXJ5LnJhbmdlKHN0YXJ0LCBlbmQpO1xuICB9XG4gIFxuICAvLyBBcHBseSBzb3J0aW5nXG4gIGlmIChvcHRpb25zLnNvcnRCeSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIob3B0aW9ucy5zb3J0QnksIHsgYXNjZW5kaW5nOiBvcHRpb25zLnNvcnRBc2MgIT09IGZhbHNlIH0pO1xuICB9XG4gIFxuICAvLyBFeGVjdXRlIHF1ZXJ5XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvcGVydGllczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgXG4gIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUud2FybignTm8gcHJvcGVydGllcyBmb3VuZCB3aXRoIHRoZSBnaXZlbiBjcml0ZXJpYScpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgLy8gTm9ybWFsaXplIHByb3BlcnR5IGRhdGEgdG8gaGFuZGxlIGluY29uc2lzdGVuY2llc1xuICByZXR1cm4gZGF0YS5tYXAocHJvcGVydHkgPT4gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHkpKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplcyBwcm9wZXJ0eSBkYXRhIHRvIGhhbmRsZSBpbmNvbnNpc3RlbnQgZmllbGQgbmFtZXNcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IC0gUmF3IHByb3BlcnR5IGRhdGEgZnJvbSBTdXBhYmFzZVxuICogQHJldHVybnMge09iamVjdH0gTm9ybWFsaXplZCBwcm9wZXJ0eSBkYXRhXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVByb3BlcnR5ID0gKHByb3BlcnR5KSA9PiB7XG4gIC8vIE1ha2UgY29weSB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHsgLi4ucHJvcGVydHkgfTtcbiAgXG4gIC8vIEhhbmRsZSBpbmNvbnNpc3RlbnQgdW5pdCBmaWVsZCBuYW1lc1xuICBub3JtYWxpemVkLnVuaXRzID0gcHJvcGVydHkubnVtX3VuaXRzIHx8IHByb3BlcnR5LnVuaXRzIHx8IG51bGw7XG4gIFxuICAvLyBVc2UgcHJvcGVydHkgbmFtZSBvciBkZXJpdmUgZnJvbSBhZGRyZXNzIGlmIG1pc3NpbmdcbiAgaWYgKCFub3JtYWxpemVkLm5hbWUgfHwgbm9ybWFsaXplZC5uYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICBub3JtYWxpemVkLm5hbWUgPSBwcm9wZXJ0eS5hZGRyZXNzIFxuICAgICAgPyBgUHJvcGVydHkgYXQgJHtwcm9wZXJ0eS5hZGRyZXNzLnNwbGl0KCcsJylbMF19YFxuICAgICAgOiBgUHJvcGVydHkgJHtwcm9wZXJ0eS5pZC5zdWJzdHJpbmcoMCwgOCl9YDtcbiAgfVxuICBcbiAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgc3RhdHVzXG4gIG5vcm1hbGl6ZWQuc3RhdHVzID0gcHJvcGVydHkuc3RhdHVzIHx8IHByb3BlcnR5LnByb3BlcnR5X3N0YXR1cyB8fCAnTGlzdGVkJztcbiAgXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgbGlrZWx5IGEgdGVzdCBwcm9wZXJ0eVxuICBub3JtYWxpemVkLl9pc190ZXN0X3Byb3BlcnR5ID0gaXNUZXN0UHJvcGVydHkocHJvcGVydHkpO1xuICBcbiAgLy8gQWRkIGNvb3JkaW5hdGUgcmVsYXRlZCBmbGFnc1xuICBpZiAocHJvcGVydHkubGF0aXR1ZGUgJiYgcHJvcGVydHkubG9uZ2l0dWRlICYmXG4gICAgICB0eXBlb2YgcHJvcGVydHkubGF0aXR1ZGUgPT09ICdudW1iZXInICYmIFxuICAgICAgdHlwZW9mIHByb3BlcnR5LmxvbmdpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICEocHJvcGVydHkubGF0aXR1ZGUgPT09IDAgJiYgcHJvcGVydHkubG9uZ2l0dWRlID09PSAwKSkge1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSB2YWxpZCAoaW4gcHJvcGVyIGxhdC9sb25nIHJhbmdlcylcbiAgICBjb25zdCBpc1ZhbGlkTGF0aXR1ZGUgPSBwcm9wZXJ0eS5sYXRpdHVkZSA+PSAtOTAgJiYgcHJvcGVydHkubGF0aXR1ZGUgPD0gOTA7XG4gICAgY29uc3QgaXNWYWxpZExvbmdpdHVkZSA9IHByb3BlcnR5LmxvbmdpdHVkZSA+PSAtMTgwICYmIHByb3BlcnR5LmxvbmdpdHVkZSA8PSAxODA7XG4gICAgXG4gICAgLy8gQXVzdGluIGFyZWEgYm91bmRhcmllcyAoYXBwcm94aW1hdGUpIC0gaGVscHMgZGV0ZWN0IG9idmlvdXNseSB3cm9uZyBjb29yZGluYXRlc1xuICAgIGNvbnN0IGlzSW5BdXN0aW5BcmVhID0gKFxuICAgICAgcHJvcGVydHkubGF0aXR1ZGUgPj0gMjkuNSAmJiBwcm9wZXJ0eS5sYXRpdHVkZSA8PSAzMS4wICYmIFxuICAgICAgcHJvcGVydHkubG9uZ2l0dWRlID49IC05OC4wICYmIHByb3BlcnR5LmxvbmdpdHVkZSA8PSAtOTcuMFxuICAgICk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY29vcmRpbmF0ZXMgYXJlIHBhcnQgb2YgYSBncmlkIHBhdHRlcm4gKGxvdyBwcmVjaXNpb24gb3Igc3VzcGljaW91cyBwYXR0ZXJucylcbiAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocHJvcGVydHkubGF0aXR1ZGUpO1xuICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwcm9wZXJ0eS5sb25naXR1ZGUpO1xuICAgIFxuICAgIC8vIE9ubHkgZmxhZyB2ZXJ5IGxvdyBwcmVjaXNpb24gY29vcmRpbmF0ZXMgYXMgc3VzcGljaW91cyAoMSBkZWNpbWFsIHBsYWNlIG9yIGxlc3MpXG4gICAgY29uc3QgaGFzTG93UHJlY2lzaW9uID0gXG4gICAgICAobGF0U3RyLmluY2x1ZGVzKCcuJykgJiYgbGF0U3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDEpIHx8XG4gICAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDEpO1xuICAgICAgXG4gICAgLy8gUmVkdWNlZCBzZXQgb2Ygc3VzcGljaW91cyBwYXR0ZXJuc1xuICAgIGNvbnN0IGhhc1N1c3BpY2lvdXNQYXR0ZXJuID0gXG4gICAgICBsYXRTdHIgPT09IGxuZ1N0ciB8fCAvLyBTYW1lIGxhdC9sbmcgaXMgdmVyeSB1bmxpa2VseVxuICAgICAgbGF0U3RyLmVuZHNXaXRoKCcwMDAwMCcpIHx8IFxuICAgICAgbG5nU3RyLmVuZHNXaXRoKCcwMDAwMCcpO1xuICAgIFxuICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGlzIGlzIGRldGVjdGVkIGFzIGEgZ3JpZCBwYXR0ZXJuXG4gICAgY29uc3QgaXNHcmlkUGF0dGVybiA9IGhhc0xvd1ByZWNpc2lvbiB8fCBoYXNTdXNwaWNpb3VzUGF0dGVybjtcbiAgICBcbiAgICAvLyBGbGFnIGNvb3JkaW5hdGVzIGFzIG1pc3NpbmcgaWYgdGhleSdyZSBpbnZhbGlkIG9yIHN1c3BpY2lvdXNcbiAgICBpZiAoIWlzVmFsaWRMYXRpdHVkZSB8fCAhaXNWYWxpZExvbmdpdHVkZSB8fCBpc0dyaWRQYXR0ZXJuKSB7XG4gICAgICBub3JtYWxpemVkLl9jb29yZGluYXRlc19taXNzaW5nID0gdHJ1ZTtcbiAgICAgIG5vcm1hbGl6ZWQuX25lZWRzX2dlb2NvZGluZyA9IHRydWU7XG4gICAgICBub3JtYWxpemVkLl9pc19ncmlkX3BhdHRlcm4gPSBpc0dyaWRQYXR0ZXJuO1xuICAgICAgbm9ybWFsaXplZC5faXNfaW52YWxpZF9yYW5nZSA9ICFpc1ZhbGlkTGF0aXR1ZGUgfHwgIWlzVmFsaWRMb25naXR1ZGU7XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGluZm8gZm9yIGludmFsaWQgY29vcmRpbmF0ZXNcbiAgICAgIGlmICghaXNWYWxpZExhdGl0dWRlIHx8ICFpc1ZhbGlkTG9uZ2l0dWRlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBjb29yZGluYXRlIHJhbmdlIGZvciBwcm9wZXJ0eSAke3Byb3BlcnR5LmlkfTogWyR7cHJvcGVydHkubGF0aXR1ZGV9LCAke3Byb3BlcnR5LmxvbmdpdHVkZX1dYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldCBhZGRpdGlvbmFsIGZsYWdzIGZvciBjb29yZGluYXRlcyBvdXRzaWRlIEF1c3RpbiAobWlnaHQgYmUgdmFsaWQgYnV0IHN1c3BpY2lvdXMpXG4gICAgICBub3JtYWxpemVkLl9vdXRzaWRlX2F1c3RpbiA9ICFpc0luQXVzdGluQXJlYTtcbiAgICAgIG5vcm1hbGl6ZWQuX2Nvb3JkaW5hdGVzX21pc3NpbmcgPSBmYWxzZTtcbiAgICAgIG5vcm1hbGl6ZWQuX25lZWRzX2dlb2NvZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBjb29yZGluYXRlcyBvciBpbnZhbGlkIGNvb3JkaW5hdGVzXG4gICAgbm9ybWFsaXplZC5fY29vcmRpbmF0ZXNfbWlzc2luZyA9IHRydWU7XG4gICAgbm9ybWFsaXplZC5fbmVlZHNfZ2VvY29kaW5nID0gdHJ1ZTtcbiAgfVxuICBcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBsaWtlbHkgYSB0ZXN0L2V4YW1wbGUgcHJvcGVydHlcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IC0gUHJvcGVydHkgZGF0YSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgcHJvcGVydHkgaXMgbGlrZWx5IGEgdGVzdCBwcm9wZXJ0eVxuICovXG5jb25zdCBpc1Rlc3RQcm9wZXJ0eSA9IChwcm9wZXJ0eSkgPT4ge1xuICAvLyBDaGVjayBmb3IgY29tbW9uIHRlc3QgcHJvcGVydHkgaW5kaWNhdG9ycyBpbiBuYW1lXG4gIGNvbnN0IG5hbWUgPSAocHJvcGVydHkubmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgdGVzdEluZGljYXRvcnMgPSBbJ3Rlc3QnLCAnZXhhbXBsZScsICdzYW1wbGUnLCAnZGVtbycsICdkdW1teScsICd0ZW1wbGF0ZSddO1xuICBcbiAgZm9yIChjb25zdCBpbmRpY2F0b3Igb2YgdGVzdEluZGljYXRvcnMpIHtcbiAgICBpZiAobmFtZS5pbmNsdWRlcyhpbmRpY2F0b3IpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciB1bnJlYWxpc3RpYyB2YWx1ZXNcbiAgaWYgKHByb3BlcnR5LnByaWNlID09PSAwIHx8IHByb3BlcnR5LnByaWNlID09PSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIGlmIChwcm9wZXJ0eS51bml0cyA9PT0gMCB8fCBwcm9wZXJ0eS51bml0cyA9PT0gOTk5IHx8IHByb3BlcnR5Lm51bV91bml0cyA9PT0gMCB8fCBwcm9wZXJ0eS5udW1fdW5pdHMgPT09IDk5OSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvLyBDaGVjayBmb3IgcGxhY2Vob2xkZXIgYWRkcmVzc2VzXG4gIGNvbnN0IGFkZHJlc3MgPSAocHJvcGVydHkuYWRkcmVzcyB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgcGxhY2Vob2xkZXJJbmRpY2F0b3JzID0gWycxMjMgbWFpbicsICd0ZXN0IGFkZHJlc3MnLCAnZXhhbXBsZScsICdwbGFjZWhvbGRlciddO1xuICBcbiAgZm9yIChjb25zdCBpbmRpY2F0b3Igb2YgcGxhY2Vob2xkZXJJbmRpY2F0b3JzKSB7XG4gICAgaWYgKGFkZHJlc3MuaW5jbHVkZXMoaW5kaWNhdG9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXN0IHByb3BlcnR5IGluIHRoZSBkYXRhYmFzZSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICogVXNlIHRoaXMgdG8gdmVyaWZ5IHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGlzIHdvcmtpbmdcbiAqIFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIGNyZWF0ZWQgdGVzdCBwcm9wZXJ0eVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGVzdFByb3BlcnR5ID0gYXN5bmMgKCkgPT4ge1xuICAvLyBGaXJzdCwgY2hlY2sgaWYgd2UgY2FuIGdldCB0aGUgdGFibGUgc3RydWN0dXJlXG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGdldCBvbmUgcmVjb3JkIHRvIHNlZSB0aGUgc2NoZW1hXG4gICAgY29uc3QgeyBkYXRhOiBzYW1wbGVQcm9wZXJ0eSwgZXJyb3I6IHNhbXBsZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Byb3BlcnRpZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAubGltaXQoMSk7XG4gICAgXG4gICAgLy8gQmFzaWMgdGVzdCBwcm9wZXJ0eSB0aGF0IG1hdGNoZXMgdGhlIHNjaGVtYSBmcm9tIHN1cGFiYXNlLXNldHVwLm1kXG4gICAgY29uc3QgYmFzZVRlc3RQcm9wZXJ0eSA9IHtcbiAgICAgIG5hbWU6IGBUZXN0IFByb3BlcnR5ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE2KX1gLFxuICAgICAgYWRkcmVzczogJzEyMyBUZXN0IFN0cmVldCcsXG4gICAgICBjaXR5OiAnQXVzdGluJyxcbiAgICAgIHN0YXRlOiAnVFgnLFxuICAgICAgemlwX2NvZGU6ICc3ODcwMScsXG4gICAgICBsYXRpdHVkZTogMzAuMjY3MixcbiAgICAgIGxvbmdpdHVkZTogLTk3Ljc0MzEsXG4gICAgICBwcmljZTogNTAwMDAwMCxcbiAgICAgIHVuaXRzOiA1MCxcbiAgICAgIHllYXJfYnVpbHQ6IDIwMTAsXG4gICAgICBwcm9wZXJ0eV90eXBlOiAnTVVMVElGQU1JTFknLFxuICAgICAgc3RhdHVzOiAnYXZhaWxhYmxlJywgLy8gVXNlIHN0YXR1cyByYXRoZXIgdGhhbiBwcm9wZXJ0eV9zdGF0dXMgZnJvbSB0aGUgZG9jc1xuICAgICAgZGVzY3JpcHRpb246ICdUaGlzIGlzIGEgdGVzdCBwcm9wZXJ0eSBjcmVhdGVkIHRvIHZlcmlmeSBkYXRhYmFzZSBjb25uZWN0aXZpdHkuJyxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHNhbXBsZSwgYWRhcHQgdG8gaXRzIHNjaGVtYVxuICAgIGxldCB0ZXN0UHJvcGVydHkgPSBiYXNlVGVzdFByb3BlcnR5O1xuICAgIGlmICghc2FtcGxlRXJyb3IgJiYgc2FtcGxlUHJvcGVydHkgJiYgc2FtcGxlUHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGV4aXN0aW5nIHByb3BlcnR5IGZvciBzY2hlbWEgcmVmZXJlbmNlOicsIHNhbXBsZVByb3BlcnR5WzBdKTtcbiAgICAgIFxuICAgICAgLy8gQWRhcHQgb3VyIHRlc3QgcHJvcGVydHkgdG8gbWF0Y2ggdGhlIGV4aXN0aW5nIHNjaGVtYVxuICAgICAgY29uc3Qgc2FtcGxlID0gc2FtcGxlUHJvcGVydHlbMF07XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHRoZSBmaWVsZHMgdGhhdCBleGlzdCBpbiB0aGUgc2FtcGxlXG4gICAgICBjb25zdCBhZGFwdGVkUHJvcGVydHkgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGJhc2VUZXN0UHJvcGVydHkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIGZpZWxkIGV4aXN0cyBpbiB0aGUgc2FtcGxlLCB1c2Ugb3VyIHRlc3QgdmFsdWVcbiAgICAgICAgaWYgKGtleSBpbiBzYW1wbGUpIHtcbiAgICAgICAgICBhZGFwdGVkUHJvcGVydHlba2V5XSA9IGJhc2VUZXN0UHJvcGVydHlba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGtleSBmaWVsZHMgdGhhdCBtaWdodCBoYXZlIGRpZmZlcmVudCBuYW1lc1xuICAgICAgaWYgKCdwcm9wZXJ0eV9zdGF0dXMnIGluIHNhbXBsZSAmJiAhKCdzdGF0dXMnIGluIHNhbXBsZSkpIHtcbiAgICAgICAgYWRhcHRlZFByb3BlcnR5LnByb3BlcnR5X3N0YXR1cyA9IGJhc2VUZXN0UHJvcGVydHkuc3RhdHVzO1xuICAgICAgICBkZWxldGUgYWRhcHRlZFByb3BlcnR5LnN0YXR1cztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCdudW1fdW5pdHMnIGluIHNhbXBsZSAmJiAhKCd1bml0cycgaW4gc2FtcGxlKSkge1xuICAgICAgICBhZGFwdGVkUHJvcGVydHkubnVtX3VuaXRzID0gYmFzZVRlc3RQcm9wZXJ0eS51bml0cztcbiAgICAgICAgZGVsZXRlIGFkYXB0ZWRQcm9wZXJ0eS51bml0cztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBhZGFwdGVkIHByb3BlcnR5XG4gICAgICB0ZXN0UHJvcGVydHkgPSBhZGFwdGVkUHJvcGVydHk7XG4gICAgICBjb25zb2xlLmxvZygnQWRhcHRlZCB0ZXN0IHByb3BlcnR5IHRvIG1hdGNoIHNjaGVtYTonLCB0ZXN0UHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gc2FtcGxlIHByb3BlcnR5IGZvdW5kLCB1c2luZyBkZWZhdWx0IHNjaGVtYScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSB0ZXN0IHByb3BlcnR5XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdwcm9wZXJ0aWVzJylcbiAgICAgIC5pbnNlcnQodGVzdFByb3BlcnR5KVxuICAgICAgLnNlbGVjdCgpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0ZXN0IHByb3BlcnR5OicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IGFnYWluIHdpdGggbWluaW1hbCBmaWVsZHMgaWYgdGhpcyBmYWlsZWRcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd2aW9sYXRlcyBub3QtbnVsbCBjb25zdHJhaW50JykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdtaXNzaW5nJykpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgYWdhaW4gd2l0aCBtaW5pbWFsIHJlcXVpcmVkIGZpZWxkcycpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHdpdGgganVzdCB0aGUgYmFyZSBtaW5pbXVtIGZpZWxkc1xuICAgICAgICBjb25zdCBtaW5pbWFsUHJvcGVydHkgPSB7XG4gICAgICAgICAgbmFtZTogYFRlc3QgUHJvcGVydHkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTYpfWAsXG4gICAgICAgICAgYWRkcmVzczogJzEyMyBUZXN0IFN0cmVldCcsXG4gICAgICAgICAgY2l0eTogJ0F1c3RpbicsXG4gICAgICAgICAgc3RhdGU6ICdUWCdcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHsgZGF0YTogbWluRGF0YSwgZXJyb3I6IG1pbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9wZXJ0aWVzJylcbiAgICAgICAgICAuaW5zZXJ0KG1pbmltYWxQcm9wZXJ0eSlcbiAgICAgICAgICAuc2VsZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChtaW5FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIG1pbmltYWwgcHJvcGVydHk6JywgbWluRXJyb3IpO1xuICAgICAgICAgIHRocm93IG1pbkVycm9yO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgbWluaW1hbCB0ZXN0IHByb3BlcnR5OicsIG1pbkRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IG1pbkRhdGEsXG4gICAgICAgICAgaW5mbzogJ0NyZWF0ZWQgd2l0aCBtaW5pbWFsIGZpZWxkcyBvbmx5J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1Rlc3QgcHJvcGVydHkgY3JlYXRlZDonLCBkYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGluZm86ICdDcmVhdGVkIHdpdGggZnVsbCBmaWVsZHMnXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlVGVzdFByb3BlcnR5OicsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdXBhYmFzZTsgIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiY29uc29sZSIsImVycm9yIiwic3VwYWJhc2UiLCJhdXRoIiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwiZ2V0Q3VycmVudFVzZXIiLCJkYXRhIiwidXNlciIsImdldFVzZXIiLCJzaWduVXAiLCJlbWFpbCIsInBhc3N3b3JkIiwic2lnbkluIiwic2lnbkluV2l0aFBhc3N3b3JkIiwic2lnbk91dCIsImZldGNoUHJvcGVydGllcyIsIm9wdGlvbnMiLCJpbmNsdWRlUmVzZWFyY2giLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJmaWx0ZXJzIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIm9yIiwiZW5kc1dpdGgiLCJhY3R1YWxLZXkiLCJyZXBsYWNlIiwiZ3RlIiwibHRlIiwiZ3QiLCJsdCIsImlsaWtlIiwiZXEiLCJpbmNsdWRlSW5jb21wbGV0ZSIsIm5vdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibG9nIiwicGFnZSIsInBhZ2VTaXplIiwic3RhcnQiLCJlbmQiLCJyYW5nZSIsInNvcnRCeSIsInNvcnRBc2MiLCJ3YXJuIiwibGVuZ3RoIiwibm9ybWFsaXplZFByb3BlcnRpZXMiLCJtYXAiLCJwcm9wZXJ0eSIsInJlc2VhcmNoRGF0YSIsInByb3BlcnR5X3Jlc2VhcmNoIiwibm9ybWFsaXplZFByb3BlcnR5Iiwibm9ybWFsaXplUHJvcGVydHkiLCJtb2R1bGVzIiwicHJvcGVydHlEZXRhaWxzIiwicHJvcGVydHlfZGV0YWlscyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiX2lzX2dyaWRfcGF0dGVybiIsIl9jb29yZGluYXRlc19mcm9tX3Jlc2VhcmNoIiwiX2Nvb3JkaW5hdGVzX21pc3NpbmciLCJfbmVlZHNfZ2VvY29kaW5nIiwiaWQiLCJfcmVzZWFyY2giLCJkZXB0aCIsInJlc2VhcmNoX2RlcHRoIiwiZGF0ZSIsInJlc2VhcmNoX2RhdGUiLCJzdW1tYXJ5IiwiZXhlY3V0aXZlX3N1bW1hcnkiLCJlIiwicHJvcGVydGllc1dpdGhDb29yZGluYXRlcyIsImZpbHRlciIsInAiLCJqb2luRXJyb3IiLCJub3JtYWxpemVkIiwidW5pdHMiLCJudW1fdW5pdHMiLCJuYW1lIiwidHJpbSIsImFkZHJlc3MiLCJzcGxpdCIsInN1YnN0cmluZyIsInN0YXR1cyIsInByb3BlcnR5X3N0YXR1cyIsIl9pc190ZXN0X3Byb3BlcnR5IiwiaXNUZXN0UHJvcGVydHkiLCJpc1ZhbGlkTGF0aXR1ZGUiLCJpc1ZhbGlkTG9uZ2l0dWRlIiwiaXNJbkF1c3RpbkFyZWEiLCJsYXRTdHIiLCJTdHJpbmciLCJsbmdTdHIiLCJoYXNMb3dQcmVjaXNpb24iLCJpbmNsdWRlcyIsImhhc1N1c3BpY2lvdXNQYXR0ZXJuIiwiaXNHcmlkUGF0dGVybiIsIl9pc19pbnZhbGlkX3JhbmdlIiwiX291dHNpZGVfYXVzdGluIiwidG9Mb3dlckNhc2UiLCJ0ZXN0SW5kaWNhdG9ycyIsImluZGljYXRvciIsInByaWNlIiwicGxhY2Vob2xkZXJJbmRpY2F0b3JzIiwiY3JlYXRlVGVzdFByb3BlcnR5Iiwic2FtcGxlUHJvcGVydHkiLCJzYW1wbGVFcnJvciIsImxpbWl0IiwiYmFzZVRlc3RQcm9wZXJ0eSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwiY2l0eSIsInN0YXRlIiwiemlwX2NvZGUiLCJ5ZWFyX2J1aWx0IiwicHJvcGVydHlfdHlwZSIsImRlc2NyaXB0aW9uIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJ0ZXN0UHJvcGVydHkiLCJzYW1wbGUiLCJhZGFwdGVkUHJvcGVydHkiLCJrZXlzIiwiaW5zZXJ0IiwibWVzc2FnZSIsIm1pbmltYWxQcm9wZXJ0eSIsIm1pbkRhdGEiLCJtaW5FcnJvciIsImluZm8iLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/supabase.js\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/map",{

/***/ "./lib/geocoding.js":
/*!**************************!*\
  !*** ./lib/geocoding.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkResearchTableExists: function() { return /* binding */ checkResearchTableExists; },\n/* harmony export */   enhancedGeocodeProperties: function() { return /* binding */ enhancedGeocodeProperties; },\n/* harmony export */   geocodeProperties: function() { return /* binding */ geocodeProperties; },\n/* harmony export */   isGridPattern: function() { return /* binding */ isGridPattern; },\n/* harmony export */   syncResearchCoordinates: function() { return /* binding */ syncResearchCoordinates; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"./lib/supabase.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../../../node_modules/process/browser.js\");\n/**\n * Geocoding utilities for the frontend\n * \n * This module provides tools for:\n * 1. Client-side geocoding using Google Maps, Mapbox, or Nominatim (fallback)\n * 2. Utilities for coordinate validation and processing\n * 3. Functions to synchronize coordinates between properties and property_research\n */ \n/**\n * Geocode a batch of properties\n * \n * @param {Array} properties - Array of property objects\n * @returns {Promise<Array>} - Properties with coordinates added\n */ async function geocodeProperties(properties) {\n    // Filter properties that need geocoding\n    const needsGeocoding = properties.filter((p)=>(p._needs_geocoding || !p.latitude || !p.longitude || p._coordinates_missing || p._is_grid_pattern) && (p.address || p.city && p.state));\n    if (needsGeocoding.length === 0) {\n        console.log(\"No properties need geocoding\");\n        return properties;\n    }\n    console.log(\"Geocoding \".concat(needsGeocoding.length, \" properties\"));\n    // Try to use Google Maps API if available\n    const googleMapsAvailable = typeof google !== \"undefined\" && google.maps && google.maps.Geocoder;\n    // Use Mapbox if available\n    const mapboxToken = process.env.NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN;\n    // Geocode each property\n    const geocodedProperties = await Promise.all(properties.map(async (property)=>{\n        // Skip properties that don't need geocoding\n        if (!property._needs_geocoding && property.latitude && property.longitude && !property._coordinates_missing && !property._is_grid_pattern || !property.address && (!property.city || !property.state)) {\n            return property;\n        }\n        // Create a copy to avoid mutating the original\n        const geocodedProperty = {\n            ...property\n        };\n        try {\n            let coordinates = null;\n            // Try Google Maps API first if available\n            if (googleMapsAvailable) {\n                coordinates = await geocodeWithGoogleMaps(property);\n            }\n            // If Google Maps failed or is not available, try Mapbox\n            if (!coordinates && mapboxToken) {\n                coordinates = await geocodeWithMapbox(property, mapboxToken);\n            }\n            // If both failed, try Nominatim as a last resort\n            if (!coordinates) {\n                coordinates = await geocodeWithNominatim(property);\n            }\n            // If we got coordinates, update the property\n            if (coordinates) {\n                geocodedProperty.latitude = coordinates.latitude;\n                geocodedProperty.longitude = coordinates.longitude;\n                geocodedProperty._geocoded = true;\n                geocodedProperty._coordinates_missing = false;\n                geocodedProperty._needs_geocoding = false;\n                geocodedProperty._is_grid_pattern = false;\n                console.log(\"Geocoded \".concat(property.address || property.city, \", \").concat(property.state, \": \").concat(coordinates.latitude, \", \").concat(coordinates.longitude));\n            } else {\n                console.warn(\"Failed to geocode \".concat(property.address || property.city, \", \").concat(property.state));\n            }\n        } catch (error) {\n            console.error(\"Geocoding error for \".concat(property.address || property.city, \", \").concat(property.state, \":\"), error);\n        }\n        return geocodedProperty;\n    }));\n    return geocodedProperties;\n}\n/**\n * Geocode a property using Google Maps API\n * \n * @param {Object} property - Property object with address information\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithGoogleMaps(property) {\n    return new Promise((resolve)=>{\n        try {\n            const geocoder = new google.maps.Geocoder();\n            // Build address string\n            let addressString = \"\";\n            if (property.address) addressString += property.address;\n            if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n            if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n            if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n            geocoder.geocode({\n                address: addressString\n            }, (results, status)=>{\n                if (status === \"OK\" && results[0] && results[0].geometry) {\n                    const latitude = results[0].geometry.location.lat();\n                    const longitude = results[0].geometry.location.lng();\n                    // Check for suspicious patterns\n                    if (isGridPattern(latitude, longitude)) {\n                        console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                        resolve(null);\n                    } else {\n                        resolve({\n                            latitude,\n                            longitude,\n                            provider: \"google\"\n                        });\n                    }\n                } else {\n                    console.warn(\"Google geocoding failed: \".concat(status));\n                    resolve(null);\n                }\n            });\n        } catch (error) {\n            console.error(\"Error with Google geocoding:\", error);\n            resolve(null);\n        }\n    });\n}\n/**\n * Geocode a property using Mapbox API\n * \n * @param {Object} property - Property object with address information\n * @param {string} accessToken - Mapbox access token\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithMapbox(property, accessToken) {\n    try {\n        // Build address string\n        let addressString = \"\";\n        if (property.address) addressString += property.address;\n        if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n        if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n        if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n        // URL encode the address\n        const encodedAddress = encodeURIComponent(addressString);\n        // Make API request\n        const response = await fetch(\"https://api.mapbox.com/geocoding/v5/mapbox.places/\".concat(encodedAddress, \".json?access_token=\").concat(accessToken));\n        if (!response.ok) {\n            throw new Error(\"Mapbox API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        if (data.features && data.features.length > 0) {\n            const feature = data.features[0];\n            const longitude = feature.center[0];\n            const latitude = feature.center[1];\n            // Check for suspicious patterns\n            if (isGridPattern(latitude, longitude)) {\n                console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                return null;\n            }\n            return {\n                latitude,\n                longitude,\n                provider: \"mapbox\"\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error with Mapbox geocoding:\", error);\n        return null;\n    }\n}\n/**\n * Geocode a property using Nominatim API (OpenStreetMap)\n * \n * @param {Object} property - Property object with address information\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithNominatim(property) {\n    try {\n        // Build address string\n        let addressString = \"\";\n        if (property.address) addressString += property.address;\n        if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n        if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n        if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n        // URL encode the address\n        const encodedAddress = encodeURIComponent(addressString);\n        // Make API request (with a random delay to avoid rate limiting)\n        const response = await fetch(\"https://nominatim.openstreetmap.org/search?format=json&q=\".concat(encodedAddress), {\n            headers: {\n                \"User-Agent\": \"AcquirePropertyMap/1.0\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Nominatim API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        if (data && data.length > 0) {\n            const result = data[0];\n            const latitude = parseFloat(result.lat);\n            const longitude = parseFloat(result.lon);\n            // Check for suspicious patterns\n            if (isGridPattern(latitude, longitude)) {\n                console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                return null;\n            }\n            return {\n                latitude,\n                longitude,\n                provider: \"nominatim\"\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error with Nominatim geocoding:\", error);\n        return null;\n    }\n}\n/**\n * Check if coordinates are likely part of a grid pattern\n * \n * @param {number} latitude - Latitude coordinate\n * @param {number} longitude - Longitude coordinate\n * @returns {boolean} - True if likely a grid pattern, false otherwise\n */ function isGridPattern(latitude, longitude) {\n    if (!latitude || !longitude) return false;\n    // Convert to strings for easier checking\n    const latStr = String(latitude);\n    const lngStr = String(longitude);\n    // Check for very low precision coordinates (often grid patterns)\n    const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 3 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 3;\n    // Check for suspicious patterns\n    const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".5\") || // Common grid values\n    lngStr.endsWith(\".5\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\");\n    return hasLowPrecision || hasSuspiciousPattern;\n}\n/**\n * Check if the property_research table exists in Supabase\n * \n * @returns {Promise<boolean>} - True if table exists, false otherwise\n */ async function checkResearchTableExists() {\n    try {\n        // Attempt to query the table\n        const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").select(\"id\").limit(1);\n        // If no error, table exists\n        return !error;\n    } catch (error) {\n        console.error(\"Error checking research table:\", error);\n        return false;\n    }\n}\n/**\n * Synchronize coordinates between properties and property_research tables\n * \n * @param {number} limit - Maximum number of properties to process\n * @returns {Promise<Object>} - Result object with success status and counts\n */ async function syncResearchCoordinates() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n    try {\n        // Check if table exists\n        const tableExists = await checkResearchTableExists();\n        if (!tableExists) {\n            return {\n                success: false,\n                message: \"Property research table does not exist or is not accessible\",\n                updated: 0,\n                errors: 0\n            };\n        }\n        // Get properties missing or with suspicious coordinates\n        const { data: properties, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"properties\").select(\"id, address, city, state, zip_code, latitude, longitude\").limit(limit);\n        if (error) {\n            throw new Error(\"Error fetching properties: \".concat(error.message));\n        }\n        if (!properties || properties.length === 0) {\n            return {\n                success: true,\n                message: \"No properties found to synchronize\",\n                updated: 0,\n                errors: 0\n            };\n        }\n        // Synchronize each property\n        let updated = 0;\n        let errors = 0;\n        for (const property of properties){\n            try {\n                // If property has valid coordinates, update property_research\n                if (property.latitude && property.longitude && !isGridPattern(property.latitude, property.longitude)) {\n                    // Get property_research record\n                    const { data: research, error: researchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").select(\"id, modules\").eq(\"property_id\", property.id);\n                    if (researchError) {\n                        console.error(\"Error fetching research for property \".concat(property.id, \":\"), researchError);\n                        errors++;\n                        continue;\n                    }\n                    if (research && research.length > 0) {\n                        // Update modules with coordinates\n                        const researchRecord = research[0];\n                        let modules = researchRecord.modules || {};\n                        // Create property_details if it doesn't exist\n                        if (!modules.property_details) {\n                            modules.property_details = {};\n                        }\n                        // Update coordinates\n                        modules.property_details.latitude = property.latitude;\n                        modules.property_details.longitude = property.longitude;\n                        modules.property_details.address = property.address;\n                        modules.property_details.city = property.city;\n                        modules.property_details.state = property.state;\n                        modules.property_details.zip_code = property.zip_code;\n                        // Update property_research\n                        const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").update({\n                            modules\n                        }).eq(\"id\", researchRecord.id);\n                        if (updateError) {\n                            console.error(\"Error updating research for property \".concat(property.id, \":\"), updateError);\n                            errors++;\n                        } else {\n                            updated++;\n                        }\n                    }\n                }\n            } catch (propertyError) {\n                console.error(\"Error processing property \".concat(property.id, \":\"), propertyError);\n                errors++;\n            }\n        }\n        return {\n            success: true,\n            message: \"Synchronized \".concat(updated, \" properties with \").concat(errors, \" errors\"),\n            updated,\n            errors\n        };\n    } catch (error) {\n        console.error(\"Error in syncResearchCoordinates:\", error);\n        return {\n            success: false,\n            message: error.message || \"Unknown error occurred\",\n            updated: 0,\n            errors: 1\n        };\n    }\n}\n/**\n * Enhanced batch geocoding function that attempts multiple methods of geocoding\n * @param {Array} properties Array of properties to geocode\n * @param {Function} progressCallback Optional callback function (property, status, details) => {}\n * @returns {Array} Updated properties with geocoding results\n */ async function enhancedGeocodeProperties(properties) {\n    let progressCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    if (!Array.isArray(properties) || properties.length === 0) {\n        return [];\n    }\n    // Create a deep copy of the properties to avoid mutating the originals\n    const propertiesCopy = JSON.parse(JSON.stringify(properties));\n    // Process each property\n    for(let i = 0; i < propertiesCopy.length; i++){\n        const property = propertiesCopy[i];\n        try {\n            // Skip properties that already have valid coordinates\n            if (property.latitude && property.longitude && property.latitude !== 0 && property.longitude !== 0 && !property._needs_geocoding && !property._coordinates_missing && !property._is_grid_pattern) {\n                // Mark as having existing valid coordinates\n                property._geocoding_source = \"existing\";\n                property._geocoded = true;\n                if (progressCallback) {\n                    progressCallback(property, \"skipped\", \"already has valid coordinates\");\n                }\n                continue;\n            }\n            if (progressCallback) {\n                progressCallback(property, \"processing\", \"starting geocoding process\");\n            }\n            // First, try geocoding with verified address if available\n            if (property.verified_address) {\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using verified address\");\n                }\n                const geocodeResult = await geocodeAddress(property.verified_address);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"verified_address\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"verified address geocoded\");\n                    }\n                    continue;\n                }\n            }\n            // Next, try with the full address\n            if (property.address) {\n                let fullAddress = property.address;\n                // Add city, state if they exist and aren't already in the address\n                if (property.city && !fullAddress.includes(property.city)) {\n                    fullAddress += \", \".concat(property.city);\n                }\n                if (property.state && !fullAddress.includes(property.state)) {\n                    fullAddress += \", \".concat(property.state);\n                }\n                // Add zip code if available and not already in the address\n                if (property.zip && !fullAddress.includes(property.zip)) {\n                    fullAddress += \" \".concat(property.zip);\n                }\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using full address\");\n                }\n                const geocodeResult = await geocodeAddress(fullAddress);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"full_address\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"full address geocoded\");\n                    }\n                    continue;\n                }\n            }\n            // If all else fails, try geocoding based on the property name\n            // This is a last resort and might not be accurate\n            if (property.name) {\n                // Format the name for geocoding\n                // Add \"Austin, TX\" since most properties are in Austin\n                const searchTerm = \"\".concat(property.name, \", \").concat(property.city || \"Austin\", \", \").concat(property.state || \"TX\");\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using property name as last resort\");\n                }\n                const geocodeResult = await geocodeAddress(searchTerm);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"property_name\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    // Still mark these as potentially grid pattern since they're less reliable\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"property name geocoded (less accurate)\");\n                    }\n                    continue;\n                }\n            }\n            // If we get here, all geocoding attempts failed\n            property._geocoding_failed = true;\n            if (progressCallback) {\n                progressCallback(property, \"error\", \"all geocoding methods failed\");\n            }\n        } catch (error) {\n            console.error(\"Error geocoding property \".concat(property.id, \":\"), error);\n            property._geocoding_failed = true;\n            if (progressCallback) {\n                progressCallback(property, \"error\", error.message);\n            }\n        }\n    }\n    return propertiesCopy;\n}\n/**\n * Helper function to check if a property has valid coordinates\n */ const hasValidCoordinates = (property)=>{\n    if (!property) return false;\n    if (!property.latitude || !property.longitude) return false;\n    // Convert to numbers if needed\n    const lat = typeof property.latitude === \"number\" ? property.latitude : parseFloat(String(property.latitude));\n    const lng = typeof property.longitude === \"number\" ? property.longitude : parseFloat(String(property.longitude));\n    // Check for NaN\n    if (isNaN(lat) || isNaN(lng)) return false;\n    // Check for zero values (often default)\n    if (lat === 0 && lng === 0) return false;\n    // Check for reasonable coordinate ranges\n    if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return false;\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUc7WUFDN0IsSUFBSW5CLGtCQUFrQjtnQkFDcEJBLGlCQUFpQnBFLFVBQVUsU0FBUztZQUN0QztRQUVGLEVBQUUsT0FBT1EsT0FBTztZQUNkdEIsUUFBUXNCLEtBQUssQ0FBQyw0QkFBd0MsT0FBWlIsU0FBUzRELEVBQUUsRUFBQyxNQUFJcEQ7WUFDMURSLFNBQVN1RixpQkFBaUIsR0FBRztZQUU3QixJQUFJbkIsa0JBQWtCO2dCQUNwQkEsaUJBQWlCcEUsVUFBVSxTQUFTUSxNQUFNOEMsT0FBTztZQUNuRDtRQUNGO0lBQ0Y7SUFFQSxPQUFPaUI7QUFDVDtBQUVBOztDQUVDLEdBQ0QsTUFBTWlCLHNCQUFzQixDQUFDeEY7SUFDM0IsSUFBSSxDQUFDQSxVQUFVLE9BQU87SUFFdEIsSUFBSSxDQUFDQSxTQUFTdEIsUUFBUSxJQUFJLENBQUNzQixTQUFTckIsU0FBUyxFQUFFLE9BQU87SUFFdEQsK0JBQStCO0lBQy9CLE1BQU11QyxNQUFNLE9BQU9sQixTQUFTdEIsUUFBUSxLQUFLLFdBQVdzQixTQUFTdEIsUUFBUSxHQUFHMkQsV0FBV0csT0FBT3hDLFNBQVN0QixRQUFRO0lBQzNHLE1BQU15QyxNQUFNLE9BQU9uQixTQUFTckIsU0FBUyxLQUFLLFdBQVdxQixTQUFTckIsU0FBUyxHQUFHMEQsV0FBV0csT0FBT3hDLFNBQVNyQixTQUFTO0lBRTlHLGdCQUFnQjtJQUNoQixJQUFJOEcsTUFBTXZFLFFBQVF1RSxNQUFNdEUsTUFBTSxPQUFPO0lBRXJDLHdDQUF3QztJQUN4QyxJQUFJRCxRQUFRLEtBQUtDLFFBQVEsR0FBRyxPQUFPO0lBRW5DLHlDQUF5QztJQUN6QyxJQUFJRCxNQUFNLENBQUMsTUFBTUEsTUFBTSxNQUFNQyxNQUFNLENBQUMsT0FBT0EsTUFBTSxLQUFLLE9BQU87SUFFN0QsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nZW9jb2RpbmcuanM/NmNkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdlb2NvZGluZyB1dGlsaXRpZXMgZm9yIHRoZSBmcm9udGVuZFxuICogXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0b29scyBmb3I6XG4gKiAxLiBDbGllbnQtc2lkZSBnZW9jb2RpbmcgdXNpbmcgR29vZ2xlIE1hcHMsIE1hcGJveCwgb3IgTm9taW5hdGltIChmYWxsYmFjaylcbiAqIDIuIFV0aWxpdGllcyBmb3IgY29vcmRpbmF0ZSB2YWxpZGF0aW9uIGFuZCBwcm9jZXNzaW5nXG4gKiAzLiBGdW5jdGlvbnMgdG8gc3luY2hyb25pemUgY29vcmRpbmF0ZXMgYmV0d2VlbiBwcm9wZXJ0aWVzIGFuZCBwcm9wZXJ0eV9yZXNlYXJjaFxuICovXG5cbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSc7XG5cbi8qKlxuICogR2VvY29kZSBhIGJhdGNoIG9mIHByb3BlcnRpZXNcbiAqIFxuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyAtIEFycmF5IG9mIHByb3BlcnR5IG9iamVjdHNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gLSBQcm9wZXJ0aWVzIHdpdGggY29vcmRpbmF0ZXMgYWRkZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlb2NvZGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgLy8gRmlsdGVyIHByb3BlcnRpZXMgdGhhdCBuZWVkIGdlb2NvZGluZ1xuICBjb25zdCBuZWVkc0dlb2NvZGluZyA9IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gXG4gICAgKHAuX25lZWRzX2dlb2NvZGluZyB8fCAhcC5sYXRpdHVkZSB8fCAhcC5sb25naXR1ZGUgfHwgcC5fY29vcmRpbmF0ZXNfbWlzc2luZyB8fCBwLl9pc19ncmlkX3BhdHRlcm4pICYmXG4gICAgKHAuYWRkcmVzcyB8fCAocC5jaXR5ICYmIHAuc3RhdGUpKVxuICApO1xuICBcbiAgaWYgKG5lZWRzR2VvY29kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUubG9nKCdObyBwcm9wZXJ0aWVzIG5lZWQgZ2VvY29kaW5nJyk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKGBHZW9jb2RpbmcgJHtuZWVkc0dlb2NvZGluZy5sZW5ndGh9IHByb3BlcnRpZXNgKTtcbiAgXG4gIC8vIFRyeSB0byB1c2UgR29vZ2xlIE1hcHMgQVBJIGlmIGF2YWlsYWJsZVxuICBjb25zdCBnb29nbGVNYXBzQXZhaWxhYmxlID0gdHlwZW9mIGdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5HZW9jb2RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIC8vIFVzZSBNYXBib3ggaWYgYXZhaWxhYmxlXG4gIGNvbnN0IG1hcGJveFRva2VuID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUFQQk9YX0FDQ0VTU19UT0tFTjtcbiAgXG4gIC8vIEdlb2NvZGUgZWFjaCBwcm9wZXJ0eVxuICBjb25zdCBnZW9jb2RlZFByb3BlcnRpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBwcm9wZXJ0aWVzLm1hcChhc3luYyAocHJvcGVydHkpID0+IHtcbiAgICAgIC8vIFNraXAgcHJvcGVydGllcyB0aGF0IGRvbid0IG5lZWQgZ2VvY29kaW5nXG4gICAgICBpZiAoKCFwcm9wZXJ0eS5fbmVlZHNfZ2VvY29kaW5nICYmIHByb3BlcnR5LmxhdGl0dWRlICYmIHByb3BlcnR5LmxvbmdpdHVkZSAmJiBcbiAgICAgICAgICAgIXByb3BlcnR5Ll9jb29yZGluYXRlc19taXNzaW5nICYmICFwcm9wZXJ0eS5faXNfZ3JpZF9wYXR0ZXJuKSB8fFxuICAgICAgICAgICghcHJvcGVydHkuYWRkcmVzcyAmJiAoIXByb3BlcnR5LmNpdHkgfHwgIXByb3BlcnR5LnN0YXRlKSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgY29uc3QgZ2VvY29kZWRQcm9wZXJ0eSA9IHsgLi4ucHJvcGVydHkgfTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBHb29nbGUgTWFwcyBBUEkgZmlyc3QgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChnb29nbGVNYXBzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBhd2FpdCBnZW9jb2RlV2l0aEdvb2dsZU1hcHMocHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBHb29nbGUgTWFwcyBmYWlsZWQgb3IgaXMgbm90IGF2YWlsYWJsZSwgdHJ5IE1hcGJveFxuICAgICAgICBpZiAoIWNvb3JkaW5hdGVzICYmIG1hcGJveFRva2VuKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBhd2FpdCBnZW9jb2RlV2l0aE1hcGJveChwcm9wZXJ0eSwgbWFwYm94VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBib3RoIGZhaWxlZCwgdHJ5IE5vbWluYXRpbSBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGF3YWl0IGdlb2NvZGVXaXRoTm9taW5hdGltKHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZ290IGNvb3JkaW5hdGVzLCB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAgICAgIGlmIChjb29yZGluYXRlcykge1xuICAgICAgICAgIGdlb2NvZGVkUHJvcGVydHkubGF0aXR1ZGUgPSBjb29yZGluYXRlcy5sYXRpdHVkZTtcbiAgICAgICAgICBnZW9jb2RlZFByb3BlcnR5LmxvbmdpdHVkZSA9IGNvb3JkaW5hdGVzLmxvbmdpdHVkZTtcbiAgICAgICAgICBnZW9jb2RlZFByb3BlcnR5Ll9nZW9jb2RlZCA9IHRydWU7XG4gICAgICAgICAgZ2VvY29kZWRQcm9wZXJ0eS5fY29vcmRpbmF0ZXNfbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgIGdlb2NvZGVkUHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGdlb2NvZGVkUHJvcGVydHkuX2lzX2dyaWRfcGF0dGVybiA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBHZW9jb2RlZCAke3Byb3BlcnR5LmFkZHJlc3MgfHwgcHJvcGVydHkuY2l0eX0sICR7cHJvcGVydHkuc3RhdGV9OiAke2Nvb3JkaW5hdGVzLmxhdGl0dWRlfSwgJHtjb29yZGluYXRlcy5sb25naXR1ZGV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZ2VvY29kZSAke3Byb3BlcnR5LmFkZHJlc3MgfHwgcHJvcGVydHkuY2l0eX0sICR7cHJvcGVydHkuc3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEdlb2NvZGluZyBlcnJvciBmb3IgJHtwcm9wZXJ0eS5hZGRyZXNzIHx8IHByb3BlcnR5LmNpdHl9LCAke3Byb3BlcnR5LnN0YXRlfTpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBnZW9jb2RlZFByb3BlcnR5O1xuICAgIH0pXG4gICk7XG4gIFxuICByZXR1cm4gZ2VvY29kZWRQcm9wZXJ0aWVzO1xufVxuXG4vKipcbiAqIEdlb2NvZGUgYSBwcm9wZXJ0eSB1c2luZyBHb29nbGUgTWFwcyBBUElcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IC0gUHJvcGVydHkgb2JqZWN0IHdpdGggYWRkcmVzcyBpbmZvcm1hdGlvblxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSAtIENvb3JkaW5hdGVzIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZW9jb2RlV2l0aEdvb2dsZU1hcHMocHJvcGVydHkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG4gICAgICBcbiAgICAgIC8vIEJ1aWxkIGFkZHJlc3Mgc3RyaW5nXG4gICAgICBsZXQgYWRkcmVzc1N0cmluZyA9ICcnO1xuICAgICAgaWYgKHByb3BlcnR5LmFkZHJlc3MpIGFkZHJlc3NTdHJpbmcgKz0gcHJvcGVydHkuYWRkcmVzcztcbiAgICAgIGlmIChwcm9wZXJ0eS5jaXR5KSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LmNpdHk7XG4gICAgICBpZiAocHJvcGVydHkuc3RhdGUpIGFkZHJlc3NTdHJpbmcgKz0gKGFkZHJlc3NTdHJpbmcgPyAnLCAnIDogJycpICsgcHJvcGVydHkuc3RhdGU7XG4gICAgICBpZiAocHJvcGVydHkuemlwX2NvZGUpIGFkZHJlc3NTdHJpbmcgKz0gKGFkZHJlc3NTdHJpbmcgPyAnICcgOiAnJykgKyBwcm9wZXJ0eS56aXBfY29kZTtcbiAgICAgIFxuICAgICAgZ2VvY29kZXIuZ2VvY29kZSh7IGFkZHJlc3M6IGFkZHJlc3NTdHJpbmcgfSwgKHJlc3VsdHMsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnT0snICYmIHJlc3VsdHNbMF0gJiYgcmVzdWx0c1swXS5nZW9tZXRyeSkge1xuICAgICAgICAgIGNvbnN0IGxhdGl0dWRlID0gcmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKTtcbiAgICAgICAgICBjb25zdCBsb25naXR1ZGUgPSByZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgICAgICAgaWYgKGlzR3JpZFBhdHRlcm4obGF0aXR1ZGUsIGxvbmdpdHVkZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU3VzcGljaW91cyBncmlkIHBhdHRlcm4gZGV0ZWN0ZWQ6ICR7bGF0aXR1ZGV9LCAke2xvbmdpdHVkZX1gKTtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICAgICAgICBwcm92aWRlcjogJ2dvb2dsZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEdvb2dsZSBnZW9jb2RpbmcgZmFpbGVkOiAke3N0YXR1c31gKTtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCBHb29nbGUgZ2VvY29kaW5nOicsIGVycm9yKTtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZW9jb2RlIGEgcHJvcGVydHkgdXNpbmcgTWFwYm94IEFQSVxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydHkgLSBQcm9wZXJ0eSBvYmplY3Qgd2l0aCBhZGRyZXNzIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gLSBNYXBib3ggYWNjZXNzIHRva2VuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IC0gQ29vcmRpbmF0ZXMgb2JqZWN0IG9yIG51bGwgaWYgZmFpbGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlb2NvZGVXaXRoTWFwYm94KHByb3BlcnR5LCBhY2Nlc3NUb2tlbikge1xuICB0cnkge1xuICAgIC8vIEJ1aWxkIGFkZHJlc3Mgc3RyaW5nXG4gICAgbGV0IGFkZHJlc3NTdHJpbmcgPSAnJztcbiAgICBpZiAocHJvcGVydHkuYWRkcmVzcykgYWRkcmVzc1N0cmluZyArPSBwcm9wZXJ0eS5hZGRyZXNzO1xuICAgIGlmIChwcm9wZXJ0eS5jaXR5KSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LmNpdHk7XG4gICAgaWYgKHByb3BlcnR5LnN0YXRlKSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LnN0YXRlO1xuICAgIGlmIChwcm9wZXJ0eS56aXBfY29kZSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcgJyA6ICcnKSArIHByb3BlcnR5LnppcF9jb2RlO1xuICAgIFxuICAgIC8vIFVSTCBlbmNvZGUgdGhlIGFkZHJlc3NcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzcyA9IGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzU3RyaW5nKTtcbiAgICBcbiAgICAvLyBNYWtlIEFQSSByZXF1ZXN0XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2FwaS5tYXBib3guY29tL2dlb2NvZGluZy92NS9tYXBib3gucGxhY2VzLyR7ZW5jb2RlZEFkZHJlc3N9Lmpzb24/YWNjZXNzX3Rva2VuPSR7YWNjZXNzVG9rZW59YFxuICAgICk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXBib3ggQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmIChkYXRhLmZlYXR1cmVzICYmIGRhdGEuZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmVhdHVyZSA9IGRhdGEuZmVhdHVyZXNbMF07XG4gICAgICBjb25zdCBsb25naXR1ZGUgPSBmZWF0dXJlLmNlbnRlclswXTtcbiAgICAgIGNvbnN0IGxhdGl0dWRlID0gZmVhdHVyZS5jZW50ZXJbMV07XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgICBpZiAoaXNHcmlkUGF0dGVybihsYXRpdHVkZSwgbG9uZ2l0dWRlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFN1c3BpY2lvdXMgZ3JpZCBwYXR0ZXJuIGRldGVjdGVkOiAke2xhdGl0dWRlfSwgJHtsb25naXR1ZGV9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBwcm92aWRlcjogJ21hcGJveCdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdpdGggTWFwYm94IGdlb2NvZGluZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW9jb2RlIGEgcHJvcGVydHkgdXNpbmcgTm9taW5hdGltIEFQSSAoT3BlblN0cmVldE1hcClcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IC0gUHJvcGVydHkgb2JqZWN0IHdpdGggYWRkcmVzcyBpbmZvcm1hdGlvblxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSAtIENvb3JkaW5hdGVzIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZW9jb2RlV2l0aE5vbWluYXRpbShwcm9wZXJ0eSkge1xuICB0cnkge1xuICAgIC8vIEJ1aWxkIGFkZHJlc3Mgc3RyaW5nXG4gICAgbGV0IGFkZHJlc3NTdHJpbmcgPSAnJztcbiAgICBpZiAocHJvcGVydHkuYWRkcmVzcykgYWRkcmVzc1N0cmluZyArPSBwcm9wZXJ0eS5hZGRyZXNzO1xuICAgIGlmIChwcm9wZXJ0eS5jaXR5KSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LmNpdHk7XG4gICAgaWYgKHByb3BlcnR5LnN0YXRlKSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LnN0YXRlO1xuICAgIGlmIChwcm9wZXJ0eS56aXBfY29kZSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcgJyA6ICcnKSArIHByb3BlcnR5LnppcF9jb2RlO1xuICAgIFxuICAgIC8vIFVSTCBlbmNvZGUgdGhlIGFkZHJlc3NcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzcyA9IGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzU3RyaW5nKTtcbiAgICBcbiAgICAvLyBNYWtlIEFQSSByZXF1ZXN0ICh3aXRoIGEgcmFuZG9tIGRlbGF5IHRvIGF2b2lkIHJhdGUgbGltaXRpbmcpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL25vbWluYXRpbS5vcGVuc3RyZWV0bWFwLm9yZy9zZWFyY2g/Zm9ybWF0PWpzb24mcT0ke2VuY29kZWRBZGRyZXNzfWAsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdBY3F1aXJlUHJvcGVydHlNYXAvMS4wJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbWluYXRpbSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgbGF0aXR1ZGUgPSBwYXJzZUZsb2F0KHJlc3VsdC5sYXQpO1xuICAgICAgY29uc3QgbG9uZ2l0dWRlID0gcGFyc2VGbG9hdChyZXN1bHQubG9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgICAgIGlmIChpc0dyaWRQYXR0ZXJuKGxhdGl0dWRlLCBsb25naXR1ZGUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU3VzcGljaW91cyBncmlkIHBhdHRlcm4gZGV0ZWN0ZWQ6ICR7bGF0aXR1ZGV9LCAke2xvbmdpdHVkZX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIHByb3ZpZGVyOiAnbm9taW5hdGltJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCBOb21pbmF0aW0gZ2VvY29kaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGNvb3JkaW5hdGVzIGFyZSBsaWtlbHkgcGFydCBvZiBhIGdyaWQgcGF0dGVyblxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGUgLSBMYXRpdHVkZSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG9uZ2l0dWRlIC0gTG9uZ2l0dWRlIGNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgbGlrZWx5IGEgZ3JpZCBwYXR0ZXJuLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JpZFBhdHRlcm4obGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICBpZiAoIWxhdGl0dWRlIHx8ICFsb25naXR1ZGUpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIENvbnZlcnQgdG8gc3RyaW5ncyBmb3IgZWFzaWVyIGNoZWNraW5nXG4gIGNvbnN0IGxhdFN0ciA9IFN0cmluZyhsYXRpdHVkZSk7XG4gIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhsb25naXR1ZGUpO1xuICBcbiAgLy8gQ2hlY2sgZm9yIHZlcnkgbG93IHByZWNpc2lvbiBjb29yZGluYXRlcyAob2Z0ZW4gZ3JpZCBwYXR0ZXJucylcbiAgY29uc3QgaGFzTG93UHJlY2lzaW9uID0gXG4gICAgKGxhdFN0ci5pbmNsdWRlcygnLicpICYmIGxhdFN0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAzKSB8fFxuICAgIChsbmdTdHIuaW5jbHVkZXMoJy4nKSAmJiBsbmdTdHIuc3BsaXQoJy4nKVsxXS5sZW5ndGggPD0gMyk7XG4gICAgXG4gIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gIGNvbnN0IGhhc1N1c3BpY2lvdXNQYXR0ZXJuID0gXG4gICAgbGF0U3RyID09PSBsbmdTdHIgfHwgLy8gU2FtZSBsYXQvbG5nIGlzIHZlcnkgdW5saWtlbHlcbiAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgbG5nU3RyLmVuZHNXaXRoKCcwMDAwMCcpIHx8XG4gICAgbGF0U3RyLmVuZHNXaXRoKCcuNScpIHx8IC8vIENvbW1vbiBncmlkIHZhbHVlc1xuICAgIGxuZ1N0ci5lbmRzV2l0aCgnLjUnKSB8fFxuICAgIGxhdFN0ci5lbmRzV2l0aCgnLjAnKSB8fFxuICAgIGxuZ1N0ci5lbmRzV2l0aCgnLjAnKTtcbiAgICBcbiAgcmV0dXJuIGhhc0xvd1ByZWNpc2lvbiB8fCBoYXNTdXNwaWNpb3VzUGF0dGVybjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvcGVydHlfcmVzZWFyY2ggdGFibGUgZXhpc3RzIGluIFN1cGFiYXNlXG4gKiBcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSAtIFRydWUgaWYgdGFibGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVzZWFyY2hUYWJsZUV4aXN0cygpIHtcbiAgdHJ5IHtcbiAgICAvLyBBdHRlbXB0IHRvIHF1ZXJ5IHRoZSB0YWJsZVxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncHJvcGVydHlfcmVzZWFyY2gnKVxuICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgLmxpbWl0KDEpO1xuICAgIFxuICAgIC8vIElmIG5vIGVycm9yLCB0YWJsZSBleGlzdHNcbiAgICByZXR1cm4gIWVycm9yO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHJlc2VhcmNoIHRhYmxlOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBTeW5jaHJvbml6ZSBjb29yZGluYXRlcyBiZXR3ZWVuIHByb3BlcnRpZXMgYW5kIHByb3BlcnR5X3Jlc2VhcmNoIHRhYmxlc1xuICogXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIHByb2Nlc3NcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gUmVzdWx0IG9iamVjdCB3aXRoIHN1Y2Nlc3Mgc3RhdHVzIGFuZCBjb3VudHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN5bmNSZXNlYXJjaENvb3JkaW5hdGVzKGxpbWl0ID0gMTAwKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgdGFibGUgZXhpc3RzXG4gICAgY29uc3QgdGFibGVFeGlzdHMgPSBhd2FpdCBjaGVja1Jlc2VhcmNoVGFibGVFeGlzdHMoKTtcbiAgICBpZiAoIXRhYmxlRXhpc3RzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ1Byb3BlcnR5IHJlc2VhcmNoIHRhYmxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlJyxcbiAgICAgICAgdXBkYXRlZDogMCxcbiAgICAgICAgZXJyb3JzOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgcHJvcGVydGllcyBtaXNzaW5nIG9yIHdpdGggc3VzcGljaW91cyBjb29yZGluYXRlc1xuICAgIGNvbnN0IHsgZGF0YTogcHJvcGVydGllcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgncHJvcGVydGllcycpXG4gICAgICAuc2VsZWN0KCdpZCwgYWRkcmVzcywgY2l0eSwgc3RhdGUsIHppcF9jb2RlLCBsYXRpdHVkZSwgbG9uZ2l0dWRlJylcbiAgICAgIC5saW1pdChsaW1pdCk7XG4gICAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgcHJvcGVydGllczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXByb3BlcnRpZXMgfHwgcHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG1lc3NhZ2U6ICdObyBwcm9wZXJ0aWVzIGZvdW5kIHRvIHN5bmNocm9uaXplJyxcbiAgICAgICAgdXBkYXRlZDogMCxcbiAgICAgICAgZXJyb3JzOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBTeW5jaHJvbml6ZSBlYWNoIHByb3BlcnR5XG4gICAgbGV0IHVwZGF0ZWQgPSAwO1xuICAgIGxldCBlcnJvcnMgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgcHJvcGVydHkgaGFzIHZhbGlkIGNvb3JkaW5hdGVzLCB1cGRhdGUgcHJvcGVydHlfcmVzZWFyY2hcbiAgICAgICAgaWYgKHByb3BlcnR5LmxhdGl0dWRlICYmIHByb3BlcnR5LmxvbmdpdHVkZSAmJiBcbiAgICAgICAgICAgICFpc0dyaWRQYXR0ZXJuKHByb3BlcnR5LmxhdGl0dWRlLCBwcm9wZXJ0eS5sb25naXR1ZGUpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHByb3BlcnR5X3Jlc2VhcmNoIHJlY29yZFxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzZWFyY2gsIGVycm9yOiByZXNlYXJjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3Byb3BlcnR5X3Jlc2VhcmNoJylcbiAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBtb2R1bGVzJylcbiAgICAgICAgICAgIC5lcSgncHJvcGVydHlfaWQnLCBwcm9wZXJ0eS5pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICBpZiAocmVzZWFyY2hFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcmVzZWFyY2ggZm9yIHByb3BlcnR5ICR7cHJvcGVydHkuaWR9OmAsIHJlc2VhcmNoRXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJlc2VhcmNoICYmIHJlc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtb2R1bGVzIHdpdGggY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGNvbnN0IHJlc2VhcmNoUmVjb3JkID0gcmVzZWFyY2hbMF07XG4gICAgICAgICAgICBsZXQgbW9kdWxlcyA9IHJlc2VhcmNoUmVjb3JkLm1vZHVsZXMgfHwge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9wZXJ0eV9kZXRhaWxzIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmICghbW9kdWxlcy5wcm9wZXJ0eV9kZXRhaWxzKSB7XG4gICAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy5sYXRpdHVkZSA9IHByb3BlcnR5LmxhdGl0dWRlO1xuICAgICAgICAgICAgbW9kdWxlcy5wcm9wZXJ0eV9kZXRhaWxzLmxvbmdpdHVkZSA9IHByb3BlcnR5LmxvbmdpdHVkZTtcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy5hZGRyZXNzID0gcHJvcGVydHkuYWRkcmVzcztcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy5jaXR5ID0gcHJvcGVydHkuY2l0eTtcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy5zdGF0ZSA9IHByb3BlcnR5LnN0YXRlO1xuICAgICAgICAgICAgbW9kdWxlcy5wcm9wZXJ0eV9kZXRhaWxzLnppcF9jb2RlID0gcHJvcGVydHkuemlwX2NvZGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcm9wZXJ0eV9yZXNlYXJjaFxuICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdwcm9wZXJ0eV9yZXNlYXJjaCcpXG4gICAgICAgICAgICAgIC51cGRhdGUoeyBtb2R1bGVzIH0pXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCByZXNlYXJjaFJlY29yZC5pZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHJlc2VhcmNoIGZvciBwcm9wZXJ0eSAke3Byb3BlcnR5LmlkfTpgLCB1cGRhdGVFcnJvcik7XG4gICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXBkYXRlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAocHJvcGVydHlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHByb3BlcnR5ICR7cHJvcGVydHkuaWR9OmAsIHByb3BlcnR5RXJyb3IpO1xuICAgICAgICBlcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiBgU3luY2hyb25pemVkICR7dXBkYXRlZH0gcHJvcGVydGllcyB3aXRoICR7ZXJyb3JzfSBlcnJvcnNgLFxuICAgICAgdXBkYXRlZCxcbiAgICAgIGVycm9yc1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3luY1Jlc2VhcmNoQ29vcmRpbmF0ZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgdXBkYXRlZDogMCxcbiAgICAgIGVycm9yczogMVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlZCBiYXRjaCBnZW9jb2RpbmcgZnVuY3Rpb24gdGhhdCBhdHRlbXB0cyBtdWx0aXBsZSBtZXRob2RzIG9mIGdlb2NvZGluZ1xuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGdlb2NvZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2dyZXNzQ2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gKHByb3BlcnR5LCBzdGF0dXMsIGRldGFpbHMpID0+IHt9XG4gKiBAcmV0dXJucyB7QXJyYXl9IFVwZGF0ZWQgcHJvcGVydGllcyB3aXRoIGdlb2NvZGluZyByZXN1bHRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmhhbmNlZEdlb2NvZGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHByb2dyZXNzQ2FsbGJhY2sgPSBudWxsKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSB8fCBwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgcHJvcGVydGllcyB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxzXG4gIGNvbnN0IHByb3BlcnRpZXNDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKSk7XG5cbiAgLy8gUHJvY2VzcyBlYWNoIHByb3BlcnR5XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllc0NvcHkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNDb3B5W2ldO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTa2lwIHByb3BlcnRpZXMgdGhhdCBhbHJlYWR5IGhhdmUgdmFsaWQgY29vcmRpbmF0ZXNcbiAgICAgIGlmIChwcm9wZXJ0eS5sYXRpdHVkZSAmJiBcbiAgICAgICAgICBwcm9wZXJ0eS5sb25naXR1ZGUgJiYgXG4gICAgICAgICAgcHJvcGVydHkubGF0aXR1ZGUgIT09IDAgJiYgXG4gICAgICAgICAgcHJvcGVydHkubG9uZ2l0dWRlICE9PSAwICYmIFxuICAgICAgICAgICFwcm9wZXJ0eS5fbmVlZHNfZ2VvY29kaW5nICYmIFxuICAgICAgICAgICFwcm9wZXJ0eS5fY29vcmRpbmF0ZXNfbWlzc2luZyAmJlxuICAgICAgICAgICFwcm9wZXJ0eS5faXNfZ3JpZF9wYXR0ZXJuKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJrIGFzIGhhdmluZyBleGlzdGluZyB2YWxpZCBjb29yZGluYXRlc1xuICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX3NvdXJjZSA9ICdleGlzdGluZyc7XG4gICAgICAgIHByb3BlcnR5Ll9nZW9jb2RlZCA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdza2lwcGVkJywgJ2FscmVhZHkgaGFzIHZhbGlkIGNvb3JkaW5hdGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdwcm9jZXNzaW5nJywgJ3N0YXJ0aW5nIGdlb2NvZGluZyBwcm9jZXNzJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpcnN0LCB0cnkgZ2VvY29kaW5nIHdpdGggdmVyaWZpZWQgYWRkcmVzcyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChwcm9wZXJ0eS52ZXJpZmllZF9hZGRyZXNzKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ2F0dGVtcHQnLCAndXNpbmcgdmVyaWZpZWQgYWRkcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBnZW9jb2RlUmVzdWx0ID0gYXdhaXQgZ2VvY29kZUFkZHJlc3MocHJvcGVydHkudmVyaWZpZWRfYWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VvY29kZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcHJvcGVydHkubGF0aXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxhdDtcbiAgICAgICAgICBwcm9wZXJ0eS5sb25naXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxuZztcbiAgICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX3NvdXJjZSA9ICd2ZXJpZmllZF9hZGRyZXNzJztcbiAgICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kZWQgPSB0cnVlO1xuICAgICAgICAgIHByb3BlcnR5Ll9uZWVkc19nZW9jb2RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBwcm9wZXJ0eS5faXNfZ3JpZF9wYXR0ZXJuID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuX2Nvb3JkaW5hdGVzX21pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICBwcm9wZXJ0eS5nZW9jb2RlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ3N1Y2Nlc3MnLCAndmVyaWZpZWQgYWRkcmVzcyBnZW9jb2RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBOZXh0LCB0cnkgd2l0aCB0aGUgZnVsbCBhZGRyZXNzXG4gICAgICBpZiAocHJvcGVydHkuYWRkcmVzcykge1xuICAgICAgICBsZXQgZnVsbEFkZHJlc3MgPSBwcm9wZXJ0eS5hZGRyZXNzO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGNpdHksIHN0YXRlIGlmIHRoZXkgZXhpc3QgYW5kIGFyZW4ndCBhbHJlYWR5IGluIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmIChwcm9wZXJ0eS5jaXR5ICYmICFmdWxsQWRkcmVzcy5pbmNsdWRlcyhwcm9wZXJ0eS5jaXR5KSkge1xuICAgICAgICAgIGZ1bGxBZGRyZXNzICs9IGAsICR7cHJvcGVydHkuY2l0eX1gO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocHJvcGVydHkuc3RhdGUgJiYgIWZ1bGxBZGRyZXNzLmluY2x1ZGVzKHByb3BlcnR5LnN0YXRlKSkge1xuICAgICAgICAgIGZ1bGxBZGRyZXNzICs9IGAsICR7cHJvcGVydHkuc3RhdGV9YDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHppcCBjb2RlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGFscmVhZHkgaW4gdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3BlcnR5LnppcCAmJiAhZnVsbEFkZHJlc3MuaW5jbHVkZXMocHJvcGVydHkuemlwKSkge1xuICAgICAgICAgIGZ1bGxBZGRyZXNzICs9IGAgJHtwcm9wZXJ0eS56aXB9YDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnYXR0ZW1wdCcsICd1c2luZyBmdWxsIGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZ2VvY29kZVJlc3VsdCA9IGF3YWl0IGdlb2NvZGVBZGRyZXNzKGZ1bGxBZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChnZW9jb2RlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBwcm9wZXJ0eS5sYXRpdHVkZSA9IGdlb2NvZGVSZXN1bHQubGF0O1xuICAgICAgICAgIHByb3BlcnR5LmxvbmdpdHVkZSA9IGdlb2NvZGVSZXN1bHQubG5nO1xuICAgICAgICAgIHByb3BlcnR5Ll9nZW9jb2Rpbmdfc291cmNlID0gJ2Z1bGxfYWRkcmVzcyc7XG4gICAgICAgICAgcHJvcGVydHkuX2dlb2NvZGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9wZXJ0eS5fbmVlZHNfZ2VvY29kaW5nID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuX2lzX2dyaWRfcGF0dGVybiA9IGZhbHNlO1xuICAgICAgICAgIHByb3BlcnR5Ll9jb29yZGluYXRlc19taXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuZ2VvY29kZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdzdWNjZXNzJywgJ2Z1bGwgYWRkcmVzcyBnZW9jb2RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdHJ5IGdlb2NvZGluZyBiYXNlZCBvbiB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgLy8gVGhpcyBpcyBhIGxhc3QgcmVzb3J0IGFuZCBtaWdodCBub3QgYmUgYWNjdXJhdGVcbiAgICAgIGlmIChwcm9wZXJ0eS5uYW1lKSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgbmFtZSBmb3IgZ2VvY29kaW5nXG4gICAgICAgIC8vIEFkZCBcIkF1c3RpbiwgVFhcIiBzaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGluIEF1c3RpblxuICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gYCR7cHJvcGVydHkubmFtZX0sICR7cHJvcGVydHkuY2l0eSB8fCAnQXVzdGluJ30sICR7cHJvcGVydHkuc3RhdGUgfHwgJ1RYJ31gO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnYXR0ZW1wdCcsICd1c2luZyBwcm9wZXJ0eSBuYW1lIGFzIGxhc3QgcmVzb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGdlb2NvZGVSZXN1bHQgPSBhd2FpdCBnZW9jb2RlQWRkcmVzcyhzZWFyY2hUZXJtKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChnZW9jb2RlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBwcm9wZXJ0eS5sYXRpdHVkZSA9IGdlb2NvZGVSZXN1bHQubGF0O1xuICAgICAgICAgIHByb3BlcnR5LmxvbmdpdHVkZSA9IGdlb2NvZGVSZXN1bHQubG5nO1xuICAgICAgICAgIHByb3BlcnR5Ll9nZW9jb2Rpbmdfc291cmNlID0gJ3Byb3BlcnR5X25hbWUnO1xuICAgICAgICAgIHByb3BlcnR5Ll9nZW9jb2RlZCA9IHRydWU7XG4gICAgICAgICAgcHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyA9IGZhbHNlO1xuICAgICAgICAgIC8vIFN0aWxsIG1hcmsgdGhlc2UgYXMgcG90ZW50aWFsbHkgZ3JpZCBwYXR0ZXJuIHNpbmNlIHRoZXkncmUgbGVzcyByZWxpYWJsZVxuICAgICAgICAgIHByb3BlcnR5Ll9pc19ncmlkX3BhdHRlcm4gPSBmYWxzZTtcbiAgICAgICAgICBwcm9wZXJ0eS5fY29vcmRpbmF0ZXNfbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgIHByb3BlcnR5Lmdlb2NvZGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnc3VjY2VzcycsICdwcm9wZXJ0eSBuYW1lIGdlb2NvZGVkIChsZXNzIGFjY3VyYXRlKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgYWxsIGdlb2NvZGluZyBhdHRlbXB0cyBmYWlsZWRcbiAgICAgIHByb3BlcnR5Ll9nZW9jb2RpbmdfZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdlcnJvcicsICdhbGwgZ2VvY29kaW5nIG1ldGhvZHMgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2VvY29kaW5nIHByb3BlcnR5ICR7cHJvcGVydHkuaWR9OmAsIGVycm9yKTtcbiAgICAgIHByb3BlcnR5Ll9nZW9jb2RpbmdfZmFpbGVkID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ2Vycm9yJywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BlcnRpZXNDb3B5O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIHByb3BlcnR5IGhhcyB2YWxpZCBjb29yZGluYXRlc1xuICovXG5jb25zdCBoYXNWYWxpZENvb3JkaW5hdGVzID0gKHByb3BlcnR5KSA9PiB7XG4gIGlmICghcHJvcGVydHkpIHJldHVybiBmYWxzZTtcbiAgXG4gIGlmICghcHJvcGVydHkubGF0aXR1ZGUgfHwgIXByb3BlcnR5LmxvbmdpdHVkZSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ29udmVydCB0byBudW1iZXJzIGlmIG5lZWRlZFxuICBjb25zdCBsYXQgPSB0eXBlb2YgcHJvcGVydHkubGF0aXR1ZGUgPT09ICdudW1iZXInID8gcHJvcGVydHkubGF0aXR1ZGUgOiBwYXJzZUZsb2F0KFN0cmluZyhwcm9wZXJ0eS5sYXRpdHVkZSkpO1xuICBjb25zdCBsbmcgPSB0eXBlb2YgcHJvcGVydHkubG9uZ2l0dWRlID09PSAnbnVtYmVyJyA/IHByb3BlcnR5LmxvbmdpdHVkZSA6IHBhcnNlRmxvYXQoU3RyaW5nKHByb3BlcnR5LmxvbmdpdHVkZSkpO1xuICBcbiAgLy8gQ2hlY2sgZm9yIE5hTlxuICBpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBDaGVjayBmb3IgemVybyB2YWx1ZXMgKG9mdGVuIGRlZmF1bHQpXG4gIGlmIChsYXQgPT09IDAgJiYgbG5nID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBDaGVjayBmb3IgcmVhc29uYWJsZSBjb29yZGluYXRlIHJhbmdlc1xuICBpZiAobGF0IDwgLTkwIHx8IGxhdCA+IDkwIHx8IGxuZyA8IC0xODAgfHwgbG5nID4gMTgwKSByZXR1cm4gZmFsc2U7XG4gIFxuICByZXR1cm4gdHJ1ZTtcbn07Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwiZ2VvY29kZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwibmVlZHNHZW9jb2RpbmciLCJmaWx0ZXIiLCJwIiwiX25lZWRzX2dlb2NvZGluZyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiX2Nvb3JkaW5hdGVzX21pc3NpbmciLCJfaXNfZ3JpZF9wYXR0ZXJuIiwiYWRkcmVzcyIsImNpdHkiLCJzdGF0ZSIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJnb29nbGVNYXBzQXZhaWxhYmxlIiwiZ29vZ2xlIiwibWFwcyIsIkdlb2NvZGVyIiwibWFwYm94VG9rZW4iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTUFQQk9YX0FDQ0VTU19UT0tFTiIsImdlb2NvZGVkUHJvcGVydGllcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJwcm9wZXJ0eSIsImdlb2NvZGVkUHJvcGVydHkiLCJjb29yZGluYXRlcyIsImdlb2NvZGVXaXRoR29vZ2xlTWFwcyIsImdlb2NvZGVXaXRoTWFwYm94IiwiZ2VvY29kZVdpdGhOb21pbmF0aW0iLCJfZ2VvY29kZWQiLCJ3YXJuIiwiZXJyb3IiLCJyZXNvbHZlIiwiZ2VvY29kZXIiLCJhZGRyZXNzU3RyaW5nIiwiemlwX2NvZGUiLCJnZW9jb2RlIiwicmVzdWx0cyIsInN0YXR1cyIsImdlb21ldHJ5IiwibG9jYXRpb24iLCJsYXQiLCJsbmciLCJpc0dyaWRQYXR0ZXJuIiwicHJvdmlkZXIiLCJhY2Nlc3NUb2tlbiIsImVuY29kZWRBZGRyZXNzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJjZW50ZXIiLCJoZWFkZXJzIiwicmVzdWx0IiwicGFyc2VGbG9hdCIsImxvbiIsImxhdFN0ciIsIlN0cmluZyIsImxuZ1N0ciIsImhhc0xvd1ByZWNpc2lvbiIsImluY2x1ZGVzIiwic3BsaXQiLCJoYXNTdXNwaWNpb3VzUGF0dGVybiIsImVuZHNXaXRoIiwiY2hlY2tSZXNlYXJjaFRhYmxlRXhpc3RzIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0Iiwic3luY1Jlc2VhcmNoQ29vcmRpbmF0ZXMiLCJ0YWJsZUV4aXN0cyIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidXBkYXRlZCIsImVycm9ycyIsInJlc2VhcmNoIiwicmVzZWFyY2hFcnJvciIsImVxIiwiaWQiLCJyZXNlYXJjaFJlY29yZCIsIm1vZHVsZXMiLCJwcm9wZXJ0eV9kZXRhaWxzIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJwcm9wZXJ0eUVycm9yIiwiZW5oYW5jZWRHZW9jb2RlUHJvcGVydGllcyIsInByb2dyZXNzQ2FsbGJhY2siLCJBcnJheSIsImlzQXJyYXkiLCJwcm9wZXJ0aWVzQ29weSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImkiLCJfZ2VvY29kaW5nX3NvdXJjZSIsInZlcmlmaWVkX2FkZHJlc3MiLCJnZW9jb2RlUmVzdWx0IiwiZ2VvY29kZUFkZHJlc3MiLCJnZW9jb2RlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImZ1bGxBZGRyZXNzIiwiemlwIiwibmFtZSIsInNlYXJjaFRlcm0iLCJfZ2VvY29kaW5nX2ZhaWxlZCIsImhhc1ZhbGlkQ29vcmRpbmF0ZXMiLCJpc05hTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/geocoding.js\n"));

/***/ })

});
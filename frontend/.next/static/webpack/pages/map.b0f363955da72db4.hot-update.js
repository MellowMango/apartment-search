"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/map",{

/***/ "./lib/geocoding.js":
/*!**************************!*\
  !*** ./lib/geocoding.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkResearchTableExists: function() { return /* binding */ checkResearchTableExists; },\n/* harmony export */   enhancedGeocodeProperties: function() { return /* binding */ enhancedGeocodeProperties; },\n/* harmony export */   geocodeAddress: function() { return /* binding */ geocodeAddress; },\n/* harmony export */   geocodeProperties: function() { return /* binding */ geocodeProperties; },\n/* harmony export */   isGridPattern: function() { return /* binding */ isGridPattern; },\n/* harmony export */   syncResearchCoordinates: function() { return /* binding */ syncResearchCoordinates; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"./lib/supabase.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../../../node_modules/process/browser.js\");\n/**\n * Geocoding utilities for the frontend\n * \n * This module provides tools for:\n * 1. Client-side geocoding using Google Maps, Mapbox, or Nominatim (fallback)\n * 2. Utilities for coordinate validation and processing\n * 3. Functions to synchronize coordinates between properties and property_research\n */ \n/**\n * Geocode a batch of properties\n * \n * @param {Array} properties - Array of property objects\n * @returns {Promise<Array>} - Properties with coordinates added\n */ async function geocodeProperties(properties) {\n    // Filter properties that need geocoding\n    const needsGeocoding = properties.filter((p)=>(p._needs_geocoding || !p.latitude || !p.longitude || p._coordinates_missing || p._is_grid_pattern) && (p.address || p.city && p.state));\n    if (needsGeocoding.length === 0) {\n        console.log(\"No properties need geocoding\");\n        return properties;\n    }\n    console.log(\"Geocoding \".concat(needsGeocoding.length, \" properties\"));\n    // Try to use Google Maps API if available\n    const googleMapsAvailable = typeof google !== \"undefined\" && google.maps && google.maps.Geocoder;\n    // Use Mapbox if available\n    const mapboxToken = process.env.NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN;\n    // Geocode each property\n    const geocodedProperties = await Promise.all(properties.map(async (property)=>{\n        // Skip properties that don't need geocoding\n        if (!property._needs_geocoding && property.latitude && property.longitude && !property._coordinates_missing && !property._is_grid_pattern || !property.address && (!property.city || !property.state)) {\n            return property;\n        }\n        // Create a copy to avoid mutating the original\n        const geocodedProperty = {\n            ...property\n        };\n        try {\n            let coordinates = null;\n            // Try Google Maps API first if available\n            if (googleMapsAvailable) {\n                coordinates = await geocodeWithGoogleMaps(property);\n            }\n            // If Google Maps failed or is not available, try Mapbox\n            if (!coordinates && mapboxToken) {\n                coordinates = await geocodeWithMapbox(property, mapboxToken);\n            }\n            // If both failed, try Nominatim as a last resort\n            if (!coordinates) {\n                coordinates = await geocodeWithNominatim(property);\n            }\n            // If we got coordinates, update the property\n            if (coordinates) {\n                geocodedProperty.latitude = coordinates.latitude;\n                geocodedProperty.longitude = coordinates.longitude;\n                geocodedProperty._geocoded = true;\n                geocodedProperty._coordinates_missing = false;\n                geocodedProperty._needs_geocoding = false;\n                geocodedProperty._is_grid_pattern = false;\n                console.log(\"Geocoded \".concat(property.address || property.city, \", \").concat(property.state, \": \").concat(coordinates.latitude, \", \").concat(coordinates.longitude));\n            } else {\n                console.warn(\"Failed to geocode \".concat(property.address || property.city, \", \").concat(property.state));\n            }\n        } catch (error) {\n            console.error(\"Geocoding error for \".concat(property.address || property.city, \", \").concat(property.state, \":\"), error);\n        }\n        return geocodedProperty;\n    }));\n    return geocodedProperties;\n}\n/**\n * Geocode a property using Google Maps API\n * \n * @param {Object} property - Property object with address information\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithGoogleMaps(property) {\n    return new Promise((resolve)=>{\n        try {\n            const geocoder = new google.maps.Geocoder();\n            // Build address string\n            let addressString = \"\";\n            if (property.address) addressString += property.address;\n            if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n            if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n            if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n            geocoder.geocode({\n                address: addressString\n            }, (results, status)=>{\n                if (status === \"OK\" && results[0] && results[0].geometry) {\n                    const latitude = results[0].geometry.location.lat();\n                    const longitude = results[0].geometry.location.lng();\n                    // Check for suspicious patterns\n                    if (isGridPattern(latitude, longitude)) {\n                        console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                        resolve(null);\n                    } else {\n                        resolve({\n                            latitude,\n                            longitude,\n                            provider: \"google\"\n                        });\n                    }\n                } else {\n                    console.warn(\"Google geocoding failed: \".concat(status));\n                    resolve(null);\n                }\n            });\n        } catch (error) {\n            console.error(\"Error with Google geocoding:\", error);\n            resolve(null);\n        }\n    });\n}\n/**\n * Geocode a property using Mapbox API\n * \n * @param {Object} property - Property object with address information\n * @param {string} accessToken - Mapbox access token\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithMapbox(property, accessToken) {\n    try {\n        // Build address string\n        let addressString = \"\";\n        if (property.address) addressString += property.address;\n        if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n        if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n        if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n        // URL encode the address\n        const encodedAddress = encodeURIComponent(addressString);\n        // Make API request\n        const response = await fetch(\"https://api.mapbox.com/geocoding/v5/mapbox.places/\".concat(encodedAddress, \".json?access_token=\").concat(accessToken));\n        if (!response.ok) {\n            throw new Error(\"Mapbox API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        if (data.features && data.features.length > 0) {\n            const feature = data.features[0];\n            const longitude = feature.center[0];\n            const latitude = feature.center[1];\n            // Check for suspicious patterns\n            if (isGridPattern(latitude, longitude)) {\n                console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                return null;\n            }\n            return {\n                latitude,\n                longitude,\n                provider: \"mapbox\"\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error with Mapbox geocoding:\", error);\n        return null;\n    }\n}\n/**\n * Geocode a property using Nominatim API (OpenStreetMap)\n * \n * @param {Object} property - Property object with address information\n * @returns {Promise<Object|null>} - Coordinates object or null if failed\n */ async function geocodeWithNominatim(property) {\n    try {\n        // Build address string\n        let addressString = \"\";\n        if (property.address) addressString += property.address;\n        if (property.city) addressString += (addressString ? \", \" : \"\") + property.city;\n        if (property.state) addressString += (addressString ? \", \" : \"\") + property.state;\n        if (property.zip_code) addressString += (addressString ? \" \" : \"\") + property.zip_code;\n        // URL encode the address\n        const encodedAddress = encodeURIComponent(addressString);\n        // Make API request (with a random delay to avoid rate limiting)\n        const response = await fetch(\"https://nominatim.openstreetmap.org/search?format=json&q=\".concat(encodedAddress), {\n            headers: {\n                \"User-Agent\": \"AcquirePropertyMap/1.0\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Nominatim API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        if (data && data.length > 0) {\n            const result = data[0];\n            const latitude = parseFloat(result.lat);\n            const longitude = parseFloat(result.lon);\n            // Check for suspicious patterns\n            if (isGridPattern(latitude, longitude)) {\n                console.warn(\"Suspicious grid pattern detected: \".concat(latitude, \", \").concat(longitude));\n                return null;\n            }\n            return {\n                latitude,\n                longitude,\n                provider: \"nominatim\"\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error with Nominatim geocoding:\", error);\n        return null;\n    }\n}\n/**\n * Check if coordinates are likely part of a grid pattern\n * \n * @param {number} latitude - Latitude coordinate\n * @param {number} longitude - Longitude coordinate\n * @returns {boolean} - True if likely a grid pattern, false otherwise\n */ function isGridPattern(latitude, longitude) {\n    if (!latitude || !longitude) return false;\n    // Convert to strings for easier checking\n    const latStr = String(latitude);\n    const lngStr = String(longitude);\n    // Check for very low precision coordinates (often grid patterns)\n    const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 3 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 3;\n    // Check for suspicious patterns\n    const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".5\") || // Common grid values\n    lngStr.endsWith(\".5\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\");\n    return hasLowPrecision || hasSuspiciousPattern;\n}\n/**\n * Check if the property_research table exists in Supabase\n * \n * @returns {Promise<boolean>} - True if table exists, false otherwise\n */ async function checkResearchTableExists() {\n    try {\n        // Attempt to query the table\n        const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").select(\"id\").limit(1);\n        // If no error, table exists\n        return !error;\n    } catch (error) {\n        console.error(\"Error checking research table:\", error);\n        return false;\n    }\n}\n/**\n * Synchronize coordinates between properties and property_research tables\n * \n * @param {number} limit - Maximum number of properties to process\n * @returns {Promise<Object>} - Result object with success status and counts\n */ async function syncResearchCoordinates() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n    try {\n        // Check if table exists\n        const tableExists = await checkResearchTableExists();\n        if (!tableExists) {\n            return {\n                success: false,\n                message: \"Property research table does not exist or is not accessible\",\n                updated: 0,\n                errors: 0\n            };\n        }\n        // Get properties missing or with suspicious coordinates\n        const { data: properties, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"properties\").select(\"id, address, city, state, zip_code, latitude, longitude\").limit(limit);\n        if (error) {\n            throw new Error(\"Error fetching properties: \".concat(error.message));\n        }\n        if (!properties || properties.length === 0) {\n            return {\n                success: true,\n                message: \"No properties found to synchronize\",\n                updated: 0,\n                errors: 0\n            };\n        }\n        // Synchronize each property\n        let updated = 0;\n        let errors = 0;\n        for (const property of properties){\n            try {\n                // If property has valid coordinates, update property_research\n                if (property.latitude && property.longitude && !isGridPattern(property.latitude, property.longitude)) {\n                    // Get property_research record\n                    const { data: research, error: researchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").select(\"id, modules\").eq(\"property_id\", property.id);\n                    if (researchError) {\n                        console.error(\"Error fetching research for property \".concat(property.id, \":\"), researchError);\n                        errors++;\n                        continue;\n                    }\n                    if (research && research.length > 0) {\n                        // Update modules with coordinates\n                        const researchRecord = research[0];\n                        let modules = researchRecord.modules || {};\n                        // Create property_details if it doesn't exist\n                        if (!modules.property_details) {\n                            modules.property_details = {};\n                        }\n                        // Update coordinates\n                        modules.property_details.latitude = property.latitude;\n                        modules.property_details.longitude = property.longitude;\n                        modules.property_details.address = property.address;\n                        modules.property_details.city = property.city;\n                        modules.property_details.state = property.state;\n                        modules.property_details.zip_code = property.zip_code;\n                        // Update property_research\n                        const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"property_research\").update({\n                            modules\n                        }).eq(\"id\", researchRecord.id);\n                        if (updateError) {\n                            console.error(\"Error updating research for property \".concat(property.id, \":\"), updateError);\n                            errors++;\n                        } else {\n                            updated++;\n                        }\n                    }\n                }\n            } catch (propertyError) {\n                console.error(\"Error processing property \".concat(property.id, \":\"), propertyError);\n                errors++;\n            }\n        }\n        return {\n            success: true,\n            message: \"Synchronized \".concat(updated, \" properties with \").concat(errors, \" errors\"),\n            updated,\n            errors\n        };\n    } catch (error) {\n        console.error(\"Error in syncResearchCoordinates:\", error);\n        return {\n            success: false,\n            message: error.message || \"Unknown error occurred\",\n            updated: 0,\n            errors: 1\n        };\n    }\n}\n/**\n * Enhanced batch geocoding function that attempts multiple methods of geocoding\n * @param {Array} properties Array of properties to geocode\n * @param {Function} progressCallback Optional callback function (property, status, details) => {}\n * @returns {Array} Updated properties with geocoding results\n */ async function enhancedGeocodeProperties(properties) {\n    let progressCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    if (!Array.isArray(properties) || properties.length === 0) {\n        return [];\n    }\n    // Create a deep copy of the properties to avoid mutating the originals\n    const propertiesCopy = JSON.parse(JSON.stringify(properties));\n    // Process each property\n    for(let i = 0; i < propertiesCopy.length; i++){\n        const property = propertiesCopy[i];\n        try {\n            // Skip properties that already have valid coordinates\n            if (property.latitude && property.longitude && property.latitude !== 0 && property.longitude !== 0 && !property._needs_geocoding && !property._coordinates_missing && !property._is_grid_pattern) {\n                // Mark as having existing valid coordinates\n                property._geocoding_source = \"existing\";\n                property._geocoded = true;\n                if (progressCallback) {\n                    progressCallback(property, \"skipped\", \"already has valid coordinates\");\n                }\n                continue;\n            }\n            if (progressCallback) {\n                progressCallback(property, \"processing\", \"starting geocoding process\");\n            }\n            // First, try geocoding with verified address if available\n            if (property.verified_address) {\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using verified address\");\n                }\n                const geocodeResult = await geocodeAddress(property.verified_address);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"verified_address\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"verified address geocoded\");\n                    }\n                    continue;\n                }\n            }\n            // Next, try with the full address\n            if (property.address) {\n                let fullAddress = property.address;\n                // Add city, state if they exist and aren't already in the address\n                if (property.city && !fullAddress.includes(property.city)) {\n                    fullAddress += \", \".concat(property.city);\n                }\n                if (property.state && !fullAddress.includes(property.state)) {\n                    fullAddress += \", \".concat(property.state);\n                }\n                // Add zip code if available and not already in the address\n                if (property.zip && !fullAddress.includes(property.zip)) {\n                    fullAddress += \" \".concat(property.zip);\n                }\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using full address\");\n                }\n                const geocodeResult = await geocodeAddress(fullAddress);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"full_address\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"full address geocoded\");\n                    }\n                    continue;\n                }\n            }\n            // If all else fails, try geocoding based on the property name\n            // This is a last resort and might not be accurate\n            if (property.name) {\n                // Format the name for geocoding\n                // Add \"Austin, TX\" since most properties are in Austin\n                const searchTerm = \"\".concat(property.name, \", \").concat(property.city || \"Austin\", \", \").concat(property.state || \"TX\");\n                if (progressCallback) {\n                    progressCallback(property, \"attempt\", \"using property name as last resort\");\n                }\n                const geocodeResult = await geocodeAddress(searchTerm);\n                if (geocodeResult.success) {\n                    property.latitude = geocodeResult.lat;\n                    property.longitude = geocodeResult.lng;\n                    property._geocoding_source = \"property_name\";\n                    property._geocoded = true;\n                    property._needs_geocoding = false;\n                    // Still mark these as potentially grid pattern since they're less reliable\n                    property._is_grid_pattern = false;\n                    property._coordinates_missing = false;\n                    property.geocoded_at = new Date().toISOString();\n                    if (progressCallback) {\n                        progressCallback(property, \"success\", \"property name geocoded (less accurate)\");\n                    }\n                    continue;\n                }\n            }\n            // If we get here, all geocoding attempts failed\n            property._geocoding_failed = true;\n            if (progressCallback) {\n                progressCallback(property, \"error\", \"all geocoding methods failed\");\n            }\n        } catch (error) {\n            console.error(\"Error geocoding property \".concat(property.id, \":\"), error);\n            property._geocoding_failed = true;\n            if (progressCallback) {\n                progressCallback(property, \"error\", error.message);\n            }\n        }\n    }\n    return propertiesCopy;\n}\n/**\n * Helper function to check if a property has valid coordinates\n */ const hasValidCoordinates = (property)=>{\n    if (!property) return false;\n    if (!property.latitude || !property.longitude) return false;\n    // Convert to numbers if needed\n    const lat = typeof property.latitude === \"number\" ? property.latitude : parseFloat(String(property.latitude));\n    const lng = typeof property.longitude === \"number\" ? property.longitude : parseFloat(String(property.longitude));\n    // Check for NaN\n    if (isNaN(lat) || isNaN(lng)) return false;\n    // Check for zero values (often default)\n    if (lat === 0 && lng === 0) return false;\n    // Check for reasonable coordinate ranges\n    if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return false;\n    return true;\n};\n/**\n * Geocode an address using Google Maps API\n * @param {string} address The address to geocode\n * @returns {Promise<Object>} Object with success flag and lat/lng if successful\n */ async function geocodeAddress(address) {\n    if (!address) {\n        return {\n            success: false,\n            error: \"No address provided\"\n        };\n    }\n    try {\n        // First try to use the geocoding API endpoint\n        const encodedAddress = encodeURIComponent(address);\n        const response = await fetch(\"/api/geocode?address=\".concat(encodedAddress));\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data && data.results && data.results.length > 0) {\n            const location = data.results[0].geometry.location;\n            return {\n                success: true,\n                lat: location.lat,\n                lng: location.lng,\n                formattedAddress: data.results[0].formatted_address\n            };\n        }\n        return {\n            success: false,\n            error: \"No results found\"\n        };\n    } catch (error) {\n        console.error(\"Error geocoding address:\", error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLElBQUk7UUFDRiw4Q0FBOEM7UUFDOUMsTUFBTWUsaUJBQWlCQyxtQkFBbUIxQztRQUMxQyxNQUFNMkMsV0FBVyxNQUFNQyxNQUFNLHdCQUF1QyxPQUFmSDtRQUVyRCxJQUFJLENBQUNFLFNBQVNFLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sY0FBOEIsT0FBaEJILFNBQVNWLE1BQU07UUFDL0M7UUFFQSxNQUFNZSxPQUFPLE1BQU1MLFNBQVNNLElBQUk7UUFFaEMsSUFBSUQsUUFBUUEsS0FBS2hCLE9BQU8sSUFBSWdCLEtBQUtoQixPQUFPLENBQUM3QixNQUFNLEdBQUcsR0FBRztZQUNuRCxNQUFNZ0MsV0FBV2EsS0FBS2hCLE9BQU8sQ0FBQyxFQUFFLENBQUNFLFFBQVEsQ0FBQ0MsUUFBUTtZQUNsRCxPQUFPO2dCQUNMb0MsU0FBUztnQkFDVG5DLEtBQUtELFNBQVNDLEdBQUc7Z0JBQ2pCQyxLQUFLRixTQUFTRSxHQUFHO2dCQUNqQnVFLGtCQUFrQjVELEtBQUtoQixPQUFPLENBQUMsRUFBRSxDQUFDNkUsaUJBQWlCO1lBQ3JEO1FBQ0Y7UUFFQSxPQUFPO1lBQUV0QyxTQUFTO1lBQU83QyxPQUFPO1FBQW1CO0lBQ3JELEVBQUUsT0FBT0EsT0FBTztRQUNkdEIsUUFBUXNCLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87WUFBRTZDLFNBQVM7WUFBTzdDLE9BQU9BLE1BQU04QyxPQUFPO1FBQUM7SUFDaEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZ2VvY29kaW5nLmpzPzZjZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZW9jb2RpbmcgdXRpbGl0aWVzIGZvciB0aGUgZnJvbnRlbmRcbiAqIFxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdG9vbHMgZm9yOlxuICogMS4gQ2xpZW50LXNpZGUgZ2VvY29kaW5nIHVzaW5nIEdvb2dsZSBNYXBzLCBNYXBib3gsIG9yIE5vbWluYXRpbSAoZmFsbGJhY2spXG4gKiAyLiBVdGlsaXRpZXMgZm9yIGNvb3JkaW5hdGUgdmFsaWRhdGlvbiBhbmQgcHJvY2Vzc2luZ1xuICogMy4gRnVuY3Rpb25zIHRvIHN5bmNocm9uaXplIGNvb3JkaW5hdGVzIGJldHdlZW4gcHJvcGVydGllcyBhbmQgcHJvcGVydHlfcmVzZWFyY2hcbiAqL1xuXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4vc3VwYWJhc2UnO1xuXG4vKipcbiAqIEdlb2NvZGUgYSBiYXRjaCBvZiBwcm9wZXJ0aWVzXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgLSBBcnJheSBvZiBwcm9wZXJ0eSBvYmplY3RzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IC0gUHJvcGVydGllcyB3aXRoIGNvb3JkaW5hdGVzIGFkZGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW9jb2RlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gIC8vIEZpbHRlciBwcm9wZXJ0aWVzIHRoYXQgbmVlZCBnZW9jb2RpbmdcbiAgY29uc3QgbmVlZHNHZW9jb2RpbmcgPSBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgIChwLl9uZWVkc19nZW9jb2RpbmcgfHwgIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlIHx8IHAuX2Nvb3JkaW5hdGVzX21pc3NpbmcgfHwgcC5faXNfZ3JpZF9wYXR0ZXJuKSAmJlxuICAgIChwLmFkZHJlc3MgfHwgKHAuY2l0eSAmJiBwLnN0YXRlKSlcbiAgKTtcbiAgXG4gIGlmIChuZWVkc0dlb2NvZGluZy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZygnTm8gcHJvcGVydGllcyBuZWVkIGdlb2NvZGluZycpO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIFxuICBjb25zb2xlLmxvZyhgR2VvY29kaW5nICR7bmVlZHNHZW9jb2RpbmcubGVuZ3RofSBwcm9wZXJ0aWVzYCk7XG4gIFxuICAvLyBUcnkgdG8gdXNlIEdvb2dsZSBNYXBzIEFQSSBpZiBhdmFpbGFibGVcbiAgY29uc3QgZ29vZ2xlTWFwc0F2YWlsYWJsZSA9IHR5cGVvZiBnb29nbGUgIT09ICd1bmRlZmluZWQnICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuR2VvY29kZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAvLyBVc2UgTWFwYm94IGlmIGF2YWlsYWJsZVxuICBjb25zdCBtYXBib3hUb2tlbiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01BUEJPWF9BQ0NFU1NfVE9LRU47XG4gIFxuICAvLyBHZW9jb2RlIGVhY2ggcHJvcGVydHlcbiAgY29uc3QgZ2VvY29kZWRQcm9wZXJ0aWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgcHJvcGVydGllcy5tYXAoYXN5bmMgKHByb3BlcnR5KSA9PiB7XG4gICAgICAvLyBTa2lwIHByb3BlcnRpZXMgdGhhdCBkb24ndCBuZWVkIGdlb2NvZGluZ1xuICAgICAgaWYgKCghcHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyAmJiBwcm9wZXJ0eS5sYXRpdHVkZSAmJiBwcm9wZXJ0eS5sb25naXR1ZGUgJiYgXG4gICAgICAgICAgICFwcm9wZXJ0eS5fY29vcmRpbmF0ZXNfbWlzc2luZyAmJiAhcHJvcGVydHkuX2lzX2dyaWRfcGF0dGVybikgfHxcbiAgICAgICAgICAoIXByb3BlcnR5LmFkZHJlc3MgJiYgKCFwcm9wZXJ0eS5jaXR5IHx8ICFwcm9wZXJ0eS5zdGF0ZSkpKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgIGNvbnN0IGdlb2NvZGVkUHJvcGVydHkgPSB7IC4uLnByb3BlcnR5IH07XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBjb29yZGluYXRlcyA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgR29vZ2xlIE1hcHMgQVBJIGZpcnN0IGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoZ29vZ2xlTWFwc0F2YWlsYWJsZSkge1xuICAgICAgICAgIGNvb3JkaW5hdGVzID0gYXdhaXQgZ2VvY29kZVdpdGhHb29nbGVNYXBzKHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgR29vZ2xlIE1hcHMgZmFpbGVkIG9yIGlzIG5vdCBhdmFpbGFibGUsIHRyeSBNYXBib3hcbiAgICAgICAgaWYgKCFjb29yZGluYXRlcyAmJiBtYXBib3hUb2tlbikge1xuICAgICAgICAgIGNvb3JkaW5hdGVzID0gYXdhaXQgZ2VvY29kZVdpdGhNYXBib3gocHJvcGVydHksIG1hcGJveFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgYm90aCBmYWlsZWQsIHRyeSBOb21pbmF0aW0gYXMgYSBsYXN0IHJlc29ydFxuICAgICAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBhd2FpdCBnZW9jb2RlV2l0aE5vbWluYXRpbShwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGdvdCBjb29yZGluYXRlcywgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICBnZW9jb2RlZFByb3BlcnR5LmxhdGl0dWRlID0gY29vcmRpbmF0ZXMubGF0aXR1ZGU7XG4gICAgICAgICAgZ2VvY29kZWRQcm9wZXJ0eS5sb25naXR1ZGUgPSBjb29yZGluYXRlcy5sb25naXR1ZGU7XG4gICAgICAgICAgZ2VvY29kZWRQcm9wZXJ0eS5fZ2VvY29kZWQgPSB0cnVlO1xuICAgICAgICAgIGdlb2NvZGVkUHJvcGVydHkuX2Nvb3JkaW5hdGVzX21pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICBnZW9jb2RlZFByb3BlcnR5Ll9uZWVkc19nZW9jb2RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBnZW9jb2RlZFByb3BlcnR5Ll9pc19ncmlkX3BhdHRlcm4gPSBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgR2VvY29kZWQgJHtwcm9wZXJ0eS5hZGRyZXNzIHx8IHByb3BlcnR5LmNpdHl9LCAke3Byb3BlcnR5LnN0YXRlfTogJHtjb29yZGluYXRlcy5sYXRpdHVkZX0sICR7Y29vcmRpbmF0ZXMubG9uZ2l0dWRlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGdlb2NvZGUgJHtwcm9wZXJ0eS5hZGRyZXNzIHx8IHByb3BlcnR5LmNpdHl9LCAke3Byb3BlcnR5LnN0YXRlfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBHZW9jb2RpbmcgZXJyb3IgZm9yICR7cHJvcGVydHkuYWRkcmVzcyB8fCBwcm9wZXJ0eS5jaXR5fSwgJHtwcm9wZXJ0eS5zdGF0ZX06YCwgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZ2VvY29kZWRQcm9wZXJ0eTtcbiAgICB9KVxuICApO1xuICBcbiAgcmV0dXJuIGdlb2NvZGVkUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBHZW9jb2RlIGEgcHJvcGVydHkgdXNpbmcgR29vZ2xlIE1hcHMgQVBJXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0eSAtIFByb3BlcnR5IG9iamVjdCB3aXRoIGFkZHJlc3MgaW5mb3JtYXRpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0gLSBDb29yZGluYXRlcyBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VvY29kZVdpdGhHb29nbGVNYXBzKHByb3BlcnR5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpO1xuICAgICAgXG4gICAgICAvLyBCdWlsZCBhZGRyZXNzIHN0cmluZ1xuICAgICAgbGV0IGFkZHJlc3NTdHJpbmcgPSAnJztcbiAgICAgIGlmIChwcm9wZXJ0eS5hZGRyZXNzKSBhZGRyZXNzU3RyaW5nICs9IHByb3BlcnR5LmFkZHJlc3M7XG4gICAgICBpZiAocHJvcGVydHkuY2l0eSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcsICcgOiAnJykgKyBwcm9wZXJ0eS5jaXR5O1xuICAgICAgaWYgKHByb3BlcnR5LnN0YXRlKSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJywgJyA6ICcnKSArIHByb3BlcnR5LnN0YXRlO1xuICAgICAgaWYgKHByb3BlcnR5LnppcF9jb2RlKSBhZGRyZXNzU3RyaW5nICs9IChhZGRyZXNzU3RyaW5nID8gJyAnIDogJycpICsgcHJvcGVydHkuemlwX2NvZGU7XG4gICAgICBcbiAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeyBhZGRyZXNzOiBhZGRyZXNzU3RyaW5nIH0sIChyZXN1bHRzLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ09LJyAmJiByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uZ2VvbWV0cnkpIHtcbiAgICAgICAgICBjb25zdCBsYXRpdHVkZSA9IHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb24ubGF0KCk7XG4gICAgICAgICAgY29uc3QgbG9uZ2l0dWRlID0gcmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJuc1xuICAgICAgICAgIGlmIChpc0dyaWRQYXR0ZXJuKGxhdGl0dWRlLCBsb25naXR1ZGUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFN1c3BpY2lvdXMgZ3JpZCBwYXR0ZXJuIGRldGVjdGVkOiAke2xhdGl0dWRlfSwgJHtsb25naXR1ZGV9YCk7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXI6ICdnb29nbGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb29nbGUgZ2VvY29kaW5nIGZhaWxlZDogJHtzdGF0dXN9YCk7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdpdGggR29vZ2xlIGdlb2NvZGluZzonLCBlcnJvcik7XG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogR2VvY29kZSBhIHByb3BlcnR5IHVzaW5nIE1hcGJveCBBUElcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5IC0gUHJvcGVydHkgb2JqZWN0IHdpdGggYWRkcmVzcyBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIC0gTWFwYm94IGFjY2VzcyB0b2tlblxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSAtIENvb3JkaW5hdGVzIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZW9jb2RlV2l0aE1hcGJveChwcm9wZXJ0eSwgYWNjZXNzVG9rZW4pIHtcbiAgdHJ5IHtcbiAgICAvLyBCdWlsZCBhZGRyZXNzIHN0cmluZ1xuICAgIGxldCBhZGRyZXNzU3RyaW5nID0gJyc7XG4gICAgaWYgKHByb3BlcnR5LmFkZHJlc3MpIGFkZHJlc3NTdHJpbmcgKz0gcHJvcGVydHkuYWRkcmVzcztcbiAgICBpZiAocHJvcGVydHkuY2l0eSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcsICcgOiAnJykgKyBwcm9wZXJ0eS5jaXR5O1xuICAgIGlmIChwcm9wZXJ0eS5zdGF0ZSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcsICcgOiAnJykgKyBwcm9wZXJ0eS5zdGF0ZTtcbiAgICBpZiAocHJvcGVydHkuemlwX2NvZGUpIGFkZHJlc3NTdHJpbmcgKz0gKGFkZHJlc3NTdHJpbmcgPyAnICcgOiAnJykgKyBwcm9wZXJ0eS56aXBfY29kZTtcbiAgICBcbiAgICAvLyBVUkwgZW5jb2RlIHRoZSBhZGRyZXNzXG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3MgPSBlbmNvZGVVUklDb21wb25lbnQoYWRkcmVzc1N0cmluZyk7XG4gICAgXG4gICAgLy8gTWFrZSBBUEkgcmVxdWVzdFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9nZW9jb2RpbmcvdjUvbWFwYm94LnBsYWNlcy8ke2VuY29kZWRBZGRyZXNzfS5qc29uP2FjY2Vzc190b2tlbj0ke2FjY2Vzc1Rva2VufWBcbiAgICApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwYm94IEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoZGF0YS5mZWF0dXJlcyAmJiBkYXRhLmZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBkYXRhLmZlYXR1cmVzWzBdO1xuICAgICAgY29uc3QgbG9uZ2l0dWRlID0gZmVhdHVyZS5jZW50ZXJbMF07XG4gICAgICBjb25zdCBsYXRpdHVkZSA9IGZlYXR1cmUuY2VudGVyWzFdO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJuc1xuICAgICAgaWYgKGlzR3JpZFBhdHRlcm4obGF0aXR1ZGUsIGxvbmdpdHVkZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTdXNwaWNpb3VzIGdyaWQgcGF0dGVybiBkZXRlY3RlZDogJHtsYXRpdHVkZX0sICR7bG9uZ2l0dWRlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgcHJvdmlkZXI6ICdtYXBib3gnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aXRoIE1hcGJveCBnZW9jb2Rpbmc6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2VvY29kZSBhIHByb3BlcnR5IHVzaW5nIE5vbWluYXRpbSBBUEkgKE9wZW5TdHJlZXRNYXApXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0eSAtIFByb3BlcnR5IG9iamVjdCB3aXRoIGFkZHJlc3MgaW5mb3JtYXRpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxudWxsPn0gLSBDb29yZGluYXRlcyBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VvY29kZVdpdGhOb21pbmF0aW0ocHJvcGVydHkpIHtcbiAgdHJ5IHtcbiAgICAvLyBCdWlsZCBhZGRyZXNzIHN0cmluZ1xuICAgIGxldCBhZGRyZXNzU3RyaW5nID0gJyc7XG4gICAgaWYgKHByb3BlcnR5LmFkZHJlc3MpIGFkZHJlc3NTdHJpbmcgKz0gcHJvcGVydHkuYWRkcmVzcztcbiAgICBpZiAocHJvcGVydHkuY2l0eSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcsICcgOiAnJykgKyBwcm9wZXJ0eS5jaXR5O1xuICAgIGlmIChwcm9wZXJ0eS5zdGF0ZSkgYWRkcmVzc1N0cmluZyArPSAoYWRkcmVzc1N0cmluZyA/ICcsICcgOiAnJykgKyBwcm9wZXJ0eS5zdGF0ZTtcbiAgICBpZiAocHJvcGVydHkuemlwX2NvZGUpIGFkZHJlc3NTdHJpbmcgKz0gKGFkZHJlc3NTdHJpbmcgPyAnICcgOiAnJykgKyBwcm9wZXJ0eS56aXBfY29kZTtcbiAgICBcbiAgICAvLyBVUkwgZW5jb2RlIHRoZSBhZGRyZXNzXG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3MgPSBlbmNvZGVVUklDb21wb25lbnQoYWRkcmVzc1N0cmluZyk7XG4gICAgXG4gICAgLy8gTWFrZSBBUEkgcmVxdWVzdCAod2l0aCBhIHJhbmRvbSBkZWxheSB0byBhdm9pZCByYXRlIGxpbWl0aW5nKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9ub21pbmF0aW0ub3BlbnN0cmVldG1hcC5vcmcvc2VhcmNoP2Zvcm1hdD1qc29uJnE9JHtlbmNvZGVkQWRkcmVzc31gLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnQWNxdWlyZVByb3BlcnR5TWFwLzEuMCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb21pbmF0aW0gQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IGxhdGl0dWRlID0gcGFyc2VGbG9hdChyZXN1bHQubGF0KTtcbiAgICAgIGNvbnN0IGxvbmdpdHVkZSA9IHBhcnNlRmxvYXQocmVzdWx0Lmxvbik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgICBpZiAoaXNHcmlkUGF0dGVybihsYXRpdHVkZSwgbG9uZ2l0dWRlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFN1c3BpY2lvdXMgZ3JpZCBwYXR0ZXJuIGRldGVjdGVkOiAke2xhdGl0dWRlfSwgJHtsb25naXR1ZGV9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBwcm92aWRlcjogJ25vbWluYXRpbSdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdpdGggTm9taW5hdGltIGdlb2NvZGluZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBjb29yZGluYXRlcyBhcmUgbGlrZWx5IHBhcnQgb2YgYSBncmlkIHBhdHRlcm5cbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IGxhdGl0dWRlIC0gTGF0aXR1ZGUgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvbmdpdHVkZSAtIExvbmdpdHVkZSBjb29yZGluYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIGxpa2VseSBhIGdyaWQgcGF0dGVybiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dyaWRQYXR0ZXJuKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgaWYgKCFsYXRpdHVkZSB8fCAhbG9uZ2l0dWRlKSByZXR1cm4gZmFsc2U7XG4gIFxuICAvLyBDb252ZXJ0IHRvIHN0cmluZ3MgZm9yIGVhc2llciBjaGVja2luZ1xuICBjb25zdCBsYXRTdHIgPSBTdHJpbmcobGF0aXR1ZGUpO1xuICBjb25zdCBsbmdTdHIgPSBTdHJpbmcobG9uZ2l0dWRlKTtcbiAgXG4gIC8vIENoZWNrIGZvciB2ZXJ5IGxvdyBwcmVjaXNpb24gY29vcmRpbmF0ZXMgKG9mdGVuIGdyaWQgcGF0dGVybnMpXG4gIGNvbnN0IGhhc0xvd1ByZWNpc2lvbiA9IFxuICAgIChsYXRTdHIuaW5jbHVkZXMoJy4nKSAmJiBsYXRTdHIuc3BsaXQoJy4nKVsxXS5sZW5ndGggPD0gMykgfHxcbiAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDMpO1xuICAgIFxuICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJuc1xuICBjb25zdCBoYXNTdXNwaWNpb3VzUGF0dGVybiA9IFxuICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IC8vIFNhbWUgbGF0L2xuZyBpcyB2ZXJ5IHVubGlrZWx5XG4gICAgbGF0U3RyLmVuZHNXaXRoKCcwMDAwMCcpIHx8IFxuICAgIGxuZ1N0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fFxuICAgIGxhdFN0ci5lbmRzV2l0aCgnLjUnKSB8fCAvLyBDb21tb24gZ3JpZCB2YWx1ZXNcbiAgICBsbmdTdHIuZW5kc1dpdGgoJy41JykgfHxcbiAgICBsYXRTdHIuZW5kc1dpdGgoJy4wJykgfHxcbiAgICBsbmdTdHIuZW5kc1dpdGgoJy4wJyk7XG4gICAgXG4gIHJldHVybiBoYXNMb3dQcmVjaXNpb24gfHwgaGFzU3VzcGljaW91c1BhdHRlcm47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHByb3BlcnR5X3Jlc2VhcmNoIHRhYmxlIGV4aXN0cyBpbiBTdXBhYmFzZVxuICogXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gLSBUcnVlIGlmIHRhYmxlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1Jlc2VhcmNoVGFibGVFeGlzdHMoKSB7XG4gIHRyeSB7XG4gICAgLy8gQXR0ZW1wdCB0byBxdWVyeSB0aGUgdGFibGVcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Byb3BlcnR5X3Jlc2VhcmNoJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5saW1pdCgxKTtcbiAgICBcbiAgICAvLyBJZiBubyBlcnJvciwgdGFibGUgZXhpc3RzXG4gICAgcmV0dXJuICFlcnJvcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyByZXNlYXJjaCB0YWJsZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogU3luY2hyb25pemUgY29vcmRpbmF0ZXMgYmV0d2VlbiBwcm9wZXJ0aWVzIGFuZCBwcm9wZXJ0eV9yZXNlYXJjaCB0YWJsZXNcbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFJlc3VsdCBvYmplY3Qgd2l0aCBzdWNjZXNzIHN0YXR1cyBhbmQgY291bnRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jUmVzZWFyY2hDb29yZGluYXRlcyhsaW1pdCA9IDEwMCkge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHRhYmxlIGV4aXN0c1xuICAgIGNvbnN0IHRhYmxlRXhpc3RzID0gYXdhaXQgY2hlY2tSZXNlYXJjaFRhYmxlRXhpc3RzKCk7XG4gICAgaWYgKCF0YWJsZUV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6ICdQcm9wZXJ0eSByZXNlYXJjaCB0YWJsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZScsXG4gICAgICAgIHVwZGF0ZWQ6IDAsXG4gICAgICAgIGVycm9yczogMFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHByb3BlcnRpZXMgbWlzc2luZyBvciB3aXRoIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXNcbiAgICBjb25zdCB7IGRhdGE6IHByb3BlcnRpZXMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Byb3BlcnRpZXMnKVxuICAgICAgLnNlbGVjdCgnaWQsIGFkZHJlc3MsIGNpdHksIHN0YXRlLCB6aXBfY29kZSwgbGF0aXR1ZGUsIGxvbmdpdHVkZScpXG4gICAgICAubGltaXQobGltaXQpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIHByb3BlcnRpZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFwcm9wZXJ0aWVzIHx8IHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiAnTm8gcHJvcGVydGllcyBmb3VuZCB0byBzeW5jaHJvbml6ZScsXG4gICAgICAgIHVwZGF0ZWQ6IDAsXG4gICAgICAgIGVycm9yczogMFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3luY2hyb25pemUgZWFjaCBwcm9wZXJ0eVxuICAgIGxldCB1cGRhdGVkID0gMDtcbiAgICBsZXQgZXJyb3JzID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHByb3BlcnR5IGhhcyB2YWxpZCBjb29yZGluYXRlcywgdXBkYXRlIHByb3BlcnR5X3Jlc2VhcmNoXG4gICAgICAgIGlmIChwcm9wZXJ0eS5sYXRpdHVkZSAmJiBwcm9wZXJ0eS5sb25naXR1ZGUgJiYgXG4gICAgICAgICAgICAhaXNHcmlkUGF0dGVybihwcm9wZXJ0eS5sYXRpdHVkZSwgcHJvcGVydHkubG9uZ2l0dWRlKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBwcm9wZXJ0eV9yZXNlYXJjaCByZWNvcmRcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlc2VhcmNoLCBlcnJvcjogcmVzZWFyY2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdwcm9wZXJ0eV9yZXNlYXJjaCcpXG4gICAgICAgICAgICAuc2VsZWN0KCdpZCwgbW9kdWxlcycpXG4gICAgICAgICAgICAuZXEoJ3Byb3BlcnR5X2lkJywgcHJvcGVydHkuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgaWYgKHJlc2VhcmNoRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHJlc2VhcmNoIGZvciBwcm9wZXJ0eSAke3Byb3BlcnR5LmlkfTpgLCByZXNlYXJjaEVycm9yKTtcbiAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXNlYXJjaCAmJiByZXNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgbW9kdWxlcyB3aXRoIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb25zdCByZXNlYXJjaFJlY29yZCA9IHJlc2VhcmNoWzBdO1xuICAgICAgICAgICAgbGV0IG1vZHVsZXMgPSByZXNlYXJjaFJlY29yZC5tb2R1bGVzIHx8IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgcHJvcGVydHlfZGV0YWlscyBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoIW1vZHVsZXMucHJvcGVydHlfZGV0YWlscykge1xuICAgICAgICAgICAgICBtb2R1bGVzLnByb3BlcnR5X2RldGFpbHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBtb2R1bGVzLnByb3BlcnR5X2RldGFpbHMubGF0aXR1ZGUgPSBwcm9wZXJ0eS5sYXRpdHVkZTtcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy5sb25naXR1ZGUgPSBwcm9wZXJ0eS5sb25naXR1ZGU7XG4gICAgICAgICAgICBtb2R1bGVzLnByb3BlcnR5X2RldGFpbHMuYWRkcmVzcyA9IHByb3BlcnR5LmFkZHJlc3M7XG4gICAgICAgICAgICBtb2R1bGVzLnByb3BlcnR5X2RldGFpbHMuY2l0eSA9IHByb3BlcnR5LmNpdHk7XG4gICAgICAgICAgICBtb2R1bGVzLnByb3BlcnR5X2RldGFpbHMuc3RhdGUgPSBwcm9wZXJ0eS5zdGF0ZTtcbiAgICAgICAgICAgIG1vZHVsZXMucHJvcGVydHlfZGV0YWlscy56aXBfY29kZSA9IHByb3BlcnR5LnppcF9jb2RlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJvcGVydHlfcmVzZWFyY2hcbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgncHJvcGVydHlfcmVzZWFyY2gnKVxuICAgICAgICAgICAgICAudXBkYXRlKHsgbW9kdWxlcyB9KVxuICAgICAgICAgICAgICAuZXEoJ2lkJywgcmVzZWFyY2hSZWNvcmQuaWQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyByZXNlYXJjaCBmb3IgcHJvcGVydHkgJHtwcm9wZXJ0eS5pZH06YCwgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHByb3BlcnR5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwcm9wZXJ0eSAke3Byb3BlcnR5LmlkfTpgLCBwcm9wZXJ0eUVycm9yKTtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogYFN5bmNocm9uaXplZCAke3VwZGF0ZWR9IHByb3BlcnRpZXMgd2l0aCAke2Vycm9yc30gZXJyb3JzYCxcbiAgICAgIHVwZGF0ZWQsXG4gICAgICBlcnJvcnNcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN5bmNSZXNlYXJjaENvb3JkaW5hdGVzOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgIHVwZGF0ZWQ6IDAsXG4gICAgICBlcnJvcnM6IDFcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZWQgYmF0Y2ggZ2VvY29kaW5nIGZ1bmN0aW9uIHRoYXQgYXR0ZW1wdHMgbXVsdGlwbGUgbWV0aG9kcyBvZiBnZW9jb2RpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgQXJyYXkgb2YgcHJvcGVydGllcyB0byBnZW9jb2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc0NhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIChwcm9wZXJ0eSwgc3RhdHVzLCBkZXRhaWxzKSA9PiB7fVxuICogQHJldHVybnMge0FycmF5fSBVcGRhdGVkIHByb3BlcnRpZXMgd2l0aCBnZW9jb2RpbmcgcmVzdWx0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5oYW5jZWRHZW9jb2RlUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBwcm9ncmVzc0NhbGxiYWNrID0gbnVsbCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcGVydGllcykgfHwgcHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIHByb3BlcnRpZXMgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsc1xuICBjb25zdCBwcm9wZXJ0aWVzQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcykpO1xuXG4gIC8vIFByb2Nlc3MgZWFjaCBwcm9wZXJ0eVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXNDb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzQ29weVtpXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU2tpcCBwcm9wZXJ0aWVzIHRoYXQgYWxyZWFkeSBoYXZlIHZhbGlkIGNvb3JkaW5hdGVzXG4gICAgICBpZiAocHJvcGVydHkubGF0aXR1ZGUgJiYgXG4gICAgICAgICAgcHJvcGVydHkubG9uZ2l0dWRlICYmIFxuICAgICAgICAgIHByb3BlcnR5LmxhdGl0dWRlICE9PSAwICYmIFxuICAgICAgICAgIHByb3BlcnR5LmxvbmdpdHVkZSAhPT0gMCAmJiBcbiAgICAgICAgICAhcHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyAmJiBcbiAgICAgICAgICAhcHJvcGVydHkuX2Nvb3JkaW5hdGVzX21pc3NpbmcgJiZcbiAgICAgICAgICAhcHJvcGVydHkuX2lzX2dyaWRfcGF0dGVybikge1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyayBhcyBoYXZpbmcgZXhpc3RpbmcgdmFsaWQgY29vcmRpbmF0ZXNcbiAgICAgICAgcHJvcGVydHkuX2dlb2NvZGluZ19zb3VyY2UgPSAnZXhpc3RpbmcnO1xuICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kZWQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnc2tpcHBlZCcsICdhbHJlYWR5IGhhcyB2YWxpZCBjb29yZGluYXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAncHJvY2Vzc2luZycsICdzdGFydGluZyBnZW9jb2RpbmcgcHJvY2VzcycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaXJzdCwgdHJ5IGdlb2NvZGluZyB3aXRoIHZlcmlmaWVkIGFkZHJlc3MgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAocHJvcGVydHkudmVyaWZpZWRfYWRkcmVzcykge1xuICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdhdHRlbXB0JywgJ3VzaW5nIHZlcmlmaWVkIGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZ2VvY29kZVJlc3VsdCA9IGF3YWl0IGdlb2NvZGVBZGRyZXNzKHByb3BlcnR5LnZlcmlmaWVkX2FkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGdlb2NvZGVSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHByb3BlcnR5LmxhdGl0dWRlID0gZ2VvY29kZVJlc3VsdC5sYXQ7XG4gICAgICAgICAgcHJvcGVydHkubG9uZ2l0dWRlID0gZ2VvY29kZVJlc3VsdC5sbmc7XG4gICAgICAgICAgcHJvcGVydHkuX2dlb2NvZGluZ19zb3VyY2UgPSAndmVyaWZpZWRfYWRkcmVzcyc7XG4gICAgICAgICAgcHJvcGVydHkuX2dlb2NvZGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9wZXJ0eS5fbmVlZHNfZ2VvY29kaW5nID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuX2lzX2dyaWRfcGF0dGVybiA9IGZhbHNlO1xuICAgICAgICAgIHByb3BlcnR5Ll9jb29yZGluYXRlc19taXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuZ2VvY29kZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdzdWNjZXNzJywgJ3ZlcmlmaWVkIGFkZHJlc3MgZ2VvY29kZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTmV4dCwgdHJ5IHdpdGggdGhlIGZ1bGwgYWRkcmVzc1xuICAgICAgaWYgKHByb3BlcnR5LmFkZHJlc3MpIHtcbiAgICAgICAgbGV0IGZ1bGxBZGRyZXNzID0gcHJvcGVydHkuYWRkcmVzcztcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjaXR5LCBzdGF0ZSBpZiB0aGV5IGV4aXN0IGFuZCBhcmVuJ3QgYWxyZWFkeSBpbiB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAocHJvcGVydHkuY2l0eSAmJiAhZnVsbEFkZHJlc3MuaW5jbHVkZXMocHJvcGVydHkuY2l0eSkpIHtcbiAgICAgICAgICBmdWxsQWRkcmVzcyArPSBgLCAke3Byb3BlcnR5LmNpdHl9YDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHByb3BlcnR5LnN0YXRlICYmICFmdWxsQWRkcmVzcy5pbmNsdWRlcyhwcm9wZXJ0eS5zdGF0ZSkpIHtcbiAgICAgICAgICBmdWxsQWRkcmVzcyArPSBgLCAke3Byb3BlcnR5LnN0YXRlfWA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB6aXAgY29kZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBhbHJlYWR5IGluIHRoZSBhZGRyZXNzXG4gICAgICAgIGlmIChwcm9wZXJ0eS56aXAgJiYgIWZ1bGxBZGRyZXNzLmluY2x1ZGVzKHByb3BlcnR5LnppcCkpIHtcbiAgICAgICAgICBmdWxsQWRkcmVzcyArPSBgICR7cHJvcGVydHkuemlwfWA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ2F0dGVtcHQnLCAndXNpbmcgZnVsbCBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGdlb2NvZGVSZXN1bHQgPSBhd2FpdCBnZW9jb2RlQWRkcmVzcyhmdWxsQWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VvY29kZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcHJvcGVydHkubGF0aXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxhdDtcbiAgICAgICAgICBwcm9wZXJ0eS5sb25naXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxuZztcbiAgICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX3NvdXJjZSA9ICdmdWxsX2FkZHJlc3MnO1xuICAgICAgICAgIHByb3BlcnR5Ll9nZW9jb2RlZCA9IHRydWU7XG4gICAgICAgICAgcHJvcGVydHkuX25lZWRzX2dlb2NvZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHByb3BlcnR5Ll9pc19ncmlkX3BhdHRlcm4gPSBmYWxzZTtcbiAgICAgICAgICBwcm9wZXJ0eS5fY29vcmRpbmF0ZXNfbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgIHByb3BlcnR5Lmdlb2NvZGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnc3VjY2VzcycsICdmdWxsIGFkZHJlc3MgZ2VvY29kZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHRyeSBnZW9jb2RpbmcgYmFzZWQgb24gdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgIC8vIFRoaXMgaXMgYSBsYXN0IHJlc29ydCBhbmQgbWlnaHQgbm90IGJlIGFjY3VyYXRlXG4gICAgICBpZiAocHJvcGVydHkubmFtZSkge1xuICAgICAgICAvLyBGb3JtYXQgdGhlIG5hbWUgZm9yIGdlb2NvZGluZ1xuICAgICAgICAvLyBBZGQgXCJBdXN0aW4sIFRYXCIgc2luY2UgbW9zdCBwcm9wZXJ0aWVzIGFyZSBpbiBBdXN0aW5cbiAgICAgICAgY29uc3Qgc2VhcmNoVGVybSA9IGAke3Byb3BlcnR5Lm5hbWV9LCAke3Byb3BlcnR5LmNpdHkgfHwgJ0F1c3Rpbid9LCAke3Byb3BlcnR5LnN0YXRlIHx8ICdUWCd9YDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ2F0dGVtcHQnLCAndXNpbmcgcHJvcGVydHkgbmFtZSBhcyBsYXN0IHJlc29ydCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBnZW9jb2RlUmVzdWx0ID0gYXdhaXQgZ2VvY29kZUFkZHJlc3Moc2VhcmNoVGVybSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VvY29kZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcHJvcGVydHkubGF0aXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxhdDtcbiAgICAgICAgICBwcm9wZXJ0eS5sb25naXR1ZGUgPSBnZW9jb2RlUmVzdWx0LmxuZztcbiAgICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX3NvdXJjZSA9ICdwcm9wZXJ0eV9uYW1lJztcbiAgICAgICAgICBwcm9wZXJ0eS5fZ2VvY29kZWQgPSB0cnVlO1xuICAgICAgICAgIHByb3BlcnR5Ll9uZWVkc19nZW9jb2RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAvLyBTdGlsbCBtYXJrIHRoZXNlIGFzIHBvdGVudGlhbGx5IGdyaWQgcGF0dGVybiBzaW5jZSB0aGV5J3JlIGxlc3MgcmVsaWFibGVcbiAgICAgICAgICBwcm9wZXJ0eS5faXNfZ3JpZF9wYXR0ZXJuID0gZmFsc2U7XG4gICAgICAgICAgcHJvcGVydHkuX2Nvb3JkaW5hdGVzX21pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICBwcm9wZXJ0eS5nZW9jb2RlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwcm9wZXJ0eSwgJ3N1Y2Nlc3MnLCAncHJvcGVydHkgbmFtZSBnZW9jb2RlZCAobGVzcyBhY2N1cmF0ZSknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIGFsbCBnZW9jb2RpbmcgYXR0ZW1wdHMgZmFpbGVkXG4gICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX2ZhaWxlZCA9IHRydWU7XG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHByb3BlcnR5LCAnZXJyb3InLCAnYWxsIGdlb2NvZGluZyBtZXRob2RzIGZhaWxlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdlb2NvZGluZyBwcm9wZXJ0eSAke3Byb3BlcnR5LmlkfTpgLCBlcnJvcik7XG4gICAgICBwcm9wZXJ0eS5fZ2VvY29kaW5nX2ZhaWxlZCA9IHRydWU7XG4gICAgICBcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvcGVydHksICdlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0aWVzQ29weTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBwcm9wZXJ0eSBoYXMgdmFsaWQgY29vcmRpbmF0ZXNcbiAqL1xuY29uc3QgaGFzVmFsaWRDb29yZGluYXRlcyA9IChwcm9wZXJ0eSkgPT4ge1xuICBpZiAoIXByb3BlcnR5KSByZXR1cm4gZmFsc2U7XG4gIFxuICBpZiAoIXByb3BlcnR5LmxhdGl0dWRlIHx8ICFwcm9wZXJ0eS5sb25naXR1ZGUpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIENvbnZlcnQgdG8gbnVtYmVycyBpZiBuZWVkZWRcbiAgY29uc3QgbGF0ID0gdHlwZW9mIHByb3BlcnR5LmxhdGl0dWRlID09PSAnbnVtYmVyJyA/IHByb3BlcnR5LmxhdGl0dWRlIDogcGFyc2VGbG9hdChTdHJpbmcocHJvcGVydHkubGF0aXR1ZGUpKTtcbiAgY29uc3QgbG5nID0gdHlwZW9mIHByb3BlcnR5LmxvbmdpdHVkZSA9PT0gJ251bWJlcicgPyBwcm9wZXJ0eS5sb25naXR1ZGUgOiBwYXJzZUZsb2F0KFN0cmluZyhwcm9wZXJ0eS5sb25naXR1ZGUpKTtcbiAgXG4gIC8vIENoZWNrIGZvciBOYU5cbiAgaWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgZm9yIHplcm8gdmFsdWVzIChvZnRlbiBkZWZhdWx0KVxuICBpZiAobGF0ID09PSAwICYmIGxuZyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgZm9yIHJlYXNvbmFibGUgY29vcmRpbmF0ZSByYW5nZXNcbiAgaWYgKGxhdCA8IC05MCB8fCBsYXQgPiA5MCB8fCBsbmcgPCAtMTgwIHx8IGxuZyA+IDE4MCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEdlb2NvZGUgYW4gYWRkcmVzcyB1c2luZyBHb29nbGUgTWFwcyBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGdlb2NvZGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IE9iamVjdCB3aXRoIHN1Y2Nlc3MgZmxhZyBhbmQgbGF0L2xuZyBpZiBzdWNjZXNzZnVsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW9jb2RlQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGlmICghYWRkcmVzcykge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vIGFkZHJlc3MgcHJvdmlkZWQnIH07XG4gIH1cblxuICB0cnkge1xuICAgIC8vIEZpcnN0IHRyeSB0byB1c2UgdGhlIGdlb2NvZGluZyBBUEkgZW5kcG9pbnRcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzcyA9IGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2dlb2NvZGU/YWRkcmVzcz0ke2VuY29kZWRBZGRyZXNzfWApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoZGF0YSAmJiBkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZGF0YS5yZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXQsXG4gICAgICAgIGxuZzogbG9jYXRpb24ubG5nLFxuICAgICAgICBmb3JtYXR0ZWRBZGRyZXNzOiBkYXRhLnJlc3VsdHNbMF0uZm9ybWF0dGVkX2FkZHJlc3NcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vIHJlc3VsdHMgZm91bmQnIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VvY29kaW5nIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwiZ2VvY29kZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwibmVlZHNHZW9jb2RpbmciLCJmaWx0ZXIiLCJwIiwiX25lZWRzX2dlb2NvZGluZyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiX2Nvb3JkaW5hdGVzX21pc3NpbmciLCJfaXNfZ3JpZF9wYXR0ZXJuIiwiYWRkcmVzcyIsImNpdHkiLCJzdGF0ZSIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJnb29nbGVNYXBzQXZhaWxhYmxlIiwiZ29vZ2xlIiwibWFwcyIsIkdlb2NvZGVyIiwibWFwYm94VG9rZW4iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTUFQQk9YX0FDQ0VTU19UT0tFTiIsImdlb2NvZGVkUHJvcGVydGllcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJwcm9wZXJ0eSIsImdlb2NvZGVkUHJvcGVydHkiLCJjb29yZGluYXRlcyIsImdlb2NvZGVXaXRoR29vZ2xlTWFwcyIsImdlb2NvZGVXaXRoTWFwYm94IiwiZ2VvY29kZVdpdGhOb21pbmF0aW0iLCJfZ2VvY29kZWQiLCJ3YXJuIiwiZXJyb3IiLCJyZXNvbHZlIiwiZ2VvY29kZXIiLCJhZGRyZXNzU3RyaW5nIiwiemlwX2NvZGUiLCJnZW9jb2RlIiwicmVzdWx0cyIsInN0YXR1cyIsImdlb21ldHJ5IiwibG9jYXRpb24iLCJsYXQiLCJsbmciLCJpc0dyaWRQYXR0ZXJuIiwicHJvdmlkZXIiLCJhY2Nlc3NUb2tlbiIsImVuY29kZWRBZGRyZXNzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJjZW50ZXIiLCJoZWFkZXJzIiwicmVzdWx0IiwicGFyc2VGbG9hdCIsImxvbiIsImxhdFN0ciIsIlN0cmluZyIsImxuZ1N0ciIsImhhc0xvd1ByZWNpc2lvbiIsImluY2x1ZGVzIiwic3BsaXQiLCJoYXNTdXNwaWNpb3VzUGF0dGVybiIsImVuZHNXaXRoIiwiY2hlY2tSZXNlYXJjaFRhYmxlRXhpc3RzIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0Iiwic3luY1Jlc2VhcmNoQ29vcmRpbmF0ZXMiLCJ0YWJsZUV4aXN0cyIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidXBkYXRlZCIsImVycm9ycyIsInJlc2VhcmNoIiwicmVzZWFyY2hFcnJvciIsImVxIiwiaWQiLCJyZXNlYXJjaFJlY29yZCIsIm1vZHVsZXMiLCJwcm9wZXJ0eV9kZXRhaWxzIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJwcm9wZXJ0eUVycm9yIiwiZW5oYW5jZWRHZW9jb2RlUHJvcGVydGllcyIsInByb2dyZXNzQ2FsbGJhY2siLCJBcnJheSIsImlzQXJyYXkiLCJwcm9wZXJ0aWVzQ29weSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImkiLCJfZ2VvY29kaW5nX3NvdXJjZSIsInZlcmlmaWVkX2FkZHJlc3MiLCJnZW9jb2RlUmVzdWx0IiwiZ2VvY29kZUFkZHJlc3MiLCJnZW9jb2RlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImZ1bGxBZGRyZXNzIiwiemlwIiwibmFtZSIsInNlYXJjaFRlcm0iLCJfZ2VvY29kaW5nX2ZhaWxlZCIsImhhc1ZhbGlkQ29vcmRpbmF0ZXMiLCJpc05hTiIsImZvcm1hdHRlZEFkZHJlc3MiLCJmb3JtYXR0ZWRfYWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/geocoding.js\n"));

/***/ })

});
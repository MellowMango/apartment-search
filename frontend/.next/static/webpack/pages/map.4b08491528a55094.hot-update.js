"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/map",{

/***/ "./pages/map.js":
/*!**********************!*\
  !*** ./pages/map.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _src_components_Layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/components/Layout */ \"./src/components/Layout.tsx\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/supabase */ \"./lib/supabase.js\");\n/* harmony import */ var _lib_geocoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/geocoding */ \"./lib/geocoding.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Import the map component dynamically to avoid SSR issues with Leaflet\nconst MapComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"src_components_MapComponent_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../src/components/MapComponent */ \"./src/components/MapComponent.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"map.js -> \" + \"../src/components/MapComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = MapComponent;\nfunction MapPage() {\n    _s();\n    const [properties, setProperties] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedProperty, setSelectedProperty] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [geocoding, setGeocoding] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [geocodingLogs, setGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showGeocodingLogs, setShowGeocodingLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [mapBounds, setMapBounds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [totalFetched, setTotalFetched] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [dataStats, setDataStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        totalProperties: 0,\n        invalidCoordinates: 0,\n        missingCoordinates: 0,\n        zeroCoordinates: 0,\n        invalidRange: 0,\n        duplicatedLocations: 0\n    });\n    // Initial property load on page load\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        loadProperties();\n    }, []);\n    // Reload properties when map bounds change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (mapBounds) {\n            console.log(\"Map bounds changed, loading properties in the visible area\");\n            loadProperties(mapBounds);\n        }\n    }, [\n        mapBounds\n    ]);\n    // Handle map bounds changes\n    const handleBoundsChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((bounds)=>{\n        setMapBounds(bounds);\n    }, []);\n    // Calculate statistics about the property data\n    const calculateStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((propData)=>{\n        if (!propData || !Array.isArray(propData)) return;\n        const missingCoords = propData.filter((p)=>!p.latitude || !p.longitude).length;\n        const zeroCoords = propData.filter((p)=>p.latitude === 0 && p.longitude === 0).length;\n        const invalidRange = propData.filter((p)=>{\n            if (!p.latitude || !p.longitude) return false;\n            const lat = typeof p.latitude === \"number\" ? p.latitude : parseFloat(String(p.latitude));\n            const lng = typeof p.longitude === \"number\" ? p.longitude : parseFloat(String(p.longitude));\n            return isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180;\n        }).length;\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        propData.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        setDataStats({\n            totalProperties: propData.length,\n            invalidCoordinates: missingCoords + zeroCoords + invalidRange,\n            missingCoordinates: missingCoords,\n            zeroCoordinates: zeroCoords,\n            invalidRange: invalidRange,\n            duplicatedLocations: duplicatedCoords,\n            uniqueLocations: coordMap.size\n        });\n    }, []);\n    // Function to load properties with optional bounds filter\n    async function loadProperties() {\n        let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        try {\n            setLoading(true);\n            const options = {\n                sortBy: \"created_at\",\n                sortAsc: false,\n                page: 1,\n                pageSize: 1000,\n                filters: {},\n                includeIncomplete: true,\n                includeResearch: true,\n                noLimit: true // Bypass pagination to get all properties\n            };\n            // Apply bounds filter if provided\n            if (bounds) {\n                options.bounds = bounds;\n            }\n            const data = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_4__.fetchProperties)(options);\n            // Calculate statistics\n            calculateStats(data);\n            // Enhanced logging for debugging\n            console.log(\"===== MAP DEBUG =====\");\n            console.log(\"Loaded \".concat(data.length, \" properties for map\"));\n            // Check coordinate validity\n            const validCoords = data.filter((p)=>p.latitude && p.longitude && typeof p.latitude === \"number\" && typeof p.longitude === \"number\" && !(p.latitude === 0 && p.longitude === 0));\n            console.log(\"Properties with valid coordinates: \".concat(validCoords.length));\n            // Check Austin area coordinates\n            const austinCoords = validCoords.filter((p)=>p.latitude >= 29.5 && p.latitude <= 31.0 && p.longitude >= -98.0 && p.longitude <= -97.0);\n            console.log(\"Properties with coordinates in Austin area: \".concat(austinCoords.length));\n            // Look for suspicious patterns\n            const suspiciousCoords = validCoords.filter((p)=>{\n                const latStr = String(p.latitude);\n                const lngStr = String(p.longitude);\n                const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 1 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 1;\n                const hasSuspiciousPattern = latStr === lngStr || latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\");\n                return hasLowPrecision || hasSuspiciousPattern;\n            });\n            console.log(\"Properties with suspicious coordinates: \".concat(suspiciousCoords.length));\n            console.log(\"===== END DEBUG =====\");\n            setProperties(data);\n            setTotalFetched(data.length);\n        } catch (error) {\n            console.error(\"Error fetching properties:\", error);\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Function to batch geocode properties with missing coordinates\n    async function batchGeocodeProperties() {\n        try {\n            setGeocoding(true);\n            // Filter properties that need geocoding\n            const propsToGeocode = properties.filter((p)=>!p.latitude || !p.longitude || p.latitude === 0 || p.longitude === 0 || p._coordinates_missing || p._needs_geocoding || p._is_grid_pattern);\n            if (propsToGeocode.length === 0) {\n                alert(\"No properties need geocoding\");\n                setGeocoding(false);\n                return;\n            }\n            // Confirm with user\n            if (!confirm(\"This will attempt to geocode \".concat(propsToGeocode.length, \" properties with missing or invalid coordinates. Continue?\"))) {\n                setGeocoding(false);\n                return;\n            }\n            // Process in batches of 25 to avoid rate limits\n            const batchSize = 25;\n            const batches = Math.ceil(propsToGeocode.length / batchSize);\n            let successCount = 0;\n            let failCount = 0;\n            for(let i = 0; i < batches; i++){\n                const start = i * batchSize;\n                const end = Math.min(start + batchSize, propsToGeocode.length);\n                const batch = propsToGeocode.slice(start, end);\n                console.log(\"Processing batch \".concat(i + 1, \"/\").concat(batches, \" (\").concat(batch.length, \" properties)\"));\n                try {\n                    const geocodedBatch = await (0,_lib_geocoding__WEBPACK_IMPORTED_MODULE_5__.enhancedGeocodeProperties)(batch);\n                    // Count successes and failures\n                    const batchSuccess = geocodedBatch.filter((p)=>p._geocoded).length;\n                    const batchFail = geocodedBatch.filter((p)=>p._geocoding_failed).length;\n                    successCount += batchSuccess;\n                    failCount += batchFail;\n                    // Merge geocoded properties back into the main array\n                    const updatedProperties = [\n                        ...properties\n                    ];\n                    geocodedBatch.forEach((geocodedProp)=>{\n                        const index = updatedProperties.findIndex((p)=>p.id === geocodedProp.id);\n                        if (index !== -1) {\n                            updatedProperties[index] = geocodedProp;\n                        }\n                    });\n                    // Update the properties state\n                    setProperties(updatedProperties);\n                    calculateStats(updatedProperties);\n                    // Wait a bit between batches to avoid rate limits\n                    if (i < batches - 1) {\n                        await new Promise((resolve)=>setTimeout(resolve, 2000));\n                    }\n                } catch (error) {\n                    console.error(\"Error geocoding batch \".concat(i + 1, \":\"), error);\n                    failCount += batch.length;\n                }\n            }\n            alert(\"Geocoding complete:\\n\\n\".concat(successCount, \" properties successfully geocoded\\n\").concat(failCount, \" properties failed to geocode\"));\n        } catch (error) {\n            console.error(\"Error in batch geocoding:\", error);\n            alert(\"Error geocoding properties: \".concat(error.message));\n        } finally{\n            setGeocoding(false);\n        }\n    }\n    function runPropertyAnalysis() {\n        // Count properties at identical coordinates\n        const coordMap = new Map();\n        let duplicatedCoords = 0;\n        properties.forEach((p)=>{\n            if (p.latitude && p.longitude) {\n                const coordKey = \"\".concat(p.latitude, \",\").concat(p.longitude);\n                if (coordMap.has(coordKey)) {\n                    coordMap.set(coordKey, coordMap.get(coordKey) + 1);\n                    duplicatedCoords++;\n                } else {\n                    coordMap.set(coordKey, 1);\n                }\n            }\n        });\n        // Find coordinates with multiple properties\n        const multiplePropsLocations = Array.from(coordMap.entries()).filter((param)=>{\n            let [_, count] = param;\n            return count > 1;\n        }).sort((a, b)=>b[1] - a[1]); // Sort by count descending\n        const multiplePropsCount = multiplePropsLocations.reduce((sum, param)=>{\n            let [_, count] = param;\n            return sum + count;\n        }, 0);\n        const uniqueLocations = coordMap.size;\n        // Count by geocoding source if available\n        const bySource = {\n            existing: properties.filter((p)=>p._geocoding_source === \"existing\").length,\n            verified_address: properties.filter((p)=>p._geocoding_source === \"verified_address\").length,\n            full_address: properties.filter((p)=>p._geocoding_source === \"full_address\").length,\n            property_name: properties.filter((p)=>p._geocoding_source === \"property_name\").length,\n            unknown: properties.filter((p)=>p.latitude && p.longitude && !p._geocoding_source).length\n        };\n        alert(\"Map Properties Analysis:\\n\\n\" + \"- Total properties: \".concat(properties.length, \"\\n\") + \"- Properties with invalid coordinates: \".concat(dataStats.invalidCoordinates, \"\\n\") + \"   • Missing coordinates: \".concat(dataStats.missingCoordinates, \"\\n\") + \"   • Zero coordinates: \".concat(dataStats.zeroCoordinates, \"\\n\") + \"   • Invalid coordinate range: \".concat(dataStats.invalidRange, \"\\n\\n\") + \"- Unique locations on map: \".concat(uniqueLocations, \"\\n\") + \"- Properties sharing exact coordinates: \".concat(duplicatedCoords, \"\\n\") + \"- Number of shared locations: \".concat(multiplePropsLocations.length, \"\\n\\n\") + (multiplePropsLocations.length > 0 ? \"Top shared locations:\\n\" + multiplePropsLocations.slice(0, 5).map((param)=>{\n            let [coords, count] = param;\n            return \"   • \".concat(count, \" properties at \").concat(coords);\n        }).join(\"\\n\") : \"\") + \"\\n\\n\" + \"Geocoding sources:\\n\" + \"   • Existing valid: \".concat(bySource.existing, \"\\n\") + \"   • Verified address: \".concat(bySource.verified_address, \"\\n\") + \"   • Full address: \".concat(bySource.full_address, \"\\n\") + \"   • Property name: \".concat(bySource.property_name, \"\\n\") + \"   • Unknown source: \".concat(bySource.unknown, \"\\n\\n\") + \"Note: Properties at identical coordinates will appear as a single marker until clicked.\");\n    }\n    // Function to clean property data\n    async function cleanPropertyData() {\n        try {\n            // Start the cleaning process\n            setLoading(true);\n            // First, analyze the data to identify issues\n            const dataIssues = {\n                missingNames: properties.filter((p)=>!p.name || p.name.trim() === \"\").length,\n                incompleteAddresses: properties.filter((p)=>p.address && (!p.city || !p.state)).length,\n                suspiciousZeros: properties.filter((p)=>p.price === 0 || p.units === 0 || p.num_units === 0).length,\n                suspiciousCoordinates: properties.filter((p)=>{\n                    // Check for suspicious patterns in coordinates\n                    if (!p.latitude || !p.longitude) return false;\n                    const latStr = String(p.latitude);\n                    const lngStr = String(p.longitude);\n                    // Check for very low precision or suspicious patterns\n                    return latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2 || latStr === lngStr || // Same lat/lng is suspicious\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                }).length,\n                duplicateNames: findDuplicates(properties, \"name\"),\n                duplicateAddresses: findDuplicates(properties, \"address\"),\n                testProperties: properties.filter((p)=>p.name && p.name.toLowerCase().includes(\"test\") || p.name && p.name.toLowerCase().includes(\"example\") || p.address && p.address.toLowerCase().includes(\"test\") || p._is_test_property).length\n            };\n            const totalIssues = dataIssues.missingNames + dataIssues.incompleteAddresses + dataIssues.suspiciousZeros + dataIssues.suspiciousCoordinates + dataIssues.duplicateNames.length + dataIssues.duplicateAddresses.length + dataIssues.testProperties;\n            // No issues found\n            if (totalIssues === 0) {\n                alert(\"No data issues found that need cleaning\");\n                setLoading(false);\n                return;\n            }\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(totalIssues, \" data quality issues:\\n\\n\") + \"- \".concat(dataIssues.missingNames, \" properties missing names\\n\") + \"- \".concat(dataIssues.incompleteAddresses, \" properties with incomplete addresses\\n\") + \"- \".concat(dataIssues.suspiciousZeros, \" properties with suspicious zero values\\n\") + \"- \".concat(dataIssues.suspiciousCoordinates, \" properties with suspicious coordinates\\n\") + \"- \".concat(dataIssues.duplicateNames.length, \" duplicate property names\\n\") + \"- \".concat(dataIssues.duplicateAddresses.length, \" duplicate addresses\\n\") + \"- \".concat(dataIssues.testProperties, \" potential test/example properties\\n\\n\") + \"Would you like to clean these issues?\");\n            if (!confirmation) {\n                setLoading(false);\n                return;\n            }\n            // Optional: offer advanced options\n            const advancedOptions = confirm(\"Would you like to use advanced cleaning options?\\n\\n\" + \"- Fix missing names and extract city/state from addresses\\n\" + \"- Flag suspicious coordinates for geocoding\\n\" + \"- Identify and flag duplicate properties\\n\" + \"- Flag test properties for filtering\\n\\n\" + \"Select 'Cancel' for basic cleaning only.\");\n            // Apply fixes to a copy of the properties\n            const cleanedProperties = [\n                ...properties\n            ];\n            // Clean property names\n            let issuesCleaned = 0;\n            properties.forEach((property, index)=>{\n                let propertyCleaned = false;\n                let cleaningNotes = [];\n                // Fix missing names using address\n                if (!property.name || property.name.trim() === \"\") {\n                    if (property.address) {\n                        cleanedProperties[index].name = \"Property at \".concat(property.address.split(\",\")[0]);\n                    } else {\n                        cleanedProperties[index].name = \"Unnamed Property \".concat(property.id.toString().substring(0, 8));\n                    }\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Missing name fixed\");\n                }\n                // Fix missing city/state if address exists\n                if (property.address && (!property.city || !property.state)) {\n                    // Try to extract city and state from address\n                    const addressParts = property.address.split(\",\").map((p)=>p.trim());\n                    if (addressParts.length >= 2 && !property.city) {\n                        cleanedProperties[index].city = addressParts[addressParts.length - 2];\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"City extracted from address\");\n                    }\n                    if (addressParts.length >= 1 && !property.state) {\n                        // Try to extract state from the last part of the address\n                        const statePart = addressParts[addressParts.length - 1];\n                        const stateMatch = statePart.match(/[A-Z]{2}/);\n                        if (stateMatch) {\n                            cleanedProperties[index].state = stateMatch[0];\n                            propertyCleaned = true;\n                            cleaningNotes.push(\"State extracted from address\");\n                        }\n                    }\n                }\n                // Flag suspicious coordinates for advanced cleaning\n                if (advancedOptions) {\n                    const latStr = String(property.latitude || \"\");\n                    const lngStr = String(property.longitude || \"\");\n                    // Check for suspicious patterns in coordinates\n                    const hasLowPrecision = latStr.includes(\".\") && latStr.split(\".\")[1].length <= 2 || lngStr.includes(\".\") && lngStr.split(\".\")[1].length <= 2;\n                    const hasSuspiciousPattern = latStr === lngStr || // Same lat/lng is very unlikely\n                    latStr.endsWith(\"00000\") || lngStr.endsWith(\"00000\") || latStr.endsWith(\".0\") || lngStr.endsWith(\".0\") || latStr.endsWith(\".5\") || lngStr.endsWith(\".5\");\n                    if (hasLowPrecision || hasSuspiciousPattern) {\n                        cleanedProperties[index]._is_grid_pattern = true;\n                        cleanedProperties[index]._needs_geocoding = true;\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged suspicious coordinates for geocoding\");\n                    }\n                }\n                // Flag test properties\n                if (property.name && property.name.toLowerCase().includes(\"test\") || property.name && property.name.toLowerCase().includes(\"example\") || property.address && property.address.toLowerCase().includes(\"test\")) {\n                    cleanedProperties[index]._is_test_property = true;\n                    propertyCleaned = true;\n                    cleaningNotes.push(\"Flagged as test property\");\n                }\n                // Flag suspicious zeros for advanced cleaning\n                if (advancedOptions && (property.price === 0 || property.units === 0 || property.num_units === 0)) {\n                    // We'll just flag these for now, manual review is needed\n                    if (!cleanedProperties[index]._data_quality_issues) {\n                        cleanedProperties[index]._data_quality_issues = [];\n                    }\n                    if (property.price === 0) {\n                        cleanedProperties[index]._data_quality_issues.push(\"zero_price\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged zero price\");\n                    }\n                    if (property.units === 0 || property.num_units === 0) {\n                        cleanedProperties[index]._data_quality_issues.push(\"zero_units\");\n                        propertyCleaned = true;\n                        cleaningNotes.push(\"Flagged zero units\");\n                    }\n                }\n                // Update property with cleaning information\n                if (propertyCleaned) {\n                    cleanedProperties[index]._data_cleaned = true;\n                    cleanedProperties[index]._cleaning_notes = cleaningNotes.join(\", \");\n                    issuesCleaned++;\n                }\n            });\n            // Update state with cleaned properties\n            setProperties(cleanedProperties);\n            calculateStats(cleanedProperties);\n            // Alert user of results\n            alert(\"Data cleaning complete!\\n\\n\" + \"- \".concat(issuesCleaned, \" properties were cleaned\\n\") + \"- Added names to \".concat(dataIssues.missingNames, \" properties\\n\") + \"- Extracted city/state for \".concat(dataIssues.incompleteAddresses, \" properties\\n\") + \"- Flagged \".concat(dataIssues.suspiciousCoordinates, \" suspicious coordinates for geocoding\\n\") + \"- Identified \".concat(dataIssues.duplicateNames.length, \" duplicate names\\n\") + \"- Flagged \".concat(dataIssues.testProperties, \" test properties\\n\\n\") + \"Next steps:\\n\" + '1. Use \"Batch Geocode\" to fix flagged coordinates\\n' + '2. Use \"Properties Analysis\" to review data quality\\n' + \"3. Some properties still require manual review\");\n        } catch (error) {\n            console.error(\"Error cleaning property data:\", error);\n            alert(\"Error cleaning data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Helper function to find duplicates in properties by field\n    function findDuplicates(array, key) {\n        const counts = {};\n        const duplicates = [];\n        // Skip entries with empty values\n        array.forEach((item)=>{\n            if (item[key] && item[key].trim() !== \"\") {\n                const value = item[key].toLowerCase().trim();\n                counts[value] = (counts[value] || 0) + 1;\n            }\n        });\n        // Find values that appear more than once\n        Object.keys(counts).forEach((value)=>{\n            if (counts[value] > 1) {\n                duplicates.push({\n                    value,\n                    count: counts[value]\n                });\n            }\n        });\n        return duplicates;\n    }\n    // Function to enrich property data with zero values\n    async function enrichPropertyData() {\n        try {\n            setLoading(true);\n            // Identify properties with suspicious zero values\n            const suspiciousProperties = properties.filter((p)=>p.price === 0 || p.units === 0 || p.num_units === 0);\n            if (suspiciousProperties.length === 0) {\n                alert(\"No properties with suspicious zero values found\");\n                setLoading(false);\n                return;\n            }\n            // Confirm with user\n            const confirmation = confirm(\"Found \".concat(suspiciousProperties.length, \" properties with suspicious zero values:\\n\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.price === 0).length, \" properties with zero price\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0 || p.num_units === 0).length, \" properties with zero units\\n\\n\") + \"Would you like to attempt to enrich these properties?\");\n            if (!confirmation) {\n                setLoading(false);\n                return;\n            }\n            // Make a copy of the properties for enrichment\n            const enrichedProperties = [\n                ...properties\n            ];\n            let enrichedCount = 0;\n            // Analyze collections of similar properties to derive estimates\n            // Group properties by city/state for better comparison\n            const cityStateGroups = {};\n            properties.forEach((p)=>{\n                if (p.city && p.state && p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)) {\n                    const key = \"\".concat(p.city.toLowerCase(), \",\").concat(p.state.toLowerCase());\n                    if (!cityStateGroups[key]) {\n                        cityStateGroups[key] = [];\n                    }\n                    cityStateGroups[key].push(p);\n                }\n            });\n            // Calculate median values per city/state\n            const medianValues = {};\n            Object.keys(cityStateGroups).forEach((key)=>{\n                const group = cityStateGroups[key];\n                if (group.length >= 3) {\n                    // Calculate median price per unit\n                    const pricesPerUnit = group.map((p)=>{\n                        const units = p.units || p.num_units || 0;\n                        return units > 0 ? p.price / units : 0;\n                    }).filter((v)=>v > 0).sort((a, b)=>a - b);\n                    const medianPricePerUnit = pricesPerUnit[Math.floor(pricesPerUnit.length / 2)];\n                    // Calculate median year built\n                    const yearBuilt = group.map((p)=>p.year_built).filter((y)=>y && y > 1900).sort((a, b)=>a - b);\n                    const medianYearBuilt = yearBuilt.length > 0 ? yearBuilt[Math.floor(yearBuilt.length / 2)] : null;\n                    medianValues[key] = {\n                        medianPricePerUnit,\n                        medianYearBuilt,\n                        sampleSize: group.length\n                    };\n                }\n            });\n            // Enrich properties with suspicious zero values\n            suspiciousProperties.forEach((property)=>{\n                const index = enrichedProperties.findIndex((p)=>p.id === property.id);\n                if (index === -1) return;\n                let isEnriched = false;\n                let enrichmentNotes = [];\n                // Find the best reference group for this property\n                let referenceGroup = null;\n                let referenceKey = null;\n                if (property.city && property.state) {\n                    const key = \"\".concat(property.city.toLowerCase(), \",\").concat(property.state.toLowerCase());\n                    if (medianValues[key]) {\n                        referenceGroup = medianValues[key];\n                        referenceKey = key;\n                    }\n                }\n                // If no direct city/state match, use the closest geographically or a general average\n                if (!referenceGroup) {\n                    // Fall back to state-level data or general average\n                    if (property.state) {\n                        const stateGroups = Object.keys(medianValues).filter((key)=>key.endsWith(\",\".concat(property.state.toLowerCase())));\n                        if (stateGroups.length > 0) {\n                            // Use the largest sample from the state\n                            referenceKey = stateGroups.sort((a, b)=>medianValues[b].sampleSize - medianValues[a].sampleSize)[0];\n                            referenceGroup = medianValues[referenceKey];\n                        }\n                    }\n                    // If still no match, use the overall average\n                    if (!referenceGroup) {\n                        const allPricesPerUnit = properties.filter((p)=>p.price && p.price > 0 && (p.units > 0 || p.num_units > 0)).map((p)=>p.price / (p.units || p.num_units)).sort((a, b)=>a - b);\n                        if (allPricesPerUnit.length > 0) {\n                            referenceGroup = {\n                                medianPricePerUnit: allPricesPerUnit[Math.floor(allPricesPerUnit.length / 2)],\n                                medianYearBuilt: null,\n                                sampleSize: allPricesPerUnit.length\n                            };\n                            referenceKey = \"all_properties\";\n                        }\n                    }\n                }\n                // Calculate missing values\n                if (referenceGroup) {\n                    // Fix zero price if units are available\n                    if (property.price === 0 && (property.units > 0 || property.num_units > 0)) {\n                        const units = property.units || property.num_units;\n                        enrichedProperties[index].price = Math.round(referenceGroup.medianPricePerUnit * units);\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated price based on \".concat(referenceKey, \" median ($\").concat(Math.round(referenceGroup.medianPricePerUnit).toLocaleString(), \"/unit)\"));\n                    }\n                    // Fix zero units if price is available\n                    if ((property.units === 0 || !property.units) && (property.num_units === 0 || !property.num_units) && property.price > 0 && referenceGroup.medianPricePerUnit > 0) {\n                        const estimatedUnits = Math.round(property.price / referenceGroup.medianPricePerUnit);\n                        enrichedProperties[index].units = estimatedUnits;\n                        enrichedProperties[index].num_units = estimatedUnits;\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated \".concat(estimatedUnits, \" units based on price and \").concat(referenceKey, \" median\"));\n                    }\n                    // Add missing year built if we have a reference\n                    if ((!property.year_built || property.year_built < 1900) && referenceGroup.medianYearBuilt) {\n                        enrichedProperties[index].year_built = referenceGroup.medianYearBuilt;\n                        isEnriched = true;\n                        enrichmentNotes.push(\"Estimated year built as \".concat(referenceGroup.medianYearBuilt, \" based on \").concat(referenceKey, \" median\"));\n                    }\n                }\n                // Flag property as needing human review if we couldn't enrich it\n                if (!isEnriched) {\n                    // Mark as needing manual review\n                    if (!enrichedProperties[index]._data_quality_issues) {\n                        enrichedProperties[index]._data_quality_issues = [];\n                    }\n                    enrichedProperties[index]._data_quality_issues.push(\"needs_manual_review\");\n                    isEnriched = true;\n                    enrichmentNotes.push(\"Marked for manual review - insufficient data to make estimates\");\n                }\n                // Update property with enrichment information\n                if (isEnriched) {\n                    enrichedProperties[index]._data_enriched = true;\n                    enrichedProperties[index]._enrichment_notes = enrichmentNotes.join(\", \");\n                    enrichedCount++;\n                }\n            });\n            // Update state with enriched properties\n            setProperties(enrichedProperties);\n            calculateStats(enrichedProperties);\n            // Alert user of results\n            alert(\"Data enrichment complete!\\n\\n\" + \"- \".concat(enrichedCount, \" properties were enriched or marked for review\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.price === 0).length, \" properties with zero price processed\\n\") + \"- \".concat(suspiciousProperties.filter((p)=>p.units === 0 || p.num_units === 0).length, \" properties with zero units processed\\n\\n\") + \"Next steps:\\n\" + \"1. Review the enriched data for accuracy\\n\" + \"2. Properties marked for manual review need human attention\\n\" + '3. Use \"Properties Analysis\" to verify data quality');\n        } catch (error) {\n            console.error(\"Error enriching property data:\", error);\n            alert(\"Error enriching data: \".concat(error.message));\n        } finally{\n            setLoading(false);\n        }\n    }\n    // Function to add a log entry with timestamp\n    const addGeocodingLog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(message) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"info\";\n        const timestamp = new Date().toLocaleTimeString();\n        setGeocodingLogs((prevLogs)=>[\n                {\n                    message,\n                    timestamp,\n                    type\n                },\n                ...prevLogs.slice(0, 99) // Keep only the last 100 logs\n            ]);\n    }, []);\n    // Clear logs when starting new geocoding process\n    const clearGeocodingLogs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setGeocodingLogs([]);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_components_Layout__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n        title: \"Property Map | Austin Multifamily\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container mx-auto px-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex justify-between items-center mb-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-2xl font-bold\",\n                            children: [\n                                \"Property Map \",\n                                loading ? \"(Loading...)\" : \"(\".concat(properties.length, \" properties shown)\")\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                            lineNumber: 763,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-2\",\n                            children: loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm text-gray-500\",\n                                children: \"Loading properties...\"\n                            }, void 0, false, {\n                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                lineNumber: 769,\n                                columnNumber: 15\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-sm bg-white shadow-sm border border-gray-200 rounded px-3 py-1\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-medium\",\n                                                children: totalFetched\n                                            }, void 0, false, {\n                                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                                lineNumber: 773,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" properties fetched\",\n                                            properties.length !== totalFetched && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-gray-500 ml-1\",\n                                                children: [\n                                                    \"(\",\n                                                    totalFetched - properties.length,\n                                                    \" filtered)\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                                lineNumber: 775,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 772,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm bg-blue-100 hover:bg-blue-200 text-blue-700 rounded px-3 py-1 transition\",\n                                        onClick: runPropertyAnalysis,\n                                        children: \"Properties Analysis\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 781,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(geocoding ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-indigo-100 hover:bg-indigo-200 text-indigo-700\"),\n                                        onClick: batchGeocodeProperties,\n                                        disabled: geocoding,\n                                        children: geocoding ? \"Geocoding...\" : \"Batch Geocode\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 788,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(loading ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-amber-100 hover:bg-amber-200 text-amber-700\"),\n                                        onClick: cleanPropertyData,\n                                        disabled: loading,\n                                        children: \"Clean Data\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 800,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm rounded px-3 py-1 transition \".concat(loading ? \"bg-gray-100 text-gray-500 cursor-not-allowed\" : \"bg-purple-100 hover:bg-purple-200 text-purple-700\"),\n                                        onClick: enrichPropertyData,\n                                        disabled: loading,\n                                        children: \"Enrich Data\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 812,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded px-3 py-1 transition\",\n                                        onClick: ()=>loadProperties(),\n                                        children: \"Refresh Map\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                                        lineNumber: 824,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true)\n                        }, void 0, false, {\n                            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                            lineNumber: 767,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                    lineNumber: 762,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"h-[80vh]\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MapComponent, {\n                        properties: properties,\n                        selectedProperty: selectedProperty,\n                        setSelectedProperty: setSelectedProperty,\n                        onBoundsChange: handleBoundsChange\n                    }, void 0, false, {\n                        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                        lineNumber: 836,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n                    lineNumber: 835,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n            lineNumber: 761,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/guyma/code/projects/acquire/frontend/pages/map.js\",\n        lineNumber: 760,\n        columnNumber: 5\n    }, this);\n}\n_s(MapPage, \"cjXAp6+U/cZXiYPZLymjp+NrESk=\");\n_c1 = MapPage;\nvar _c, _c1;\n$RefreshReg$(_c, \"MapComponent\");\n$RefreshReg$(_c1, \"MapPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9zcmMvY29tcG9uZW50cy9MYXlvdXQnO1xuaW1wb3J0IHsgZmV0Y2hQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IGVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMgfSBmcm9tICcuLi9saWIvZ2VvY29kaW5nJztcblxuLy8gSW1wb3J0IHRoZSBtYXAgY29tcG9uZW50IGR5bmFtaWNhbGx5IHRvIGF2b2lkIFNTUiBpc3N1ZXMgd2l0aCBMZWFmbGV0XG5jb25zdCBNYXBDb21wb25lbnQgPSBkeW5hbWljKFxuICAoKSA9PiBpbXBvcnQoJy4uL3NyYy9jb21wb25lbnRzL01hcENvbXBvbmVudCcpLFxuICB7IHNzcjogZmFsc2UgfVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwUGFnZSgpIHtcbiAgY29uc3QgW3Byb3BlcnRpZXMsIHNldFByb3BlcnRpZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRQcm9wZXJ0eSwgc2V0U2VsZWN0ZWRQcm9wZXJ0eV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtnZW9jb2RpbmcsIHNldEdlb2NvZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtnZW9jb2RpbmdMb2dzLCBzZXRHZW9jb2RpbmdMb2dzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3Nob3dHZW9jb2RpbmdMb2dzLCBzZXRTaG93R2VvY29kaW5nTG9nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFttYXBCb3VuZHMsIHNldE1hcEJvdW5kc10gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3RvdGFsRmV0Y2hlZCwgc2V0VG90YWxGZXRjaGVkXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbZGF0YVN0YXRzLCBzZXREYXRhU3RhdHNdID0gdXNlU3RhdGUoe1xuICAgIHRvdGFsUHJvcGVydGllczogMCxcbiAgICBpbnZhbGlkQ29vcmRpbmF0ZXM6IDAsXG4gICAgbWlzc2luZ0Nvb3JkaW5hdGVzOiAwLFxuICAgIHplcm9Db29yZGluYXRlczogMCxcbiAgICBpbnZhbGlkUmFuZ2U6IDAsXG4gICAgZHVwbGljYXRlZExvY2F0aW9uczogMFxuICB9KTtcblxuICAvLyBJbml0aWFsIHByb3BlcnR5IGxvYWQgb24gcGFnZSBsb2FkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZFByb3BlcnRpZXMoKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJlbG9hZCBwcm9wZXJ0aWVzIHdoZW4gbWFwIGJvdW5kcyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwQm91bmRzKSB7XG4gICAgICBjb25zb2xlLmxvZygnTWFwIGJvdW5kcyBjaGFuZ2VkLCBsb2FkaW5nIHByb3BlcnRpZXMgaW4gdGhlIHZpc2libGUgYXJlYScpO1xuICAgICAgbG9hZFByb3BlcnRpZXMobWFwQm91bmRzKTtcbiAgICB9XG4gIH0sIFttYXBCb3VuZHNdKTtcblxuICAvLyBIYW5kbGUgbWFwIGJvdW5kcyBjaGFuZ2VzXG4gIGNvbnN0IGhhbmRsZUJvdW5kc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChib3VuZHMpID0+IHtcbiAgICBzZXRNYXBCb3VuZHMoYm91bmRzKTtcbiAgfSwgW10pO1xuXG4gIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzIGFib3V0IHRoZSBwcm9wZXJ0eSBkYXRhXG4gIGNvbnN0IGNhbGN1bGF0ZVN0YXRzID0gdXNlQ2FsbGJhY2soKHByb3BEYXRhKSA9PiB7XG4gICAgaWYgKCFwcm9wRGF0YSB8fCAhQXJyYXkuaXNBcnJheShwcm9wRGF0YSkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBtaXNzaW5nQ29vcmRzID0gcHJvcERhdGEuZmlsdGVyKHAgPT4gIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlKS5sZW5ndGg7XG4gICAgY29uc3QgemVyb0Nvb3JkcyA9IHByb3BEYXRhLmZpbHRlcihwID0+IHAubGF0aXR1ZGUgPT09IDAgJiYgcC5sb25naXR1ZGUgPT09IDApLmxlbmd0aDtcbiAgICBjb25zdCBpbnZhbGlkUmFuZ2UgPSBwcm9wRGF0YS5maWx0ZXIocCA9PiB7XG4gICAgICBpZiAoIXAubGF0aXR1ZGUgfHwgIXAubG9uZ2l0dWRlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBsYXQgPSB0eXBlb2YgcC5sYXRpdHVkZSA9PT0gJ251bWJlcicgPyBwLmxhdGl0dWRlIDogcGFyc2VGbG9hdChTdHJpbmcocC5sYXRpdHVkZSkpO1xuICAgICAgY29uc3QgbG5nID0gdHlwZW9mIHAubG9uZ2l0dWRlID09PSAnbnVtYmVyJyA/IHAubG9uZ2l0dWRlIDogcGFyc2VGbG9hdChTdHJpbmcocC5sb25naXR1ZGUpKTtcbiAgICAgIHJldHVybiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpIHx8IGxhdCA8IC05MCB8fCBsYXQgPiA5MCB8fCBsbmcgPCAtMTgwIHx8IGxuZyA+IDE4MCk7XG4gICAgfSkubGVuZ3RoO1xuICAgIFxuICAgIC8vIENvdW50IHByb3BlcnRpZXMgYXQgaWRlbnRpY2FsIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgY29vcmRNYXAgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGR1cGxpY2F0ZWRDb29yZHMgPSAwO1xuICAgIFxuICAgIHByb3BEYXRhLmZvckVhY2gocCA9PiB7XG4gICAgICBpZiAocC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSkge1xuICAgICAgICBjb25zdCBjb29yZEtleSA9IGAke3AubGF0aXR1ZGV9LCR7cC5sb25naXR1ZGV9YDtcbiAgICAgICAgaWYgKGNvb3JkTWFwLmhhcyhjb29yZEtleSkpIHtcbiAgICAgICAgICBjb29yZE1hcC5zZXQoY29vcmRLZXksIGNvb3JkTWFwLmdldChjb29yZEtleSkgKyAxKTtcbiAgICAgICAgICBkdXBsaWNhdGVkQ29vcmRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRNYXAuc2V0KGNvb3JkS2V5LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNldERhdGFTdGF0cyh7XG4gICAgICB0b3RhbFByb3BlcnRpZXM6IHByb3BEYXRhLmxlbmd0aCxcbiAgICAgIGludmFsaWRDb29yZGluYXRlczogbWlzc2luZ0Nvb3JkcyArIHplcm9Db29yZHMgKyBpbnZhbGlkUmFuZ2UsXG4gICAgICBtaXNzaW5nQ29vcmRpbmF0ZXM6IG1pc3NpbmdDb29yZHMsXG4gICAgICB6ZXJvQ29vcmRpbmF0ZXM6IHplcm9Db29yZHMsXG4gICAgICBpbnZhbGlkUmFuZ2U6IGludmFsaWRSYW5nZSxcbiAgICAgIGR1cGxpY2F0ZWRMb2NhdGlvbnM6IGR1cGxpY2F0ZWRDb29yZHMsXG4gICAgICB1bmlxdWVMb2NhdGlvbnM6IGNvb3JkTWFwLnNpemVcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGxvYWQgcHJvcGVydGllcyB3aXRoIG9wdGlvbmFsIGJvdW5kcyBmaWx0ZXJcbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFByb3BlcnRpZXMoYm91bmRzID0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgXG4gICAgICAgIHNvcnRCeTogJ2NyZWF0ZWRfYXQnLCBcbiAgICAgICAgc29ydEFzYzogZmFsc2UsXG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIHBhZ2VTaXplOiAxMDAwLFxuICAgICAgICBmaWx0ZXJzOiB7fSxcbiAgICAgICAgaW5jbHVkZUluY29tcGxldGU6IHRydWUsXG4gICAgICAgIGluY2x1ZGVSZXNlYXJjaDogdHJ1ZSxcbiAgICAgICAgbm9MaW1pdDogdHJ1ZSAvLyBCeXBhc3MgcGFnaW5hdGlvbiB0byBnZXQgYWxsIHByb3BlcnRpZXNcbiAgICAgIH07XG5cbiAgICAgIC8vIEFwcGx5IGJvdW5kcyBmaWx0ZXIgaWYgcHJvdmlkZWRcbiAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgb3B0aW9ucy5ib3VuZHMgPSBib3VuZHM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaFByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgICBjYWxjdWxhdGVTdGF0cyhkYXRhKTtcbiAgICAgIFxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmxvZyhgPT09PT0gTUFQIERFQlVHID09PT09YCk7XG4gICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7ZGF0YS5sZW5ndGh9IHByb3BlcnRpZXMgZm9yIG1hcGApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBjb29yZGluYXRlIHZhbGlkaXR5XG4gICAgICBjb25zdCB2YWxpZENvb3JkcyA9IGRhdGEuZmlsdGVyKHAgPT4gXG4gICAgICAgIHAubGF0aXR1ZGUgJiYgXG4gICAgICAgIHAubG9uZ2l0dWRlICYmIFxuICAgICAgICB0eXBlb2YgcC5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiYgXG4gICAgICAgIHR5cGVvZiBwLmxvbmdpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgIShwLmxhdGl0dWRlID09PSAwICYmIHAubG9uZ2l0dWRlID09PSAwKVxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9wZXJ0aWVzIHdpdGggdmFsaWQgY29vcmRpbmF0ZXM6ICR7dmFsaWRDb29yZHMubGVuZ3RofWApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBBdXN0aW4gYXJlYSBjb29yZGluYXRlc1xuICAgICAgY29uc3QgYXVzdGluQ29vcmRzID0gdmFsaWRDb29yZHMuZmlsdGVyKHAgPT4gXG4gICAgICAgIHAubGF0aXR1ZGUgPj0gMjkuNSAmJiBwLmxhdGl0dWRlIDw9IDMxLjAgJiYgXG4gICAgICAgIHAubG9uZ2l0dWRlID49IC05OC4wICYmIHAubG9uZ2l0dWRlIDw9IC05Ny4wXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coYFByb3BlcnRpZXMgd2l0aCBjb29yZGluYXRlcyBpbiBBdXN0aW4gYXJlYTogJHthdXN0aW5Db29yZHMubGVuZ3RofWApO1xuICAgICAgXG4gICAgICAvLyBMb29rIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gICAgICBjb25zdCBzdXNwaWNpb3VzQ29vcmRzID0gdmFsaWRDb29yZHMuZmlsdGVyKHAgPT4ge1xuICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocC5sYXRpdHVkZSk7XG4gICAgICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwLmxvbmdpdHVkZSk7XG4gICAgICAgIGNvbnN0IGhhc0xvd1ByZWNpc2lvbiA9IFxuICAgICAgICAgIChsYXRTdHIuaW5jbHVkZXMoJy4nKSAmJiBsYXRTdHIuc3BsaXQoJy4nKVsxXS5sZW5ndGggPD0gMSkgfHxcbiAgICAgICAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDEpO1xuICAgICAgICBjb25zdCBoYXNTdXNwaWNpb3VzUGF0dGVybiA9IFxuICAgICAgICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IFxuICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fCBcbiAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJzAwMDAwJyk7XG4gICAgICAgIHJldHVybiBoYXNMb3dQcmVjaXNpb24gfHwgaGFzU3VzcGljaW91c1BhdHRlcm47XG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9wZXJ0aWVzIHdpdGggc3VzcGljaW91cyBjb29yZGluYXRlczogJHtzdXNwaWNpb3VzQ29vcmRzLmxlbmd0aH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGA9PT09PSBFTkQgREVCVUcgPT09PT1gKTtcbiAgICAgIFxuICAgICAgc2V0UHJvcGVydGllcyhkYXRhKTtcbiAgICAgIHNldFRvdGFsRmV0Y2hlZChkYXRhLmxlbmd0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb3BlcnRpZXM6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvLyBGdW5jdGlvbiB0byBiYXRjaCBnZW9jb2RlIHByb3BlcnRpZXMgd2l0aCBtaXNzaW5nIGNvb3JkaW5hdGVzXG4gIGFzeW5jIGZ1bmN0aW9uIGJhdGNoR2VvY29kZVByb3BlcnRpZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNldEdlb2NvZGluZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIHByb3BlcnRpZXMgdGhhdCBuZWVkIGdlb2NvZGluZ1xuICAgICAgY29uc3QgcHJvcHNUb0dlb2NvZGUgPSBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgICAgICAhcC5sYXRpdHVkZSB8fCAhcC5sb25naXR1ZGUgfHwgXG4gICAgICAgIHAubGF0aXR1ZGUgPT09IDAgfHwgcC5sb25naXR1ZGUgPT09IDAgfHxcbiAgICAgICAgcC5fY29vcmRpbmF0ZXNfbWlzc2luZyB8fCBwLl9uZWVkc19nZW9jb2RpbmcgfHxcbiAgICAgICAgcC5faXNfZ3JpZF9wYXR0ZXJuXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAocHJvcHNUb0dlb2NvZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFsZXJ0KCdObyBwcm9wZXJ0aWVzIG5lZWQgZ2VvY29kaW5nJyk7XG4gICAgICAgIHNldEdlb2NvZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29uZmlybSB3aXRoIHVzZXJcbiAgICAgIGlmICghY29uZmlybShgVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ2VvY29kZSAke3Byb3BzVG9HZW9jb2RlLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIG1pc3Npbmcgb3IgaW52YWxpZCBjb29yZGluYXRlcy4gQ29udGludWU/YCkpIHtcbiAgICAgICAgc2V0R2VvY29kaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGluIGJhdGNoZXMgb2YgMjUgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDI1O1xuICAgICAgY29uc3QgYmF0Y2hlcyA9IE1hdGguY2VpbChwcm9wc1RvR2VvY29kZS5sZW5ndGggLyBiYXRjaFNpemUpO1xuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBsZXQgZmFpbENvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpICogYmF0Y2hTaXplO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGJhdGNoU2l6ZSwgcHJvcHNUb0dlb2NvZGUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBwcm9wc1RvR2VvY29kZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGJhdGNoICR7aSsxfS8ke2JhdGNoZXN9ICgke2JhdGNoLmxlbmd0aH0gcHJvcGVydGllcylgKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZ2VvY29kZWRCYXRjaCA9IGF3YWl0IGVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMoYmF0Y2gpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENvdW50IHN1Y2Nlc3NlcyBhbmQgZmFpbHVyZXNcbiAgICAgICAgICBjb25zdCBiYXRjaFN1Y2Nlc3MgPSBnZW9jb2RlZEJhdGNoLmZpbHRlcihwID0+IHAuX2dlb2NvZGVkKS5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgYmF0Y2hGYWlsID0gZ2VvY29kZWRCYXRjaC5maWx0ZXIocCA9PiBwLl9nZW9jb2RpbmdfZmFpbGVkKS5sZW5ndGg7XG4gICAgICAgICAgXG4gICAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGJhdGNoU3VjY2VzcztcbiAgICAgICAgICBmYWlsQ291bnQgKz0gYmF0Y2hGYWlsO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1lcmdlIGdlb2NvZGVkIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBtYWluIGFycmF5XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb3BlcnRpZXMgPSBbLi4ucHJvcGVydGllc107XG4gICAgICAgICAgZ2VvY29kZWRCYXRjaC5mb3JFYWNoKGdlb2NvZGVkUHJvcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHVwZGF0ZWRQcm9wZXJ0aWVzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IGdlb2NvZGVkUHJvcC5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRQcm9wZXJ0aWVzW2luZGV4XSA9IGdlb2NvZGVkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb3BlcnRpZXMgc3RhdGVcbiAgICAgICAgICBzZXRQcm9wZXJ0aWVzKHVwZGF0ZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBjYWxjdWxhdGVTdGF0cyh1cGRhdGVkUHJvcGVydGllcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBhIGJpdCBiZXR3ZWVuIGJhdGNoZXMgdG8gYXZvaWQgcmF0ZSBsaW1pdHNcbiAgICAgICAgICBpZiAoaSA8IGJhdGNoZXMgLSAxKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZW9jb2RpbmcgYmF0Y2ggJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICBmYWlsQ291bnQgKz0gYmF0Y2gubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGFsZXJ0KGBHZW9jb2RpbmcgY29tcGxldGU6XFxuXFxuJHtzdWNjZXNzQ291bnR9IHByb3BlcnRpZXMgc3VjY2Vzc2Z1bGx5IGdlb2NvZGVkXFxuJHtmYWlsQ291bnR9IHByb3BlcnRpZXMgZmFpbGVkIHRvIGdlb2NvZGVgKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBiYXRjaCBnZW9jb2Rpbmc6JywgZXJyb3IpO1xuICAgICAgYWxlcnQoYEVycm9yIGdlb2NvZGluZyBwcm9wZXJ0aWVzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEdlb2NvZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuUHJvcGVydHlBbmFseXNpcygpIHtcbiAgICAvLyBDb3VudCBwcm9wZXJ0aWVzIGF0IGlkZW50aWNhbCBjb29yZGluYXRlc1xuICAgIGNvbnN0IGNvb3JkTWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBkdXBsaWNhdGVkQ29vcmRzID0gMDtcbiAgICBcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICBpZiAocC5sYXRpdHVkZSAmJiBwLmxvbmdpdHVkZSkge1xuICAgICAgICBjb25zdCBjb29yZEtleSA9IGAke3AubGF0aXR1ZGV9LCR7cC5sb25naXR1ZGV9YDtcbiAgICAgICAgaWYgKGNvb3JkTWFwLmhhcyhjb29yZEtleSkpIHtcbiAgICAgICAgICBjb29yZE1hcC5zZXQoY29vcmRLZXksIGNvb3JkTWFwLmdldChjb29yZEtleSkgKyAxKTtcbiAgICAgICAgICBkdXBsaWNhdGVkQ29vcmRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRNYXAuc2V0KGNvb3JkS2V5LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZpbmQgY29vcmRpbmF0ZXMgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgY29uc3QgbXVsdGlwbGVQcm9wc0xvY2F0aW9ucyA9IEFycmF5LmZyb20oY29vcmRNYXAuZW50cmllcygpKVxuICAgICAgLmZpbHRlcigoW18sIGNvdW50XSkgPT4gY291bnQgPiAxKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTsgLy8gU29ydCBieSBjb3VudCBkZXNjZW5kaW5nXG4gICAgXG4gICAgY29uc3QgbXVsdGlwbGVQcm9wc0NvdW50ID0gbXVsdGlwbGVQcm9wc0xvY2F0aW9ucy5yZWR1Y2UoKHN1bSwgW18sIGNvdW50XSkgPT4gc3VtICsgY291bnQsIDApO1xuICAgIGNvbnN0IHVuaXF1ZUxvY2F0aW9ucyA9IGNvb3JkTWFwLnNpemU7XG4gICAgXG4gICAgLy8gQ291bnQgYnkgZ2VvY29kaW5nIHNvdXJjZSBpZiBhdmFpbGFibGVcbiAgICBjb25zdCBieVNvdXJjZSA9IHtcbiAgICAgIGV4aXN0aW5nOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAuX2dlb2NvZGluZ19zb3VyY2UgPT09ICdleGlzdGluZycpLmxlbmd0aCxcbiAgICAgIHZlcmlmaWVkX2FkZHJlc3M6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ3ZlcmlmaWVkX2FkZHJlc3MnKS5sZW5ndGgsXG4gICAgICBmdWxsX2FkZHJlc3M6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ2Z1bGxfYWRkcmVzcycpLmxlbmd0aCxcbiAgICAgIHByb3BlcnR5X25hbWU6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5fZ2VvY29kaW5nX3NvdXJjZSA9PT0gJ3Byb3BlcnR5X25hbWUnKS5sZW5ndGgsXG4gICAgICB1bmtub3duOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAubGF0aXR1ZGUgJiYgcC5sb25naXR1ZGUgJiYgIXAuX2dlb2NvZGluZ19zb3VyY2UpLmxlbmd0aFxuICAgIH07XG4gICAgXG4gICAgYWxlcnQoXG4gICAgICBgTWFwIFByb3BlcnRpZXMgQW5hbHlzaXM6XFxuXFxuYCArXG4gICAgICBgLSBUb3RhbCBwcm9wZXJ0aWVzOiAke3Byb3BlcnRpZXMubGVuZ3RofVxcbmAgK1xuICAgICAgYC0gUHJvcGVydGllcyB3aXRoIGludmFsaWQgY29vcmRpbmF0ZXM6ICR7ZGF0YVN0YXRzLmludmFsaWRDb29yZGluYXRlc31cXG5gICtcbiAgICAgIGAgICDigKIgTWlzc2luZyBjb29yZGluYXRlczogJHtkYXRhU3RhdHMubWlzc2luZ0Nvb3JkaW5hdGVzfVxcbmAgK1xuICAgICAgYCAgIOKAoiBaZXJvIGNvb3JkaW5hdGVzOiAke2RhdGFTdGF0cy56ZXJvQ29vcmRpbmF0ZXN9XFxuYCArXG4gICAgICBgICAg4oCiIEludmFsaWQgY29vcmRpbmF0ZSByYW5nZTogJHtkYXRhU3RhdHMuaW52YWxpZFJhbmdlfVxcblxcbmAgK1xuICAgICAgYC0gVW5pcXVlIGxvY2F0aW9ucyBvbiBtYXA6ICR7dW5pcXVlTG9jYXRpb25zfVxcbmAgK1xuICAgICAgYC0gUHJvcGVydGllcyBzaGFyaW5nIGV4YWN0IGNvb3JkaW5hdGVzOiAke2R1cGxpY2F0ZWRDb29yZHN9XFxuYCArXG4gICAgICBgLSBOdW1iZXIgb2Ygc2hhcmVkIGxvY2F0aW9uczogJHttdWx0aXBsZVByb3BzTG9jYXRpb25zLmxlbmd0aH1cXG5cXG5gICtcbiAgICAgIChtdWx0aXBsZVByb3BzTG9jYXRpb25zLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgYFRvcCBzaGFyZWQgbG9jYXRpb25zOlxcbmAgK1xuICAgICAgICBtdWx0aXBsZVByb3BzTG9jYXRpb25zLnNsaWNlKDAsIDUpLm1hcCgoW2Nvb3JkcywgY291bnRdKSA9PiBcbiAgICAgICAgICBgICAg4oCiICR7Y291bnR9IHByb3BlcnRpZXMgYXQgJHtjb29yZHN9YFxuICAgICAgICApLmpvaW4oJ1xcbicpIDogJycpICtcbiAgICAgIGBcXG5cXG5gICtcbiAgICAgIGBHZW9jb2Rpbmcgc291cmNlczpcXG5gICtcbiAgICAgIGAgICDigKIgRXhpc3RpbmcgdmFsaWQ6ICR7YnlTb3VyY2UuZXhpc3Rpbmd9XFxuYCArXG4gICAgICBgICAg4oCiIFZlcmlmaWVkIGFkZHJlc3M6ICR7YnlTb3VyY2UudmVyaWZpZWRfYWRkcmVzc31cXG5gICtcbiAgICAgIGAgICDigKIgRnVsbCBhZGRyZXNzOiAke2J5U291cmNlLmZ1bGxfYWRkcmVzc31cXG5gICtcbiAgICAgIGAgICDigKIgUHJvcGVydHkgbmFtZTogJHtieVNvdXJjZS5wcm9wZXJ0eV9uYW1lfVxcbmAgK1xuICAgICAgYCAgIOKAoiBVbmtub3duIHNvdXJjZTogJHtieVNvdXJjZS51bmtub3dufVxcblxcbmAgK1xuICAgICAgYE5vdGU6IFByb3BlcnRpZXMgYXQgaWRlbnRpY2FsIGNvb3JkaW5hdGVzIHdpbGwgYXBwZWFyIGFzIGEgc2luZ2xlIG1hcmtlciB1bnRpbCBjbGlja2VkLmBcbiAgICApO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gY2xlYW4gcHJvcGVydHkgZGF0YVxuICBhc3luYyBmdW5jdGlvbiBjbGVhblByb3BlcnR5RGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RhcnQgdGhlIGNsZWFuaW5nIHByb2Nlc3NcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0LCBhbmFseXplIHRoZSBkYXRhIHRvIGlkZW50aWZ5IGlzc3Vlc1xuICAgICAgY29uc3QgZGF0YUlzc3VlcyA9IHtcbiAgICAgICAgbWlzc2luZ05hbWVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+ICFwLm5hbWUgfHwgcC5uYW1lLnRyaW0oKSA9PT0gJycpLmxlbmd0aCxcbiAgICAgICAgaW5jb21wbGV0ZUFkZHJlc3NlczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBwLmFkZHJlc3MgJiYgKCFwLmNpdHkgfHwgIXAuc3RhdGUpKS5sZW5ndGgsXG4gICAgICAgIHN1c3BpY2lvdXNaZXJvczogcHJvcGVydGllcy5maWx0ZXIocCA9PiBcbiAgICAgICAgICAocC5wcmljZSA9PT0gMCB8fCBwLnVuaXRzID09PSAwIHx8IHAubnVtX3VuaXRzID09PSAwKVxuICAgICAgICApLmxlbmd0aCxcbiAgICAgICAgc3VzcGljaW91c0Nvb3JkaW5hdGVzOiBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJucyBpbiBjb29yZGluYXRlc1xuICAgICAgICAgIGlmICghcC5sYXRpdHVkZSB8fCAhcC5sb25naXR1ZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocC5sYXRpdHVkZSk7XG4gICAgICAgICAgY29uc3QgbG5nU3RyID0gU3RyaW5nKHAubG9uZ2l0dWRlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBmb3IgdmVyeSBsb3cgcHJlY2lzaW9uIG9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGxhdFN0ci5pbmNsdWRlcygnLicpICYmIGxhdFN0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAyKSB8fFxuICAgICAgICAgICAgKGxuZ1N0ci5pbmNsdWRlcygnLicpICYmIGxuZ1N0ci5zcGxpdCgnLicpWzFdLmxlbmd0aCA8PSAyKSB8fFxuICAgICAgICAgICAgbGF0U3RyID09PSBsbmdTdHIgfHwgLy8gU2FtZSBsYXQvbG5nIGlzIHN1c3BpY2lvdXNcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fCBcbiAgICAgICAgICAgIGxuZ1N0ci5lbmRzV2l0aCgnMDAwMDAnKSB8fFxuICAgICAgICAgICAgbGF0U3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy4wJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjUnKSB8fCBcbiAgICAgICAgICAgIGxuZ1N0ci5lbmRzV2l0aCgnLjUnKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLmxlbmd0aCxcbiAgICAgICAgZHVwbGljYXRlTmFtZXM6IGZpbmREdXBsaWNhdGVzKHByb3BlcnRpZXMsICduYW1lJyksXG4gICAgICAgIGR1cGxpY2F0ZUFkZHJlc3NlczogZmluZER1cGxpY2F0ZXMocHJvcGVydGllcywgJ2FkZHJlc3MnKSxcbiAgICAgICAgdGVzdFByb3BlcnRpZXM6IHByb3BlcnRpZXMuZmlsdGVyKHAgPT4gXG4gICAgICAgICAgKHAubmFtZSAmJiBwLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICAocC5uYW1lICYmIHAubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdleGFtcGxlJykpIHx8XG4gICAgICAgICAgKHAuYWRkcmVzcyAmJiBwLmFkZHJlc3MudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICBwLl9pc190ZXN0X3Byb3BlcnR5XG4gICAgICAgICkubGVuZ3RoXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbElzc3VlcyA9IGRhdGFJc3N1ZXMubWlzc2luZ05hbWVzICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3NlcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLnN1c3BpY2lvdXNaZXJvcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLnN1c3BpY2lvdXNDb29yZGluYXRlcyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLmR1cGxpY2F0ZU5hbWVzLmxlbmd0aCArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXNzdWVzLmR1cGxpY2F0ZUFkZHJlc3Nlcy5sZW5ndGggKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllcztcbiAgICAgIFxuICAgICAgLy8gTm8gaXNzdWVzIGZvdW5kXG4gICAgICBpZiAodG90YWxJc3N1ZXMgPT09IDApIHtcbiAgICAgICAgYWxlcnQoJ05vIGRhdGEgaXNzdWVzIGZvdW5kIHRoYXQgbmVlZCBjbGVhbmluZycpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb25maXJtIHdpdGggdXNlclxuICAgICAgY29uc3QgY29uZmlybWF0aW9uID0gY29uZmlybShcbiAgICAgICAgYEZvdW5kICR7dG90YWxJc3N1ZXN9IGRhdGEgcXVhbGl0eSBpc3N1ZXM6XFxuXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5taXNzaW5nTmFtZXN9IHByb3BlcnRpZXMgbWlzc2luZyBuYW1lc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3Nlc30gcHJvcGVydGllcyB3aXRoIGluY29tcGxldGUgYWRkcmVzc2VzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzWmVyb3N9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXN9IHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIGNvb3JkaW5hdGVzXFxuYCArXG4gICAgICAgIGAtICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGh9IGR1cGxpY2F0ZSBwcm9wZXJ0eSBuYW1lc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMuZHVwbGljYXRlQWRkcmVzc2VzLmxlbmd0aH0gZHVwbGljYXRlIGFkZHJlc3Nlc1xcbmAgK1xuICAgICAgICBgLSAke2RhdGFJc3N1ZXMudGVzdFByb3BlcnRpZXN9IHBvdGVudGlhbCB0ZXN0L2V4YW1wbGUgcHJvcGVydGllc1xcblxcbmAgK1xuICAgICAgICBgV291bGQgeW91IGxpa2UgdG8gY2xlYW4gdGhlc2UgaXNzdWVzP2BcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmICghY29uZmlybWF0aW9uKSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9wdGlvbmFsOiBvZmZlciBhZHZhbmNlZCBvcHRpb25zXG4gICAgICBjb25zdCBhZHZhbmNlZE9wdGlvbnMgPSBjb25maXJtKFxuICAgICAgICBcIldvdWxkIHlvdSBsaWtlIHRvIHVzZSBhZHZhbmNlZCBjbGVhbmluZyBvcHRpb25zP1xcblxcblwiICtcbiAgICAgICAgXCItIEZpeCBtaXNzaW5nIG5hbWVzIGFuZCBleHRyYWN0IGNpdHkvc3RhdGUgZnJvbSBhZGRyZXNzZXNcXG5cIiArXG4gICAgICAgIFwiLSBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcblwiICtcbiAgICAgICAgXCItIElkZW50aWZ5IGFuZCBmbGFnIGR1cGxpY2F0ZSBwcm9wZXJ0aWVzXFxuXCIgK1xuICAgICAgICBcIi0gRmxhZyB0ZXN0IHByb3BlcnRpZXMgZm9yIGZpbHRlcmluZ1xcblxcblwiICtcbiAgICAgICAgXCJTZWxlY3QgJ0NhbmNlbCcgZm9yIGJhc2ljIGNsZWFuaW5nIG9ubHkuXCJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGZpeGVzIHRvIGEgY29weSBvZiB0aGUgcHJvcGVydGllc1xuICAgICAgY29uc3QgY2xlYW5lZFByb3BlcnRpZXMgPSBbLi4ucHJvcGVydGllc107XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHByb3BlcnR5IG5hbWVzXG4gICAgICBsZXQgaXNzdWVzQ2xlYW5lZCA9IDA7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5LCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHlDbGVhbmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjbGVhbmluZ05vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaXggbWlzc2luZyBuYW1lcyB1c2luZyBhZGRyZXNzXG4gICAgICAgIGlmICghcHJvcGVydHkubmFtZSB8fCBwcm9wZXJ0eS5uYW1lLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkuYWRkcmVzcykge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWUgPSBgUHJvcGVydHkgYXQgJHtwcm9wZXJ0eS5hZGRyZXNzLnNwbGl0KCcsJylbMF19YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLm5hbWUgPSBgVW5uYW1lZCBQcm9wZXJ0eSAke3Byb3BlcnR5LmlkLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BlcnR5Q2xlYW5lZCA9IHRydWU7XG4gICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdNaXNzaW5nIG5hbWUgZml4ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRml4IG1pc3NpbmcgY2l0eS9zdGF0ZSBpZiBhZGRyZXNzIGV4aXN0c1xuICAgICAgICBpZiAocHJvcGVydHkuYWRkcmVzcyAmJiAoIXByb3BlcnR5LmNpdHkgfHwgIXByb3BlcnR5LnN0YXRlKSkge1xuICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IGNpdHkgYW5kIHN0YXRlIGZyb20gYWRkcmVzc1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NQYXJ0cyA9IHByb3BlcnR5LmFkZHJlc3Muc3BsaXQoJywnKS5tYXAocCA9PiBwLnRyaW0oKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGFkZHJlc3NQYXJ0cy5sZW5ndGggPj0gMiAmJiAhcHJvcGVydHkuY2l0eSkge1xuICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLmNpdHkgPSBhZGRyZXNzUGFydHNbYWRkcmVzc1BhcnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnQ2l0eSBleHRyYWN0ZWQgZnJvbSBhZGRyZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhZGRyZXNzUGFydHMubGVuZ3RoID49IDEgJiYgIXByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBzdGF0ZSBmcm9tIHRoZSBsYXN0IHBhcnQgb2YgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlUGFydCA9IGFkZHJlc3NQYXJ0c1thZGRyZXNzUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU1hdGNoID0gc3RhdGVQYXJ0Lm1hdGNoKC9bQS1aXXsyfS8pO1xuICAgICAgICAgICAgaWYgKHN0YXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLnN0YXRlID0gc3RhdGVNYXRjaFswXTtcbiAgICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdTdGF0ZSBleHRyYWN0ZWQgZnJvbSBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGFkdmFuY2VkIGNsZWFuaW5nXG4gICAgICAgIGlmIChhZHZhbmNlZE9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsYXRTdHIgPSBTdHJpbmcocHJvcGVydHkubGF0aXR1ZGUgfHwgJycpO1xuICAgICAgICAgIGNvbnN0IGxuZ1N0ciA9IFN0cmluZyhwcm9wZXJ0eS5sb25naXR1ZGUgfHwgJycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zIGluIGNvb3JkaW5hdGVzXG4gICAgICAgICAgY29uc3QgaGFzTG93UHJlY2lzaW9uID0gXG4gICAgICAgICAgICAobGF0U3RyLmluY2x1ZGVzKCcuJykgJiYgbGF0U3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpIHx8XG4gICAgICAgICAgICAobG5nU3RyLmluY2x1ZGVzKCcuJykgJiYgbG5nU3RyLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDw9IDIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaGFzU3VzcGljaW91c1BhdHRlcm4gPSBcbiAgICAgICAgICAgIGxhdFN0ciA9PT0gbG5nU3RyIHx8IC8vIFNhbWUgbGF0L2xuZyBpcyB2ZXJ5IHVubGlrZWx5XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJzAwMDAwJykgfHxcbiAgICAgICAgICAgIGxhdFN0ci5lbmRzV2l0aCgnLjAnKSB8fFxuICAgICAgICAgICAgbG5nU3RyLmVuZHNXaXRoKCcuMCcpIHx8XG4gICAgICAgICAgICBsYXRTdHIuZW5kc1dpdGgoJy41JykgfHwgXG4gICAgICAgICAgICBsbmdTdHIuZW5kc1dpdGgoJy41Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGFzTG93UHJlY2lzaW9uIHx8IGhhc1N1c3BpY2lvdXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2lzX2dyaWRfcGF0dGVybiA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX25lZWRzX2dlb2NvZGluZyA9IHRydWU7XG4gICAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdGbGFnZ2VkIHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmxhZyB0ZXN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKChwcm9wZXJ0eS5uYW1lICYmIHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGVzdCcpKSB8fCBcbiAgICAgICAgICAgIChwcm9wZXJ0eS5uYW1lICYmIHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZXhhbXBsZScpKSB8fFxuICAgICAgICAgICAgKHByb3BlcnR5LmFkZHJlc3MgJiYgcHJvcGVydHkuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0ZXN0JykpKSB7XG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9pc190ZXN0X3Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnRmxhZ2dlZCBhcyB0ZXN0IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZsYWcgc3VzcGljaW91cyB6ZXJvcyBmb3IgYWR2YW5jZWQgY2xlYW5pbmdcbiAgICAgICAgaWYgKGFkdmFuY2VkT3B0aW9ucyAmJiAocHJvcGVydHkucHJpY2UgPT09IDAgfHwgcHJvcGVydHkudW5pdHMgPT09IDAgfHwgcHJvcGVydHkubnVtX3VuaXRzID09PSAwKSkge1xuICAgICAgICAgIC8vIFdlJ2xsIGp1c3QgZmxhZyB0aGVzZSBmb3Igbm93LCBtYW51YWwgcmV2aWV3IGlzIG5lZWRlZFxuICAgICAgICAgIGlmICghY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfcXVhbGl0eV9pc3N1ZXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHByb3BlcnR5LnByaWNlID09PSAwKSB7XG4gICAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfcXVhbGl0eV9pc3N1ZXMucHVzaCgnemVyb19wcmljZScpO1xuICAgICAgICAgICAgcHJvcGVydHlDbGVhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFuaW5nTm90ZXMucHVzaCgnRmxhZ2dlZCB6ZXJvIHByaWNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9wZXJ0eS51bml0cyA9PT0gMCB8fCBwcm9wZXJ0eS5udW1fdW5pdHMgPT09IDApIHtcbiAgICAgICAgICAgIGNsZWFuZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3Vlcy5wdXNoKCd6ZXJvX3VuaXRzJyk7XG4gICAgICAgICAgICBwcm9wZXJ0eUNsZWFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW5pbmdOb3Rlcy5wdXNoKCdGbGFnZ2VkIHplcm8gdW5pdHMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9wZXJ0eSB3aXRoIGNsZWFuaW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChwcm9wZXJ0eUNsZWFuZWQpIHtcbiAgICAgICAgICBjbGVhbmVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfY2xlYW5lZCA9IHRydWU7XG4gICAgICAgICAgY2xlYW5lZFByb3BlcnRpZXNbaW5kZXhdLl9jbGVhbmluZ19ub3RlcyA9IGNsZWFuaW5nTm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICBpc3N1ZXNDbGVhbmVkKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBjbGVhbmVkIHByb3BlcnRpZXNcbiAgICAgIHNldFByb3BlcnRpZXMoY2xlYW5lZFByb3BlcnRpZXMpO1xuICAgICAgY2FsY3VsYXRlU3RhdHMoY2xlYW5lZFByb3BlcnRpZXMpO1xuICAgICAgXG4gICAgICAvLyBBbGVydCB1c2VyIG9mIHJlc3VsdHNcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRGF0YSBjbGVhbmluZyBjb21wbGV0ZSFcXG5cXG5gICtcbiAgICAgICAgYC0gJHtpc3N1ZXNDbGVhbmVkfSBwcm9wZXJ0aWVzIHdlcmUgY2xlYW5lZFxcbmAgK1xuICAgICAgICBgLSBBZGRlZCBuYW1lcyB0byAke2RhdGFJc3N1ZXMubWlzc2luZ05hbWVzfSBwcm9wZXJ0aWVzXFxuYCArXG4gICAgICAgIGAtIEV4dHJhY3RlZCBjaXR5L3N0YXRlIGZvciAke2RhdGFJc3N1ZXMuaW5jb21wbGV0ZUFkZHJlc3Nlc30gcHJvcGVydGllc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy5zdXNwaWNpb3VzQ29vcmRpbmF0ZXN9IHN1c3BpY2lvdXMgY29vcmRpbmF0ZXMgZm9yIGdlb2NvZGluZ1xcbmAgK1xuICAgICAgICBgLSBJZGVudGlmaWVkICR7ZGF0YUlzc3Vlcy5kdXBsaWNhdGVOYW1lcy5sZW5ndGh9IGR1cGxpY2F0ZSBuYW1lc1xcbmAgK1xuICAgICAgICBgLSBGbGFnZ2VkICR7ZGF0YUlzc3Vlcy50ZXN0UHJvcGVydGllc30gdGVzdCBwcm9wZXJ0aWVzXFxuXFxuYCArXG4gICAgICAgIGBOZXh0IHN0ZXBzOlxcbmAgK1xuICAgICAgICBgMS4gVXNlIFwiQmF0Y2ggR2VvY29kZVwiIHRvIGZpeCBmbGFnZ2VkIGNvb3JkaW5hdGVzXFxuYCArXG4gICAgICAgIGAyLiBVc2UgXCJQcm9wZXJ0aWVzIEFuYWx5c2lzXCIgdG8gcmV2aWV3IGRhdGEgcXVhbGl0eVxcbmAgK1xuICAgICAgICBgMy4gU29tZSBwcm9wZXJ0aWVzIHN0aWxsIHJlcXVpcmUgbWFudWFsIHJldmlld2BcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFuaW5nIHByb3BlcnR5IGRhdGE6JywgZXJyb3IpO1xuICAgICAgYWxlcnQoYEVycm9yIGNsZWFuaW5nIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBkdXBsaWNhdGVzIGluIHByb3BlcnRpZXMgYnkgZmllbGRcbiAgZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoYXJyYXksIGtleSkge1xuICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBbXTtcbiAgICBcbiAgICAvLyBTa2lwIGVudHJpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcbiAgICBhcnJheS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW1ba2V5XSAmJiBpdGVtW2tleV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgY291bnRzW3ZhbHVlXSA9IChjb3VudHNbdmFsdWVdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBGaW5kIHZhbHVlcyB0aGF0IGFwcGVhciBtb3JlIHRoYW4gb25jZVxuICAgIE9iamVjdC5rZXlzKGNvdW50cykuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoY291bnRzW3ZhbHVlXSA+IDEpIHtcbiAgICAgICAgZHVwbGljYXRlcy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjb3VudDogY291bnRzW3ZhbHVlXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZHVwbGljYXRlcztcbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGVucmljaCBwcm9wZXJ0eSBkYXRhIHdpdGggemVybyB2YWx1ZXNcbiAgYXN5bmMgZnVuY3Rpb24gZW5yaWNoUHJvcGVydHlEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBJZGVudGlmeSBwcm9wZXJ0aWVzIHdpdGggc3VzcGljaW91cyB6ZXJvIHZhbHVlc1xuICAgICAgY29uc3Qgc3VzcGljaW91c1Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmZpbHRlcihwID0+IFxuICAgICAgICAocC5wcmljZSA9PT0gMCB8fCBwLnVuaXRzID09PSAwIHx8IHAubnVtX3VuaXRzID09PSAwKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKHN1c3BpY2lvdXNQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhbGVydCgnTm8gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXMgZm91bmQnKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29uZmlybSB3aXRoIHVzZXJcbiAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbiA9IGNvbmZpcm0oXG4gICAgICAgIGBGb3VuZCAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHN1c3BpY2lvdXMgemVybyB2YWx1ZXM6XFxuXFxuYCArXG4gICAgICAgIGAtICR7c3VzcGljaW91c1Byb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC5wcmljZSA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyBwcmljZVxcbmAgK1xuICAgICAgICBgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAudW5pdHMgPT09IDAgfHwgcC5udW1fdW5pdHMgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gdW5pdHNcXG5cXG5gICtcbiAgICAgICAgYFdvdWxkIHlvdSBsaWtlIHRvIGF0dGVtcHQgdG8gZW5yaWNoIHRoZXNlIHByb3BlcnRpZXM/YFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKCFjb25maXJtYXRpb24pIHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIHByb3BlcnRpZXMgZm9yIGVucmljaG1lbnRcbiAgICAgIGNvbnN0IGVucmljaGVkUHJvcGVydGllcyA9IFsuLi5wcm9wZXJ0aWVzXTtcbiAgICAgIGxldCBlbnJpY2hlZENvdW50ID0gMDtcbiAgICAgIFxuICAgICAgLy8gQW5hbHl6ZSBjb2xsZWN0aW9ucyBvZiBzaW1pbGFyIHByb3BlcnRpZXMgdG8gZGVyaXZlIGVzdGltYXRlc1xuICAgICAgLy8gR3JvdXAgcHJvcGVydGllcyBieSBjaXR5L3N0YXRlIGZvciBiZXR0ZXIgY29tcGFyaXNvblxuICAgICAgY29uc3QgY2l0eVN0YXRlR3JvdXBzID0ge307XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmIChwLmNpdHkgJiYgcC5zdGF0ZSAmJiBwLnByaWNlICYmIHAucHJpY2UgPiAwICYmIChwLnVuaXRzID4gMCB8fCBwLm51bV91bml0cyA+IDApKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cC5jaXR5LnRvTG93ZXJDYXNlKCl9LCR7cC5zdGF0ZS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgICAgaWYgKCFjaXR5U3RhdGVHcm91cHNba2V5XSkge1xuICAgICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2l0eVN0YXRlR3JvdXBzW2tleV0ucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4gdmFsdWVzIHBlciBjaXR5L3N0YXRlXG4gICAgICBjb25zdCBtZWRpYW5WYWx1ZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNpdHlTdGF0ZUdyb3VwcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGNpdHlTdGF0ZUdyb3Vwc1trZXldO1xuICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID49IDMpIHsgLy8gT25seSB1c2UgZ3JvdXBzIHdpdGggZW5vdWdoIGRhdGEgcG9pbnRzXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG1lZGlhbiBwcmljZSBwZXIgdW5pdFxuICAgICAgICAgIGNvbnN0IHByaWNlc1BlclVuaXQgPSBncm91cC5tYXAocCA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bml0cyA9IHAudW5pdHMgfHwgcC5udW1fdW5pdHMgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA+IDAgPyBwLnByaWNlIC8gdW5pdHMgOiAwO1xuICAgICAgICAgIH0pLmZpbHRlcih2ID0+IHYgPiAwKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbWVkaWFuUHJpY2VQZXJVbml0ID0gcHJpY2VzUGVyVW5pdFtNYXRoLmZsb29yKHByaWNlc1BlclVuaXQubGVuZ3RoIC8gMildO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBtZWRpYW4geWVhciBidWlsdFxuICAgICAgICAgIGNvbnN0IHllYXJCdWlsdCA9IGdyb3VwLm1hcChwID0+IHAueWVhcl9idWlsdCkuZmlsdGVyKHkgPT4geSAmJiB5ID4gMTkwMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgIGNvbnN0IG1lZGlhblllYXJCdWlsdCA9IHllYXJCdWlsdC5sZW5ndGggPiAwID8geWVhckJ1aWx0W01hdGguZmxvb3IoeWVhckJ1aWx0Lmxlbmd0aCAvIDIpXSA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgbWVkaWFuVmFsdWVzW2tleV0gPSB7XG4gICAgICAgICAgICBtZWRpYW5QcmljZVBlclVuaXQsXG4gICAgICAgICAgICBtZWRpYW5ZZWFyQnVpbHQsXG4gICAgICAgICAgICBzYW1wbGVTaXplOiBncm91cC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRW5yaWNoIHByb3BlcnRpZXMgd2l0aCBzdXNwaWNpb3VzIHplcm8gdmFsdWVzXG4gICAgICBzdXNwaWNpb3VzUHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBlbnJpY2hlZFByb3BlcnRpZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcHJvcGVydHkuaWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBsZXQgaXNFbnJpY2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZW5yaWNobWVudE5vdGVzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IHJlZmVyZW5jZSBncm91cCBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICBsZXQgcmVmZXJlbmNlR3JvdXAgPSBudWxsO1xuICAgICAgICBsZXQgcmVmZXJlbmNlS2V5ID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9wZXJ0eS5jaXR5ICYmIHByb3BlcnR5LnN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYCR7cHJvcGVydHkuY2l0eS50b0xvd2VyQ2FzZSgpfSwke3Byb3BlcnR5LnN0YXRlLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgICBpZiAobWVkaWFuVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwID0gbWVkaWFuVmFsdWVzW2tleV07XG4gICAgICAgICAgICByZWZlcmVuY2VLZXkgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBubyBkaXJlY3QgY2l0eS9zdGF0ZSBtYXRjaCwgdXNlIHRoZSBjbG9zZXN0IGdlb2dyYXBoaWNhbGx5IG9yIGEgZ2VuZXJhbCBhdmVyYWdlXG4gICAgICAgIGlmICghcmVmZXJlbmNlR3JvdXApIHtcbiAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gc3RhdGUtbGV2ZWwgZGF0YSBvciBnZW5lcmFsIGF2ZXJhZ2VcbiAgICAgICAgICBpZiAocHJvcGVydHkuc3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlR3JvdXBzID0gT2JqZWN0LmtleXMobWVkaWFuVmFsdWVzKS5maWx0ZXIoa2V5ID0+IFxuICAgICAgICAgICAgICBrZXkuZW5kc1dpdGgoYCwke3Byb3BlcnR5LnN0YXRlLnRvTG93ZXJDYXNlKCl9YClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzdGF0ZUdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgbGFyZ2VzdCBzYW1wbGUgZnJvbSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgcmVmZXJlbmNlS2V5ID0gc3RhdGVHcm91cHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgICAgICAgICAgbWVkaWFuVmFsdWVzW2JdLnNhbXBsZVNpemUgLSBtZWRpYW5WYWx1ZXNbYV0uc2FtcGxlU2l6ZVxuICAgICAgICAgICAgICApWzBdO1xuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cCA9IG1lZGlhblZhbHVlc1tyZWZlcmVuY2VLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJZiBzdGlsbCBubyBtYXRjaCwgdXNlIHRoZSBvdmVyYWxsIGF2ZXJhZ2VcbiAgICAgICAgICBpZiAoIXJlZmVyZW5jZUdyb3VwKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxQcmljZXNQZXJVbml0ID0gcHJvcGVydGllc1xuICAgICAgICAgICAgICAuZmlsdGVyKHAgPT4gcC5wcmljZSAmJiBwLnByaWNlID4gMCAmJiAocC51bml0cyA+IDAgfHwgcC5udW1fdW5pdHMgPiAwKSlcbiAgICAgICAgICAgICAgLm1hcChwID0+IHAucHJpY2UgLyAocC51bml0cyB8fCBwLm51bV91bml0cykpXG4gICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGFsbFByaWNlc1BlclVuaXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cCA9IHtcbiAgICAgICAgICAgICAgICBtZWRpYW5QcmljZVBlclVuaXQ6IGFsbFByaWNlc1BlclVuaXRbTWF0aC5mbG9vcihhbGxQcmljZXNQZXJVbml0Lmxlbmd0aCAvIDIpXSxcbiAgICAgICAgICAgICAgICBtZWRpYW5ZZWFyQnVpbHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZTogYWxsUHJpY2VzUGVyVW5pdC5sZW5ndGhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVmZXJlbmNlS2V5ID0gXCJhbGxfcHJvcGVydGllc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1pc3NpbmcgdmFsdWVzXG4gICAgICAgIGlmIChyZWZlcmVuY2VHcm91cCkge1xuICAgICAgICAgIC8vIEZpeCB6ZXJvIHByaWNlIGlmIHVuaXRzIGFyZSBhdmFpbGFibGVcbiAgICAgICAgICBpZiAocHJvcGVydHkucHJpY2UgPT09IDAgJiYgKHByb3BlcnR5LnVuaXRzID4gMCB8fCBwcm9wZXJ0eS5udW1fdW5pdHMgPiAwKSkge1xuICAgICAgICAgICAgY29uc3QgdW5pdHMgPSBwcm9wZXJ0eS51bml0cyB8fCBwcm9wZXJ0eS5udW1fdW5pdHM7XG4gICAgICAgICAgICBlbnJpY2hlZFByb3BlcnRpZXNbaW5kZXhdLnByaWNlID0gTWF0aC5yb3VuZChyZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQgKiB1bml0cyk7XG4gICAgICAgICAgICBpc0VucmljaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVucmljaG1lbnROb3Rlcy5wdXNoKGBFc3RpbWF0ZWQgcHJpY2UgYmFzZWQgb24gJHtyZWZlcmVuY2VLZXl9IG1lZGlhbiAoJCR7TWF0aC5yb3VuZChyZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQpLnRvTG9jYWxlU3RyaW5nKCl9L3VuaXQpYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpeCB6ZXJvIHVuaXRzIGlmIHByaWNlIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIGlmICgocHJvcGVydHkudW5pdHMgPT09IDAgfHwgIXByb3BlcnR5LnVuaXRzKSAmJiBcbiAgICAgICAgICAgICAgKHByb3BlcnR5Lm51bV91bml0cyA9PT0gMCB8fCAhcHJvcGVydHkubnVtX3VuaXRzKSAmJiBcbiAgICAgICAgICAgICAgcHJvcGVydHkucHJpY2UgPiAwICYmIFxuICAgICAgICAgICAgICByZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRVbml0cyA9IE1hdGgucm91bmQocHJvcGVydHkucHJpY2UgLyByZWZlcmVuY2VHcm91cC5tZWRpYW5QcmljZVBlclVuaXQpO1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS51bml0cyA9IGVzdGltYXRlZFVuaXRzO1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5udW1fdW5pdHMgPSBlc3RpbWF0ZWRVbml0cztcbiAgICAgICAgICAgIGlzRW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5yaWNobWVudE5vdGVzLnB1c2goYEVzdGltYXRlZCAke2VzdGltYXRlZFVuaXRzfSB1bml0cyBiYXNlZCBvbiBwcmljZSBhbmQgJHtyZWZlcmVuY2VLZXl9IG1lZGlhbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgbWlzc2luZyB5ZWFyIGJ1aWx0IGlmIHdlIGhhdmUgYSByZWZlcmVuY2VcbiAgICAgICAgICBpZiAoKCFwcm9wZXJ0eS55ZWFyX2J1aWx0IHx8IHByb3BlcnR5LnllYXJfYnVpbHQgPCAxOTAwKSAmJiByZWZlcmVuY2VHcm91cC5tZWRpYW5ZZWFyQnVpbHQpIHtcbiAgICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0ueWVhcl9idWlsdCA9IHJlZmVyZW5jZUdyb3VwLm1lZGlhblllYXJCdWlsdDtcbiAgICAgICAgICAgIGlzRW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5yaWNobWVudE5vdGVzLnB1c2goYEVzdGltYXRlZCB5ZWFyIGJ1aWx0IGFzICR7cmVmZXJlbmNlR3JvdXAubWVkaWFuWWVhckJ1aWx0fSBiYXNlZCBvbiAke3JlZmVyZW5jZUtleX0gbWVkaWFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGbGFnIHByb3BlcnR5IGFzIG5lZWRpbmcgaHVtYW4gcmV2aWV3IGlmIHdlIGNvdWxkbid0IGVucmljaCBpdFxuICAgICAgICBpZiAoIWlzRW5yaWNoZWQpIHtcbiAgICAgICAgICAvLyBNYXJrIGFzIG5lZWRpbmcgbWFudWFsIHJldmlld1xuICAgICAgICAgIGlmICghZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3Vlcykge1xuICAgICAgICAgICAgZW5yaWNoZWRQcm9wZXJ0aWVzW2luZGV4XS5fZGF0YV9xdWFsaXR5X2lzc3VlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnJpY2hlZFByb3BlcnRpZXNbaW5kZXhdLl9kYXRhX3F1YWxpdHlfaXNzdWVzLnB1c2goJ25lZWRzX21hbnVhbF9yZXZpZXcnKTtcbiAgICAgICAgICBpc0VucmljaGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbnJpY2htZW50Tm90ZXMucHVzaCgnTWFya2VkIGZvciBtYW51YWwgcmV2aWV3IC0gaW5zdWZmaWNpZW50IGRhdGEgdG8gbWFrZSBlc3RpbWF0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb3BlcnR5IHdpdGggZW5yaWNobWVudCBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoaXNFbnJpY2hlZCkge1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2RhdGFfZW5yaWNoZWQgPSB0cnVlO1xuICAgICAgICAgIGVucmljaGVkUHJvcGVydGllc1tpbmRleF0uX2VucmljaG1lbnRfbm90ZXMgPSBlbnJpY2htZW50Tm90ZXMuam9pbignLCAnKTtcbiAgICAgICAgICBlbnJpY2hlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBlbnJpY2hlZCBwcm9wZXJ0aWVzXG4gICAgICBzZXRQcm9wZXJ0aWVzKGVucmljaGVkUHJvcGVydGllcyk7XG4gICAgICBjYWxjdWxhdGVTdGF0cyhlbnJpY2hlZFByb3BlcnRpZXMpO1xuICAgICAgXG4gICAgICAvLyBBbGVydCB1c2VyIG9mIHJlc3VsdHNcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgRGF0YSBlbnJpY2htZW50IGNvbXBsZXRlIVxcblxcbmAgK1xuICAgICAgICBgLSAke2VucmljaGVkQ291bnR9IHByb3BlcnRpZXMgd2VyZSBlbnJpY2hlZCBvciBtYXJrZWQgZm9yIHJldmlld1xcbmAgK1xuICAgICAgICBgLSAke3N1c3BpY2lvdXNQcm9wZXJ0aWVzLmZpbHRlcihwID0+IHAucHJpY2UgPT09IDApLmxlbmd0aH0gcHJvcGVydGllcyB3aXRoIHplcm8gcHJpY2UgcHJvY2Vzc2VkXFxuYCArXG4gICAgICAgIGAtICR7c3VzcGljaW91c1Byb3BlcnRpZXMuZmlsdGVyKHAgPT4gcC51bml0cyA9PT0gMCB8fCBwLm51bV91bml0cyA9PT0gMCkubGVuZ3RofSBwcm9wZXJ0aWVzIHdpdGggemVybyB1bml0cyBwcm9jZXNzZWRcXG5cXG5gICtcbiAgICAgICAgYE5leHQgc3RlcHM6XFxuYCArXG4gICAgICAgIGAxLiBSZXZpZXcgdGhlIGVucmljaGVkIGRhdGEgZm9yIGFjY3VyYWN5XFxuYCArXG4gICAgICAgIGAyLiBQcm9wZXJ0aWVzIG1hcmtlZCBmb3IgbWFudWFsIHJldmlldyBuZWVkIGh1bWFuIGF0dGVudGlvblxcbmAgK1xuICAgICAgICBgMy4gVXNlIFwiUHJvcGVydGllcyBBbmFseXNpc1wiIHRvIHZlcmlmeSBkYXRhIHF1YWxpdHlgXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJpY2hpbmcgcHJvcGVydHkgZGF0YTonLCBlcnJvcik7XG4gICAgICBhbGVydChgRXJyb3IgZW5yaWNoaW5nIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbG9nIGVudHJ5IHdpdGggdGltZXN0YW1wXG4gIGNvbnN0IGFkZEdlb2NvZGluZ0xvZyA9IHVzZUNhbGxiYWNrKChtZXNzYWdlLCB0eXBlID0gJ2luZm8nKSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKHByZXZMb2dzID0+IFtcbiAgICAgIHsgbWVzc2FnZSwgdGltZXN0YW1wLCB0eXBlIH0sXG4gICAgICAuLi5wcmV2TG9ncy5zbGljZSgwLCA5OSkgLy8gS2VlcCBvbmx5IHRoZSBsYXN0IDEwMCBsb2dzXG4gICAgXSk7XG4gIH0sIFtdKTtcblxuICAvLyBDbGVhciBsb2dzIHdoZW4gc3RhcnRpbmcgbmV3IGdlb2NvZGluZyBwcm9jZXNzXG4gIGNvbnN0IGNsZWFyR2VvY29kaW5nTG9ncyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRHZW9jb2RpbmdMb2dzKFtdKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPExheW91dCB0aXRsZT1cIlByb3BlcnR5IE1hcCB8IEF1c3RpbiBNdWx0aWZhbWlseVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTRcIj5cbiAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkXCI+XG4gICAgICAgICAgICBQcm9wZXJ0eSBNYXAge2xvYWRpbmcgPyAnKExvYWRpbmcuLi4pJyA6IGAoJHtwcm9wZXJ0aWVzLmxlbmd0aH0gcHJvcGVydGllcyBzaG93bilgfVxuICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTJcIj5cbiAgICAgICAgICAgIHtsb2FkaW5nID8gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTUwMFwiPkxvYWRpbmcgcHJvcGVydGllcy4uLjwvZGl2PlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gYmctd2hpdGUgc2hhZG93LXNtIGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZCBweC0zIHB5LTFcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtXCI+e3RvdGFsRmV0Y2hlZH08L3NwYW4+IHByb3BlcnRpZXMgZmV0Y2hlZFxuICAgICAgICAgICAgICAgICAge3Byb3BlcnRpZXMubGVuZ3RoICE9PSB0b3RhbEZldGNoZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwIG1sLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAoe3RvdGFsRmV0Y2hlZCAtIHByb3BlcnRpZXMubGVuZ3RofSBmaWx0ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBiZy1ibHVlLTEwMCBob3ZlcjpiZy1ibHVlLTIwMCB0ZXh0LWJsdWUtNzAwIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17cnVuUHJvcGVydHlBbmFseXNpc31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBQcm9wZXJ0aWVzIEFuYWx5c2lzXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtc20gcm91bmRlZCBweC0zIHB5LTEgdHJhbnNpdGlvbiAke1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RpbmcgXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTUwMCBjdXJzb3Itbm90LWFsbG93ZWQnIFxuICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWluZGlnby0xMDAgaG92ZXI6YmctaW5kaWdvLTIwMCB0ZXh0LWluZGlnby03MDAnXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2JhdGNoR2VvY29kZVByb3BlcnRpZXN9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Z2VvY29kaW5nfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtnZW9jb2RpbmcgPyAnR2VvY29kaW5nLi4uJyA6ICdCYXRjaCBHZW9jb2RlJ31cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1zbSByb3VuZGVkIHB4LTMgcHktMSB0cmFuc2l0aW9uICR7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgXG4gICAgICAgICAgICAgICAgICAgICAgPyAnYmctZ3JheS0xMDAgdGV4dC1ncmF5LTUwMCBjdXJzb3Itbm90LWFsbG93ZWQnIFxuICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWFtYmVyLTEwMCBob3ZlcjpiZy1hbWJlci0yMDAgdGV4dC1hbWJlci03MDAnXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2NsZWFuUHJvcGVydHlEYXRhfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgQ2xlYW4gRGF0YVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B0ZXh0LXNtIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb24gJHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyBcbiAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ncmF5LTEwMCB0ZXh0LWdyYXktNTAwIGN1cnNvci1ub3QtYWxsb3dlZCcgXG4gICAgICAgICAgICAgICAgICAgICAgOiAnYmctcHVycGxlLTEwMCBob3ZlcjpiZy1wdXJwbGUtMjAwIHRleHQtcHVycGxlLTcwMCdcbiAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZW5yaWNoUHJvcGVydHlEYXRhfVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgRW5yaWNoIERhdGFcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBiZy1ncmVlbi0xMDAgaG92ZXI6YmctZ3JlZW4tMjAwIHRleHQtZ3JlZW4tNzAwIHJvdW5kZWQgcHgtMyBweS0xIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gbG9hZFByb3BlcnRpZXMoKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBSZWZyZXNoIE1hcFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLVs4MHZoXVwiPlxuICAgICAgICAgIDxNYXBDb21wb25lbnQgXG4gICAgICAgICAgICBwcm9wZXJ0aWVzPXtwcm9wZXJ0aWVzfSBcbiAgICAgICAgICAgIHNlbGVjdGVkUHJvcGVydHk9e3NlbGVjdGVkUHJvcGVydHl9XG4gICAgICAgICAgICBzZXRTZWxlY3RlZFByb3BlcnR5PXtzZXRTZWxlY3RlZFByb3BlcnR5fVxuICAgICAgICAgICAgb25Cb3VuZHNDaGFuZ2U9e2hhbmRsZUJvdW5kc0NoYW5nZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvTGF5b3V0PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiZHluYW1pYyIsIkxheW91dCIsImZldGNoUHJvcGVydGllcyIsImVuaGFuY2VkR2VvY29kZVByb3BlcnRpZXMiLCJNYXBDb21wb25lbnQiLCJzc3IiLCJNYXBQYWdlIiwicHJvcGVydGllcyIsInNldFByb3BlcnRpZXMiLCJzZWxlY3RlZFByb3BlcnR5Iiwic2V0U2VsZWN0ZWRQcm9wZXJ0eSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZ2VvY29kaW5nIiwic2V0R2VvY29kaW5nIiwiZ2VvY29kaW5nTG9ncyIsInNldEdlb2NvZGluZ0xvZ3MiLCJzaG93R2VvY29kaW5nTG9ncyIsInNldFNob3dHZW9jb2RpbmdMb2dzIiwibWFwQm91bmRzIiwic2V0TWFwQm91bmRzIiwidG90YWxGZXRjaGVkIiwic2V0VG90YWxGZXRjaGVkIiwiZGF0YVN0YXRzIiwic2V0RGF0YVN0YXRzIiwidG90YWxQcm9wZXJ0aWVzIiwiaW52YWxpZENvb3JkaW5hdGVzIiwibWlzc2luZ0Nvb3JkaW5hdGVzIiwiemVyb0Nvb3JkaW5hdGVzIiwiaW52YWxpZFJhbmdlIiwiZHVwbGljYXRlZExvY2F0aW9ucyIsImxvYWRQcm9wZXJ0aWVzIiwiY29uc29sZSIsImxvZyIsImhhbmRsZUJvdW5kc0NoYW5nZSIsImJvdW5kcyIsImNhbGN1bGF0ZVN0YXRzIiwicHJvcERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJtaXNzaW5nQ29vcmRzIiwiZmlsdGVyIiwicCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwibGVuZ3RoIiwiemVyb0Nvb3JkcyIsImxhdCIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJsbmciLCJpc05hTiIsImNvb3JkTWFwIiwiTWFwIiwiZHVwbGljYXRlZENvb3JkcyIsImZvckVhY2giLCJjb29yZEtleSIsImhhcyIsInNldCIsImdldCIsInVuaXF1ZUxvY2F0aW9ucyIsInNpemUiLCJvcHRpb25zIiwic29ydEJ5Iiwic29ydEFzYyIsInBhZ2UiLCJwYWdlU2l6ZSIsImZpbHRlcnMiLCJpbmNsdWRlSW5jb21wbGV0ZSIsImluY2x1ZGVSZXNlYXJjaCIsIm5vTGltaXQiLCJkYXRhIiwidmFsaWRDb29yZHMiLCJhdXN0aW5Db29yZHMiLCJzdXNwaWNpb3VzQ29vcmRzIiwibGF0U3RyIiwibG5nU3RyIiwiaGFzTG93UHJlY2lzaW9uIiwiaW5jbHVkZXMiLCJzcGxpdCIsImhhc1N1c3BpY2lvdXNQYXR0ZXJuIiwiZW5kc1dpdGgiLCJlcnJvciIsImJhdGNoR2VvY29kZVByb3BlcnRpZXMiLCJwcm9wc1RvR2VvY29kZSIsIl9jb29yZGluYXRlc19taXNzaW5nIiwiX25lZWRzX2dlb2NvZGluZyIsIl9pc19ncmlkX3BhdHRlcm4iLCJhbGVydCIsImNvbmZpcm0iLCJiYXRjaFNpemUiLCJiYXRjaGVzIiwiTWF0aCIsImNlaWwiLCJzdWNjZXNzQ291bnQiLCJmYWlsQ291bnQiLCJpIiwic3RhcnQiLCJlbmQiLCJtaW4iLCJiYXRjaCIsInNsaWNlIiwiZ2VvY29kZWRCYXRjaCIsImJhdGNoU3VjY2VzcyIsIl9nZW9jb2RlZCIsImJhdGNoRmFpbCIsIl9nZW9jb2RpbmdfZmFpbGVkIiwidXBkYXRlZFByb3BlcnRpZXMiLCJnZW9jb2RlZFByb3AiLCJpbmRleCIsImZpbmRJbmRleCIsImlkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibWVzc2FnZSIsInJ1blByb3BlcnR5QW5hbHlzaXMiLCJtdWx0aXBsZVByb3BzTG9jYXRpb25zIiwiZnJvbSIsImVudHJpZXMiLCJfIiwiY291bnQiLCJzb3J0IiwiYSIsImIiLCJtdWx0aXBsZVByb3BzQ291bnQiLCJyZWR1Y2UiLCJzdW0iLCJieVNvdXJjZSIsImV4aXN0aW5nIiwiX2dlb2NvZGluZ19zb3VyY2UiLCJ2ZXJpZmllZF9hZGRyZXNzIiwiZnVsbF9hZGRyZXNzIiwicHJvcGVydHlfbmFtZSIsInVua25vd24iLCJtYXAiLCJjb29yZHMiLCJqb2luIiwiY2xlYW5Qcm9wZXJ0eURhdGEiLCJkYXRhSXNzdWVzIiwibWlzc2luZ05hbWVzIiwibmFtZSIsInRyaW0iLCJpbmNvbXBsZXRlQWRkcmVzc2VzIiwiYWRkcmVzcyIsImNpdHkiLCJzdGF0ZSIsInN1c3BpY2lvdXNaZXJvcyIsInByaWNlIiwidW5pdHMiLCJudW1fdW5pdHMiLCJzdXNwaWNpb3VzQ29vcmRpbmF0ZXMiLCJkdXBsaWNhdGVOYW1lcyIsImZpbmREdXBsaWNhdGVzIiwiZHVwbGljYXRlQWRkcmVzc2VzIiwidGVzdFByb3BlcnRpZXMiLCJ0b0xvd2VyQ2FzZSIsIl9pc190ZXN0X3Byb3BlcnR5IiwidG90YWxJc3N1ZXMiLCJjb25maXJtYXRpb24iLCJhZHZhbmNlZE9wdGlvbnMiLCJjbGVhbmVkUHJvcGVydGllcyIsImlzc3Vlc0NsZWFuZWQiLCJwcm9wZXJ0eSIsInByb3BlcnR5Q2xlYW5lZCIsImNsZWFuaW5nTm90ZXMiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInB1c2giLCJhZGRyZXNzUGFydHMiLCJzdGF0ZVBhcnQiLCJzdGF0ZU1hdGNoIiwibWF0Y2giLCJfZGF0YV9xdWFsaXR5X2lzc3VlcyIsIl9kYXRhX2NsZWFuZWQiLCJfY2xlYW5pbmdfbm90ZXMiLCJhcnJheSIsImtleSIsImNvdW50cyIsImR1cGxpY2F0ZXMiLCJpdGVtIiwidmFsdWUiLCJPYmplY3QiLCJrZXlzIiwiZW5yaWNoUHJvcGVydHlEYXRhIiwic3VzcGljaW91c1Byb3BlcnRpZXMiLCJlbnJpY2hlZFByb3BlcnRpZXMiLCJlbnJpY2hlZENvdW50IiwiY2l0eVN0YXRlR3JvdXBzIiwibWVkaWFuVmFsdWVzIiwiZ3JvdXAiLCJwcmljZXNQZXJVbml0IiwidiIsIm1lZGlhblByaWNlUGVyVW5pdCIsImZsb29yIiwieWVhckJ1aWx0IiwieWVhcl9idWlsdCIsInkiLCJtZWRpYW5ZZWFyQnVpbHQiLCJzYW1wbGVTaXplIiwiaXNFbnJpY2hlZCIsImVucmljaG1lbnROb3RlcyIsInJlZmVyZW5jZUdyb3VwIiwicmVmZXJlbmNlS2V5Iiwic3RhdGVHcm91cHMiLCJhbGxQcmljZXNQZXJVbml0Iiwicm91bmQiLCJ0b0xvY2FsZVN0cmluZyIsImVzdGltYXRlZFVuaXRzIiwiX2RhdGFfZW5yaWNoZWQiLCJfZW5yaWNobWVudF9ub3RlcyIsImFkZEdlb2NvZGluZ0xvZyIsInR5cGUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwicHJldkxvZ3MiLCJjbGVhckdlb2NvZGluZ0xvZ3MiLCJ0aXRsZSIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwic3BhbiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJkaXNhYmxlZCIsIm9uQm91bmRzQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/map.js\n"));

/***/ })

});